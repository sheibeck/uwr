---
phase: 3.1-combat-balance
plan: 02
type: execute
wave: 2
depends_on: ["3.1-01"]
files_modified:
  - spacetimedb/src/index.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true

must_haves:
  truths:
    - "STR increases auto-attack damage by ~1.5% per point (multiplicative, gear-dominant)"
    - "DEX provides crit chance (0.1% per point, capped at 50%) with weapon-type-specific multipliers"
    - "Ability damage uses hybrid formula: (base + stat_scaling) * ability_multiplier"
    - "Longer cast time abilities have higher ability multiplier"
    - "WIS increases healing output for healing classes by 2% per point"
    - "Magic abilities are mitigated by magic resistance, physical by armor"
    - "Crit strike events appear in combat log with appropriate messages"
  artifacts:
    - path: "spacetimedb/src/index.ts"
      provides: "Stat-scaled ability damage, WIS healing scaling, magic resist mitigation routing"
      contains: "getAbilityStatScaling"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "STR-scaled auto-attacks, DEX crit strikes, damage type routing"
      contains: "calculateStatScaledAutoAttack"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "imports stat scaling and crit functions"
      pattern: "import.*combat_scaling"
    - from: "spacetimedb/src/index.ts"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "imports ability scaling and healing power functions"
      pattern: "import.*combat_scaling"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/index.ts"
      via: "deps object passes updated functions"
      pattern: "deps\\.rollAttackOutcome"
---

<objective>
Wire stat scaling into the live combat pipeline. This plan integrates the foundation from Plan 01 into auto-attacks (combat.ts), abilities (index.ts executeAbility), healing (index.ts applyHeal), and attack outcome resolution (rollAttackOutcome). Then publish and regenerate bindings.

Purpose: After this plan, stats MATTER in combat. A warrior with high STR hits harder. A rogue with high DEX crits more often. A wizard with high INT casts more powerful spells. A cleric with high WIS heals for more.

Output: Fully functional stat-scaled combat system. Published module. Regenerated client bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3.1-combat-balance/3.1-CONTEXT.md
@.planning/phases/3.1-combat-balance/3.1-RESEARCH.md
@.planning/phases/3.1-combat-balance/3.1-01-SUMMARY.md
@spacetimedb/src/index.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/data/combat_scaling.ts
@spacetimedb/src/data/class_stats.ts
@spacetimedb/src/data/ability_catalog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire stat scaling into auto-attacks and add critical strikes</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**Part A: Update rollAttackOutcome in index.ts (~line 1679) to support critical strikes:**

Modify `rollAttackOutcome` to accept optional `character` and `weaponName` parameters for crit calculation. Change roll granularity from `seed % 100n` to `seed % 1000n` for finer-grained probability.

Updated signature:
```typescript
function rollAttackOutcome(
  seed: bigint,
  opts: {
    canBlock: boolean;
    canParry: boolean;
    canDodge: boolean;
    characterDex?: bigint;
    weaponName?: string;
    weaponType?: string;
  }
)
```

Logic changes (using /1000n scale):
1. Dodge: 50n per 1000 (was 5n per 100)
2. Parry: 50n per 1000
3. Block: 50n per 1000, multiplier stays 50n
4. **NEW - Critical strike:** If `characterDex` is provided, calculate crit chance using `calculateCritChance(characterDex)` from combat_scaling.ts. If roll < cursor + critChance, return `{ outcome: 'crit', multiplier: getCritMultiplier(weaponName ?? '', weaponType) }`. Import `calculateCritChance` and `getCritMultiplier` from combat_scaling.ts.
5. Normal hit: multiplier 100n

Update getCritMultiplier to accept weaponType as optional second arg — if weaponType is set (non-empty), use it directly for lookup; if not, fall back to inferWeaponType(weaponName).

The outcome 'crit' is NEW — update the combat.ts resolveAttack function to handle it. In resolveAttack (~line 401), the `finalDamage = (reducedDamage * outcome.multiplier) / 100n` formula already handles multiplier-based outcomes, so crit damage works automatically via the higher multiplier (150n-250n instead of 100n).

**Part B: Wire STR scaling into player auto-attacks in combat.ts (~line 1629):**

Import `calculateStatScaledAutoAttack` from combat_scaling.ts.

In the player auto-attack section of combat.ts (where `baseDamage` is calculated around line 1629-1635), replace the flat base damage calculation with stat-scaled version:

Current:
```typescript
const baseDamage = 5n + character.level + weapon.baseDamage + (weapon.dps / 2n) + sumEnemyEffect(...);
const damage = baseDamage + wellFedDmgBonus;
```

New:
```typescript
const rawWeaponDamage = 5n + character.level + weapon.baseDamage + (weapon.dps / 2n);
const statScaledDamage = calculateStatScaledAutoAttack(rawWeaponDamage, character.str);
const baseDamage = statScaledDamage + sumEnemyEffect(ctx, combat.id, 'damage_taken', currentEnemy.id);
const damage = baseDamage + wellFedDmgBonus;
```

**Part C: Pass DEX and weapon info to rollAttackOutcome calls in combat.ts:**

For player auto-attacks (~line 1637), update the resolveAttack call to pass character DEX and weapon name:
```typescript
const { finalDamage, nextHp, outcome } = resolveAttack(ctx, {
  seed: outcomeSeed,
  baseDamage: damage,
  // ... existing fields ...
  characterDex: character.dex,
  weaponName: weapon.name,
  weaponType: weapon.weaponType,
});
```

Update the resolveAttack function signature and the rollAttackOutcome call within it to pass the new optional fields through.

**Part D: Add crit-specific combat log messages:**

In combat.ts resolveAttack, add a 'crit' message template to the messages object. Update message resolution to handle 'crit' outcome:
```typescript
messages: {
  // ... existing dodge/miss/parry/block/hit ...
  crit: (damage) => `Critical hit! You hit ${targetName} for ${damage} damage.`,
}
```

For enemy auto-attacks hitting players (the other resolveAttack call around line 2138), do NOT add crit — enemies don't have DEX stats. Leave enemy attacks unchanged.

**Part E: Update deps object export in index.ts (~line 6229):**

Add `calculateStatScaledAutoAttack`, `calculateCritChance`, `getCritMultiplier` to the deps exports so combat.ts can access them, OR import them directly in combat.ts from the data file. Prefer direct import from combat_scaling.ts in combat.ts since these are pure functions with no database dependency.

IMPORTANT: The `resolveAttack` function in combat.ts needs to forward `characterDex`, `weaponName`, and `weaponType` to `rollAttackOutcome`. Add these as optional fields to the resolveAttack options object. Only pass them to rollAttackOutcome when present.
  </action>
  <verify>
Run TypeScript compiler:
```
cd C:/projects/uwr/spacetimedb && npx tsc --noEmit
```
Grep for `calculateStatScaledAutoAttack` in combat.ts to confirm STR scaling is wired.
Grep for `characterDex` in combat.ts to confirm crit system is wired.
Grep for `'crit'` in combat.ts to confirm crit log messages exist.
  </verify>
  <done>
Player auto-attacks use STR-scaled damage via multiplicative formula. rollAttackOutcome supports DEX-based critical strikes with weapon-type-specific multipliers. Crit outcomes appear in combat log. Enemy attacks unchanged. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire stat scaling into abilities, healing, damage type routing, publish and regenerate</name>
  <files>
    spacetimedb/src/index.ts
  </files>
  <action>
**Part A: Wire stat scaling into ability damage (index.ts, executeAbility function ~line 1985):**

Import `getAbilityStatScaling`, `getAbilityMultiplier`, `applyMagicResistMitigation` from combat_scaling.ts. Import `ABILITIES` damageType from ability_catalog.ts.

In the `applyDamage` inner function of executeAbility (~line 1985-2067), integrate the hybrid ability formula. The current damage calculation is:

```typescript
const raw = abilityDamageFromWeapon(baseWeaponDamage, percent, bonus) + totalDamageUp + sumEnemyEffect(...);
const reduced = applyArmorMitigation(raw, armor);
```

Change to:
```typescript
// Get ability info for stat scaling
const abilityEntry = ABILITIES[abilityKey as keyof typeof ABILITIES];
const statScaling = getAbilityStatScaling(
  { str: character.str, dex: character.dex, cha: character.cha, wis: character.wis, int: character.int },
  abilityKey,
  character.className
);
const abilityMultiplier = abilityEntry
  ? getAbilityMultiplier(abilityEntry.castSeconds, abilityEntry.cooldownSeconds)
  : 100n;

// Hybrid formula: (base + stat_scaling) * ability_multiplier / 100
const abilityBaseDamage = abilityEntry ? abilityEntry.power * 10n : 0n;
const scaledAbilityDamage = ((abilityBaseDamage + statScaling) * abilityMultiplier) / 100n;

// Weapon component (for weapon abilities that use percent > 0)
const weaponComponent = percent > 0n ? abilityDamageFromWeapon(baseWeaponDamage, percent, bonus) : 0n;

// Total raw damage
const raw = weaponComponent + scaledAbilityDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);

// Route mitigation by damage type
const dmgType = abilityEntry?.damageType ?? 'physical';
let reduced: bigint;
if (dmgType === 'magic') {
  // Magic damage: apply magic resistance if enemy has it, then armor at reduced rate
  // For now enemies don't have magicResistance field, so magic bypasses armor entirely
  // (This makes magic damage impactful as per user decision: "Makes magic damage impactful")
  reduced = raw > 0n ? raw : 1n;
} else {
  // Physical damage: apply armor mitigation as before
  reduced = applyArmorMitigation(raw, armor);
}
```

NOTE: The `percent` and `bonus` parameters come from each ability's switch case. Many abilities call `applyDamage(100n, 0n)` or `applyDamage(120n, 5n)`. The weapon component should ONLY be added when `percent > 0n`. For pure spells that call `applyDamage(0n, 0n)` and then override damage directly, the scaledAbilityDamage provides the stat-scaled value.

Review each ability switch case in executeAbility. Many damage abilities call `applyDamage(percent, bonus)` — these will automatically get stat scaling. Some abilities manually compute damage — these need individual attention:
- Abilities that call `applyDamage(100n, 0n)` or similar: automatic stat scaling works.
- Abilities that deal damage through effects (dots, debuffs): leave those unchanged for now — they scale through their own magnitude values.
- Pet damage: leave unchanged — pets have their own damage formula.

**Part B: Wire WIS healing scaling into applyHeal (index.ts ~line 2070):**

Import `calculateHealingPower` from combat_scaling.ts.

In the `applyHeal` inner function, apply WIS scaling:

Current:
```typescript
const applyHeal = (target: typeof Character.rowType, amount: bigint, source: string) => {
  const current = ctx.db.character.id.find(target.id);
  if (!current) return;
  const nextHp = current.hp + amount > current.maxHp ? current.maxHp : current.hp + amount;
```

New:
```typescript
const applyHeal = (target: typeof Character.rowType, amount: bigint, source: string) => {
  const current = ctx.db.character.id.find(target.id);
  if (!current) return;
  // Apply WIS scaling to healing output (uses the CASTER's WIS, not target's)
  const scaledAmount = calculateHealingPower(amount, character.wis, character.className);
  const nextHp = current.hp + scaledAmount > current.maxHp ? current.maxHp : current.hp + scaledAmount;
  ctx.db.character.id.update({ ...current, hp: nextHp });
  const message = `${source} restores ${scaledAmount} health to ${current.name}.`;
```

Note: `character` here refers to the CASTER (the character executing the ability), which is the correct source for WIS scaling.

**Part C: Update self-heal abilities that use fixed amounts:**

Several abilities have hardcoded heal amounts that should now also benefit from stat scaling. The applyHeal function handles this automatically since it uses the caster's WIS. Verify these calls pass through applyHeal:
- `shaman_spirit_mender`: `applyHeal(targetCharacter, 6n, 'Spirit Mender')` -- OK, goes through applyHeal
- `cleric_mend`: `applyHeal(targetCharacter, 10n, 'Mend')` -- OK
- `cleric_heal`: `applyHeal(targetCharacter, 15n, 'Heal')` -- OK
- `paladin_lay_on_hands`: `applyHeal(target, missing, 'Lay on Hands')` -- OK (scales with WIS)
- `necromancer_plague_spark`: `applyHeal(character, 2n, 'Plague Spark')` -- self-heal, Necro has INT not WIS, so no scaling (correct per design)
- `druid_thorn_lash`: `applyHeal(character, 3n, 'Thorn Lash')` -- Druid has WIS primary, so this WILL scale (correct)
- `reaver_blood_rend`: `applyHeal(character, leech, 'Blood Rend')` -- Reaver has STR primary, no WIS scaling (correct)

No additional changes needed — the applyHeal function handles all cases correctly.

**Part D: Publish and regenerate bindings:**

After all code changes:
1. Publish with clear-database: `spacetime publish uwr --clear-database -y --project-path C:/projects/uwr/spacetimedb`
2. Regenerate client bindings: `spacetime generate --lang typescript --out-dir C:/projects/uwr/src/module_bindings --project-path C:/projects/uwr/spacetimedb`
3. Verify client builds: `cd C:/projects/uwr && npx vue-tsc --noEmit`

If the default server is maincloud (check `spacetime server list`), publish to maincloud.
  </action>
  <verify>
1. TypeScript compile: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit`
2. Publish succeeds: `spacetime publish uwr --clear-database -y --project-path C:/projects/uwr/spacetimedb`
3. Bindings regenerate: `spacetime generate --lang typescript --out-dir C:/projects/uwr/src/module_bindings --project-path C:/projects/uwr/spacetimedb`
4. Client compiles: `cd C:/projects/uwr && npx vue-tsc --noEmit`
5. Grep for key integrations:
   - `getAbilityStatScaling` in index.ts (ability scaling wired)
   - `calculateHealingPower` in index.ts (healing scaling wired)
   - `damageType` in index.ts (damage type routing wired)
  </verify>
  <done>
Ability damage uses hybrid formula with stat scaling and ability multiplier. WIS scales healing for healing classes. Magic damage bypasses armor (impactful). Physical damage uses tuned armor curve. Module published. Bindings regenerated. Client compiles.
  </done>
</task>

</tasks>

<verification>
- `spacetime publish` succeeds without errors
- `spacetime generate` produces updated bindings
- Client `vue-tsc --noEmit` passes
- Grep confirms stat scaling functions are called in combat pipeline
- Grep confirms damageType routing exists in applyDamage
- Grep confirms calculateHealingPower is called in applyHeal
- Check `spacetime logs uwr` after a test combat for stat scaling in damage numbers
</verification>

<success_criteria>
Complete stat-scaled combat system is live. STR scales auto-attacks. DEX enables crits with weapon-type multipliers. INT/WIS/CHA/STR scale ability damage per class. WIS scales healing. Magic bypasses armor. Physical uses tuned armor curve. Module published and client bindings regenerated.
</success_criteria>

<output>
After completion, create `.planning/phases/3.1-combat-balance/3.1-02-SUMMARY.md`
</output>
