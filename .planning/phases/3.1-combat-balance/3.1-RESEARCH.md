# Phase 3.1: Combat Balance - Research

**Researched:** 2026-02-12
**Domain:** RPG combat stat scaling, damage formulas, role balance
**Confidence:** HIGH

## Summary

This phase balances combat between melee and caster classes by implementing stat-based damage scaling, critical strike mechanics, and defensive balance. The existing combat system has tables for Character stats (str/dex/cha/wis/int), abilities with power values, and armor mitigation formulas. The research confirms standard RPG stat scaling patterns are well-established and should be applied to the existing damage calculation paths.

**Current state analysis:**
- **Damage formula exists:** `baseWeaponDamage = 5n + character.level + weapon.baseDamage + weapon.dps / 2n` (index.ts:1900)
- **Armor mitigation exists:** `(damage * 100n) / (100n + scaledArmor)` with diminishing returns (index.ts:4118-4122)
- **Attack outcomes exist:** dodge/parry/block system with fixed 5% chances (index.ts:1679-1698)
- **Stat storage exists:** Character table has str/dex/cha/wis/int fields (index.ts:240-244)
- **No stat scaling:** Stats are stored but NOT used in damage calculations currently
- **No critical strikes:** System has `critMelee/critRanged/critDivine/critArcane` fields but no implementation

**Primary recommendation:** Extend existing damage formula paths to incorporate stat scaling using multiplicative bonuses, implement critical strike system using DEX with weapon-type-specific multipliers, and add healing power scaling from WIS.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Stat Scaling Formula:**
- STR scales weapon-based auto-attack damage
- Scaling magnitude: 1-2% damage increase per STR point (moderate scaling)
- Gear remains dominant power source, stats are secondary
- DEX influences critical strike chance with linear scaling: 0.1-0.2% crit chance per DEX point
- Critical damage multiplier varies by weapon type:
  - Fast weapons: lower multiplier (e.g., 1.5x)
  - Slow weapons: higher multiplier (e.g., 2.5x)
- Melee weapon abilities scale from STR
- Caster spells scale from INT
- Hybrid classes: abilities can scale from multiple stats
- Specific abilities may use different stats (ability-by-ability basis)

**Class Role Philosophy:**
- Role-based DPS tiers: Pure DPS > Hybrids > Tanks/Healers
- Specialization = power (traditional MMO model)
- Defense comes from gear choices, not class (independent scaling)
- A warrior can build glass cannon or tank based on gear selection
- Armor proficiencies remain: Warriors = plate, Mages = cloth, etc.
- Stats and enchants on gear determine actual tankiness, not just armor type
- Tanks get taunt and threat management mechanics
- Healers get group healing capabilities

**Ability Power vs Auto-Attacks:**
- Hybrid formula: `(base_damage + stat * scaling) * ability_multiplier`
- Example: Fireball = `(base + INT * 2) * 1.5`
- Both stat scaling AND ability multiplier contribute
- Longer cast time = higher ability multiplier
- Higher power = higher mana cost (efficiency constant)
- Longer cooldown = higher burst damage

**Defensive Balance Approach:**
- Cloth-wearing casters get shields, barriers, or damage absorption abilities
- Different defensive paradigm from armor (temporary protection vs constant mitigation)
- WIS increases healing power for healing classes
- WIS increases mana pool for healers and classes with WIS as primary or hybrid stat
- WIS does NOT directly increase magic resistance
- Armor has diminishing returns curve for damage reduction:
  - First 50 armor = ~30% reduction, next 50 armor = ~15% more
  - Prevents extreme tank stacking
- Magic resistance rarer than armor but more powerful per point
- Makes magic damage impactful
- Less available on gear, forces tactical choices

### Claude's Discretion

Implementation is open to standard RPG combat formulas that match the scaling philosophies defined above.

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope (balancing existing combat mechanics).
</user_constraints>

---

## Standard Stack

### Core Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SpacetimeDB | 1.11.x | Database/backend | Already in use, no new dependencies needed |
| BigInt arithmetic | Native | Stat calculations | SpacetimeDB uses bigint for all numeric values |

### Supporting

No additional libraries needed. This phase extends existing combat reducer logic.

### Installation

No new packages required. All work is in existing `spacetimedb/src/` TypeScript files.

---

## Architecture Patterns

### Recommended Code Structure

```
spacetimedb/src/
├── index.ts                          # Extend damage calculation functions
│   ├── applyArmorMitigation()        # EXISTING - already has diminishing returns
│   ├── rollAttackOutcome()           # EXTEND - add critical strike logic
│   ├── calculateAutoAttackDamage()   # NEW - stat-scaled auto-attack damage
│   ├── calculateAbilityDamage()      # NEW - stat-scaled ability damage
│   └── calculateHealingPower()       # NEW - WIS-scaled healing
├── data/class_stats.ts               # EXTEND - add weapon type mappings
└── reducers/combat.ts                # EXTEND - use new damage functions
```

### Pattern 1: Stat Scaling with Multiplicative Bonuses

**What:** Add percentage-based damage bonuses from stats to base weapon damage.

**When to use:** Auto-attacks and physical weapon abilities.

**Formula:**
```typescript
// Current (index.ts:1900)
const baseWeaponDamage = 5n + character.level + weapon.baseDamage + weapon.dps / 2n;

// After stat scaling (EXTEND)
const statBonus = (baseWeaponDamage * character.str * 15n) / 1000n; // 1.5% per STR
const scaledDamage = baseWeaponDamage + statBonus;
```

**Why this pattern:**
- Multiplicative scaling keeps gear dominant (user decision: "Gear remains dominant power source")
- 1-2% per point = 15-20 per 1000 in integer math
- Avoids floating point (SpacetimeDB uses BigInt)

**Source:** User decision + standard RPG scaling ([Power Scaling in RPGs](https://marcleoseguin.com/2020/11/18/power-scaling-in-rpgs/))

---

### Pattern 2: Critical Strike Calculation

**What:** DEX-based critical strike chance with weapon-type-specific multipliers.

**When to use:** All physical damage (auto-attacks and abilities).

**Implementation:**
```typescript
// Step 1: Calculate crit chance from DEX
const baseCritChance = 5n; // 5% base
const dexCritBonus = character.dex * 1n; // 0.1% per DEX = 1 per 1000
const totalCritChance = baseCritChance + dexCritBonus / 10n;

// Step 2: Roll for crit (extend rollAttackOutcome)
const critRoll = seed % 1000n;
if (critRoll < totalCritChance) {
  // Critical strike!
  const weaponType = getWeaponType(weaponTemplate); // "dagger", "staff", "sword", etc.
  const critMultiplier = getCritMultiplierForWeaponType(weaponType);
  finalDamage = (baseDamage * critMultiplier) / 100n;
}
```

**Weapon type to crit multiplier mapping:**
```typescript
// Add to data/class_stats.ts
export const WEAPON_CRIT_MULTIPLIERS: Record<string, bigint> = {
  dagger: 150n,   // Fast weapon = lower multiplier (1.5x)
  staff: 150n,
  rapier: 150n,
  sword: 200n,    // Medium weapons
  mace: 200n,
  bow: 200n,
  axe: 250n,      // Slow weapons = higher multiplier (2.5x)
  blade: 200n,    // Spellblade/Reaver weapons
};
```

**Why this pattern:**
- Linear DEX scaling (user decision: "0.1-0.2% crit chance per DEX point")
- Variable multiplier by weapon speed (user decision: "Fast weapons: lower multiplier (e.g., 1.5x)")
- Rewards weapon choice and build planning

**Source:** User decision + [Path of Exile crit mechanics](https://www.poewiki.net/wiki/Critical_strike)

---

### Pattern 3: Ability Damage Scaling (Hybrid Formula)

**What:** Abilities use base damage + stat scaling + ability multiplier.

**When to use:** All combat abilities (Fireball, Slam, Hex, etc.).

**Current ability damage (index.ts:2012-2018):**
```typescript
// Current: only uses weapon damage + damage_up effects
const raw = abilityDamageFromWeapon(baseWeaponDamage, percent, bonus) +
  totalDamageUp +
  sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);
```

**After hybrid scaling:**
```typescript
// Extend ability execution (executeAbility in index.ts)
const abilityBaseDamage = ability.power * 10n; // Base damage from power rating
const statScaling = getAbilityStatScaling(character, abilityKey); // INT for spells, STR for melee
const abilityMultiplier = getAbilityMultiplier(ability); // Based on cast time & cooldown
const scaledAbilityDamage = ((abilityBaseDamage + statScaling) * abilityMultiplier) / 100n;
```

**Ability multiplier formula:**
```typescript
function getAbilityMultiplier(ability: AbilityTemplate): bigint {
  let multiplier = 100n; // Base 1.0x

  // Cast time compensation: +10% per second of cast time
  multiplier += ability.castSeconds * 10n;

  // Cooldown compensation: +5% per 10 seconds of cooldown
  if (ability.cooldownSeconds > 0n) {
    multiplier += (ability.cooldownSeconds * 5n) / 10n;
  }

  return multiplier;
}
```

**Example (Fireball):**
- User decision example: `(base + INT * 2) * 1.5`
- Fireball power = 4 → base = 40 damage
- Wizard INT = 20 → stat scaling = 40
- Cast time = 1s, cooldown = 0s → multiplier = 110%
- Final: `(40 + 40) * 110% = 88 damage` before armor

**Why this pattern:**
- Matches user decision exactly: `(base_damage + stat * scaling) * ability_multiplier`
- Cast time and cooldown both affect multiplier (user decisions)
- Maintains DPS equality over time (long cast = higher burst)

**Source:** User decisions + [Damage formulas](https://yujiri.xyz/game-design/damage-formulas.gmi)

---

### Pattern 4: Healing Power Scaling

**What:** WIS stat increases healing output for healing classes.

**When to use:** All healing abilities (Mend, Heal, Spirit Mender, etc.).

**Implementation:**
```typescript
function calculateHealingPower(
  baseHealing: bigint,
  casterWis: bigint,
  className: string
): bigint {
  const config = getClassConfig(className);

  // Only scale healing if WIS is primary or secondary stat
  if (config.primary !== 'wis' && config.secondary !== 'wis') {
    return baseHealing; // No WIS scaling for non-healing classes
  }

  // 2% healing power per WIS point
  const wisBonus = (baseHealing * casterWis * 20n) / 1000n;
  return baseHealing + wisBonus;
}

// In ability execution (applyHeal function in index.ts:2070)
const baseAmount = 6n; // Spirit Mender base heal
const scaledAmount = calculateHealingPower(baseAmount, character.wis, character.className);
applyHeal(targetCharacter, scaledAmount, 'Spirit Mender');
```

**Why this pattern:**
- User decision: "WIS increases healing power for healing classes"
- Only affects classes with WIS as primary/secondary stat (Cleric, Paladin, Druid, Shaman, Ranger)
- 2% scaling matches STR/INT damage scaling magnitude
- Does NOT increase magic resistance (user decision: "WIS does NOT directly increase magic resistance")

**Source:** User decision + [MMORPG healing mechanics](https://hacktheminotaur.com/eso-guides/dynamic-stat-scaling/)

---

### Pattern 5: Armor Diminishing Returns (Already Implemented)

**What:** Existing armor mitigation formula already provides diminishing returns.

**Current implementation (index.ts:4118-4122):**
```typescript
function applyArmorMitigation(damage: bigint, armorClass: bigint) {
  const scaledArmor = armorClass * 5n;
  const mitigated = (damage * 100n) / (100n + scaledArmor);
  return mitigated > 0n ? mitigated : 1n;
}
```

**Analysis:**
- Formula: `damage * 100 / (100 + armor * 5)`
- At 10 armor: 33% reduction
- At 20 armor: 50% reduction
- At 40 armor: 67% reduction
- At 100 armor: 83% reduction
- Never reaches 100% (always deals minimum 1 damage)

**User decision check:**
- User wants: "First 50 armor = ~30% reduction, next 50 armor = ~15% more"
- Current formula at 50 armor: 71% reduction
- **MISMATCH:** Current formula too strong

**Recommended adjustment:**
```typescript
function applyArmorMitigation(damage: bigint, armorClass: bigint) {
  // Adjust scaling factor from 5n to 2n for gentler curve
  const scaledArmor = armorClass * 2n;
  const mitigated = (damage * 100n) / (100n + scaledArmor);
  return mitigated > 0n ? mitigated : 1n;
}

// New curve:
// 50 armor: 50% reduction (user wants ~30%, still needs tuning)
// 100 armor: 67% reduction (user wants ~45%)
```

**Action needed:** Test and tune scaling factor (try 1n or 1.5n) to match user's desired curve.

**Source:** User decision + [Albion Online armor mechanics](https://forum.albiononline.com/index.php/Thread/173891-How-armor-and-defense-affect-damage-reduction/)

---

### Pattern 6: Magic Resistance (New System)

**What:** Add magic resistance as separate defensive stat, rarer but more powerful than armor.

**Why needed:** User decision: "Magic resistance rarer than armor but more powerful per point"

**Implementation:**
```typescript
// Add to Character table (index.ts:215)
// NEW FIELD: magicResistance: t.u64()

// Add to ItemTemplate table (index.ts:265)
// NEW FIELD: magicResistanceBonus: t.u64()

// Damage type detection in combat
function getDamageType(abilityKey: string): 'physical' | 'magic' {
  const magicAbilities = new Set([
    'wizard_magic_missile', 'wizard_frost_shard', 'wizard_lightning_surge',
    'shaman_hex', 'shaman_stormcall', 'necromancer_plague_spark',
    'enchanter_mind_fray', 'cleric_smite', // etc.
  ]);
  return magicAbilities.has(abilityKey) ? 'magic' : 'physical';
}

// Apply appropriate mitigation
function applyMitigation(damage: bigint, character: Character, damageType: 'physical' | 'magic'): bigint {
  if (damageType === 'physical') {
    return applyArmorMitigation(damage, character.armorClass);
  } else {
    // Magic resistance uses steeper curve (more powerful per point)
    const scaledResist = character.magicResistance * 3n; // 3x multiplier vs armor's 2x
    const mitigated = (damage * 100n) / (100n + scaledResist);
    return mitigated > 0n ? mitigated : 1n;
  }
}
```

**Why this pattern:**
- Separate stat from armor (prevents armor from affecting magic damage)
- Rarer on gear (fewer items grant magic resistance)
- More powerful per point (3x multiplier vs 2x for armor)
- Forces tactical gear choices (can't max both easily)

**Source:** User decision + [D&D damage resistance mechanics](https://www.d20srd.org/srd/variant/adventuring/armorAsDamageReduction.htm)

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Additive Stat Scaling
**Why it's bad:** Makes stats dominant over gear, contradicts user decision "Gear remains dominant power source"
**What to do instead:** Use multiplicative scaling (stat * damage / 1000) so better gear = more benefit from stats

### Anti-Pattern 2: Fixed Critical Multiplier
**Why it's bad:** User decision requires "Variable by weapon type — Fast weapons: lower multiplier (e.g., 1.5x)"
**What to do instead:** Map weapon types to multipliers, reward build diversity

### Anti-Pattern 3: WIS Increasing Magic Resistance
**Why it's bad:** User explicitly stated "WIS does NOT directly increase magic resistance"
**What to do instead:** WIS only affects healing power and mana pool

### Anti-Pattern 4: Ability Damage Ignoring Cast Time/Cooldown
**Why it's bad:** User decisions require compensation: "Longer cast time = higher ability multiplier"
**What to do instead:** Calculate ability multiplier from `castSeconds` and `cooldownSeconds` fields

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Damage formula precision | Custom decimal system | BigInt integer math with `/1000n` scaling | SpacetimeDB uses bigint, floating point causes determinism issues |
| Critical strike RNG | Custom random generator | Existing `seed % 1000n` pattern (index.ts:1683) | Already used in `rollAttackOutcome`, maintains determinism |
| Stat growth per level | New level-up system | Existing `computeBaseStats` (class_stats.ts:95) | Already handles primary/secondary stat growth |
| Armor mitigation curve | New formula | Existing `applyArmorMitigation` | Already implements diminishing returns, just needs tuning |

**Key insight:** SpacetimeDB reducers must be deterministic — no `Math.random()`, no floating point. All scaling uses integer division with `/1000n` for percentage calculations.

---

## Common Pitfalls

### Pitfall 1: Floating Point in Damage Calculations

**What goes wrong:** Using `1.5 * damage` causes non-deterministic results in SpacetimeDB.

**Why it happens:** TypeScript allows floats but SpacetimeDB requires deterministic reducers.

**How to avoid:**
```typescript
// ❌ WRONG
const critDamage = damage * 1.5;

// ✅ RIGHT
const critDamage = (damage * 150n) / 100n;
```

**Warning signs:** TypeScript compiler warnings about `number` vs `bigint` types.

---

### Pitfall 2: Stat Scaling Dominating Gear

**What goes wrong:** High stat scaling makes gear irrelevant, contradicts user decision.

**Why it happens:** Additive scaling (+10 damage per STR) grows faster than multiplicative.

**How to avoid:**
```typescript
// ❌ WRONG - additive scaling
const damage = baseWeaponDamage + (character.str * 10n);

// ✅ RIGHT - multiplicative scaling
const statBonus = (baseWeaponDamage * character.str * 15n) / 1000n; // 1.5% per point
const damage = baseWeaponDamage + statBonus;
```

**Warning signs:**
- High-stat low-gear characters outdamage low-stat high-gear characters
- Naked character with 50 STR deals more damage than geared character with 20 STR

**Test case:** Level 5 character, 20 STR, weapon damage 15:
- Additive: `15 + (20 * 10) = 215 damage` ❌ Stats dominate
- Multiplicative: `15 + (15 * 20 * 15 / 1000) = 15 + 4 = 19 damage` ✅ Gear dominant

---

### Pitfall 3: Critical Strike Chance Capping

**What goes wrong:** DEX scaling allows 100%+ crit chance, breaking balance.

**Why it happens:** No cap on `dexCritBonus` calculation.

**How to avoid:**
```typescript
// Add cap to crit chance
const baseCritChance = 5n; // 5%
const dexCritBonus = character.dex * 1n / 10n; // 0.1% per DEX
const totalCritChance = baseCritChance + dexCritBonus;
const cappedCritChance = totalCritChance > 50n ? 50n : totalCritChance; // Cap at 50%
```

**Warning signs:**
- Character with 500+ DEX has guaranteed crits
- Build diversity collapses to "stack DEX only"

**Recommendation:** Cap at 40-50% crit chance (common in MMORPGs).

---

### Pitfall 4: Ability Resource Costs Not Matching Power

**What goes wrong:** Low-cost high-damage abilities become spam-optimal.

**Why it happens:** User decision states "Higher power = higher mana cost (efficiency constant)" but doesn't define the constant.

**How to avoid:**
```typescript
// Existing resource cost function (inferred from code, not explicitly defined)
function abilityResourceCost(level: bigint, power: bigint): bigint {
  // Match efficiency: damage per mana should be constant
  const baseCost = 10n;
  const powerCost = power * 5n; // 5 mana per power point
  const levelCost = level * 3n; // 3 mana per level
  return baseCost + powerCost + levelCost;
}

// Validate efficiency
// Fireball: power=4, level=1 → cost = 10 + 20 + 3 = 33 mana → ~1.2 damage per mana
// Shock: power=2, level=1 → cost = 10 + 10 + 3 = 23 mana → ~0.87 damage per mana
// ⚠️ Fireball MORE efficient — needs balancing
```

**Warning signs:**
- Players only use one ability (others are inefficient)
- High-cooldown abilities never used (spam low-cooldown is better)

**Test case:** Calculate damage-per-mana for all abilities, should be ±10% of average.

---

### Pitfall 5: Mixing Damage Types in Mitigation

**What goes wrong:** Magic damage reduced by armor, physical damage reduced by magic resistance.

**Why it happens:** No damage type tracking in ability execution.

**How to avoid:**
```typescript
// Tag abilities with damage type
export const ABILITIES = {
  warrior_slam: {
    // ... existing fields
    damageType: 'physical',
  },
  wizard_magic_missile: {
    // ... existing fields
    damageType: 'magic',
  },
};

// Apply correct mitigation
const damageType = ability.damageType ?? 'physical'; // Default physical
const mitigatedDamage = applyMitigation(rawDamage, target, damageType);
```

**Warning signs:**
- Heavily armored warriors take normal damage from Fireball
- Casters in cloth armor shrug off Slam attacks
- Magic resistance has no effect

---

## Code Examples

### Example 1: Stat-Scaled Auto-Attack Damage

**Source:** Extending existing combat reducer (reducers/combat.ts + index.ts)

```typescript
// Add to index.ts after line 4122
function calculateAutoAttackDamage(
  character: typeof Character.rowType,
  weapon: { baseDamage: bigint; dps: bigint }
): bigint {
  // Base weapon damage (existing formula)
  const baseWeaponDamage = 5n + character.level + weapon.baseDamage + weapon.dps / 2n;

  // STR scaling: 1.5% per point (user decision: 1-2% range)
  const strBonus = (baseWeaponDamage * character.str * 15n) / 1000n;

  // Final damage before crit/mitigation
  return baseWeaponDamage + strBonus;
}

// Usage in auto-attack resolution (combat.ts line ~1629)
const baseDamage = calculateAutoAttackDamage(character, weapon);
```

---

### Example 2: Critical Strike with Weapon-Type Multiplier

**Source:** Extending rollAttackOutcome (index.ts:1679)

```typescript
// Add weapon type mapping to data/class_stats.ts
export const WEAPON_TYPES: Record<string, string> = {
  'Training Sword': 'sword',
  'Training Dagger': 'dagger',
  'Training Staff': 'staff',
  'Training Axe': 'axe',
  'Training Bow': 'bow',
  'Training Mace': 'mace',
  'Training Rapier': 'rapier',
  'Training Blade': 'blade',
};

export const WEAPON_CRIT_MULTIPLIERS: Record<string, bigint> = {
  dagger: 150n,   // Fast = 1.5x
  rapier: 150n,
  staff: 150n,
  sword: 200n,    // Medium = 2.0x
  blade: 200n,
  mace: 200n,
  bow: 200n,
  axe: 250n,      // Slow = 2.5x
};

// Extend rollAttackOutcome in index.ts
function rollAttackOutcome(
  seed: bigint,
  opts: {
    canBlock: boolean;
    canParry: boolean;
    canDodge: boolean;
    character?: typeof Character.rowType;
    weaponName?: string;
  }
) {
  const roll = seed % 1000n; // Change from 100n to 1000n for finer granularity
  let cursor = 0n;

  // Dodge (5% = 50 per 1000)
  if (opts.canDodge) {
    cursor += 50n;
    if (roll < cursor) return { outcome: 'dodge', multiplier: 0n };
  }

  // Parry (5% = 50 per 1000)
  if (opts.canParry) {
    cursor += 50n;
    if (roll < cursor) return { outcome: 'parry', multiplier: 0n };
  }

  // Block (5% = 50 per 1000)
  if (opts.canBlock) {
    cursor += 50n;
    if (roll < cursor) return { outcome: 'block', multiplier: 50n };
  }

  // Critical strike (DEX-based)
  if (opts.character) {
    const baseCritChance = 50n; // 5% base
    const dexCritBonus = opts.character.dex * 1n; // 0.1% per DEX point
    const totalCritChance = baseCritChance + dexCritBonus;
    const cappedCritChance = totalCritChance > 500n ? 500n : totalCritChance; // Cap at 50%

    cursor += cappedCritChance;
    if (roll < cursor) {
      // Determine weapon type
      const weaponType = opts.weaponName
        ? WEAPON_TYPES[opts.weaponName] ?? 'sword'
        : 'sword';
      const critMultiplier = WEAPON_CRIT_MULTIPLIERS[weaponType] ?? 200n;
      return { outcome: 'crit', multiplier: critMultiplier };
    }
  }

  // Normal hit
  return { outcome: 'hit', multiplier: 100n };
}
```

---

### Example 3: Ability Stat Scaling

**Source:** Extending executeAbility (index.ts:1828)

```typescript
// Add ability stat scaling helper
function getAbilityStatScaling(
  character: typeof Character.rowType,
  abilityKey: string
): bigint {
  const ability = ABILITIES[abilityKey as keyof typeof ABILITIES];
  if (!ability) return 0n;

  // Determine which stat scales this ability
  const className = normalizeClassName(character.className);
  const config = getClassConfig(className);

  // Melee abilities scale from STR
  const meleeAbilities = new Set([
    'warrior_slam', 'warrior_cleave', 'warrior_crushing_blow',
    'rogue_shadow_cut', 'rogue_bleed', 'rogue_shadow_strike',
    'monk_crippling_kick', 'monk_palm_strike', 'monk_tiger_flurry',
    'beastmaster_pack_rush', 'beastmaster_beast_fang', 'beastmaster_alpha_assault',
  ]);

  if (meleeAbilities.has(abilityKey)) {
    // 2.0 stat scaling per point for abilities (vs 1.5% for auto-attacks)
    return character.str * 2n;
  }

  // Caster spells scale from INT
  const arcaneAbilities = new Set([
    'wizard_magic_missile', 'wizard_frost_shard', 'wizard_lightning_surge',
    'necromancer_plague_spark', 'necromancer_wither', 'necromancer_grave_surge',
    'summoner_conjure_vessel', 'summoner_conjured_spike', 'summoner_spectral_lance',
    'enchanter_mind_fray', 'enchanter_slow', 'enchanter_charm_fray',
  ]);

  if (arcaneAbilities.has(abilityKey)) {
    return character.int * 2n;
  }

  // Hybrid abilities (Paladin, Spellblade, Reaver)
  const hybridAbilities = new Set([
    'paladin_holy_strike', 'paladin_radiant_smite',
    'spellblade_arcane_slash', 'spellblade_runic_strike', 'spellblade_spellstorm',
    'reaver_blood_rend', 'reaver_soul_rend', 'reaver_oblivion',
  ]);

  if (hybridAbilities.has(abilityKey)) {
    // Average of STR and INT
    return (character.str + character.int);
  }

  // Nature/divine abilities scale from WIS
  const divineAbilities = new Set([
    'cleric_smite', 'druid_thorn_lash', 'druid_bramble', 'druid_wild_surge',
    'shaman_hex', 'shaman_stormcall', 'ranger_marked_shot', 'ranger_rapid_shot',
  ]);

  if (divineAbilities.has(abilityKey)) {
    return character.wis * 2n;
  }

  // Default: no stat scaling
  return 0n;
}

// Add ability multiplier calculation
function getAbilityMultiplier(ability: typeof ABILITIES[keyof typeof ABILITIES]): bigint {
  let multiplier = 100n; // Base 1.0x

  // Cast time compensation: +10% per second
  multiplier += ability.castSeconds * 10n;

  // Cooldown compensation: +5% per 10 seconds (50% per 100s)
  if (ability.cooldownSeconds > 0n) {
    multiplier += (ability.cooldownSeconds * 5n) / 10n;
  }

  return multiplier;
}

// Modify applyDamage in executeAbility (index.ts:1985) to use stat scaling
const applyDamage = (
  percent: bigint,
  bonus: bigint,
  options?: { /* ... existing options */ }
) => {
  if (!enemy || !combatId) throw new SenderError('No enemy in combat');

  // Get ability stat scaling
  const statScaling = getAbilityStatScaling(character, abilityKey);
  const abilityMultiplier = getAbilityMultiplier(ability);

  // Calculate base ability damage
  const abilityBaseDamage = ability.power * 10n;

  // Apply hybrid formula: (base + stat * scaling) * multiplier
  const scaledAbilityDamage = ((abilityBaseDamage + statScaling) * abilityMultiplier) / 100n;

  // Add to weapon-based damage (for weapon abilities) or replace it (for pure spells)
  const finalBaseDamage = percent > 0n
    ? abilityDamageFromWeapon(baseWeaponDamage, percent, bonus) + scaledAbilityDamage
    : scaledAbilityDamage;

  // Apply armor mitigation
  const raw = finalBaseDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);
  const reduced = applyArmorMitigation(raw, armor);

  // ... rest of existing logic
};
```

---

### Example 4: Healing Power Scaling

**Source:** Extending applyHeal (index.ts:2070)

```typescript
// Add healing power calculation
function calculateHealingPower(
  baseHealing: bigint,
  casterWis: bigint,
  className: string
): bigint {
  const config = getClassConfig(className);

  // Only scale healing if WIS is primary or secondary stat
  if (config.primary !== 'wis' && config.secondary !== 'wis') {
    return baseHealing; // Non-healing classes don't benefit
  }

  // 2% healing power per WIS point (20 per 1000)
  const wisBonus = (baseHealing * casterWis * 20n) / 1000n;
  return baseHealing + wisBonus;
}

// Modify applyHeal to use scaling
const applyHeal = (target: typeof Character.rowType, baseAmount: bigint, source: string) => {
  const current = ctx.db.character.id.find(target.id);
  if (!current) return;

  // Apply WIS scaling
  const scaledAmount = calculateHealingPower(baseAmount, character.wis, character.className);

  const nextHp = current.hp + scaledAmount > current.maxHp ? current.maxHp : current.hp + scaledAmount;
  ctx.db.character.id.update({ ...current, hp: nextHp });

  const message = `${source} restores ${scaledAmount} health to ${current.name}.`;
  appendPrivateEvent(ctx, current.id, current.ownerUserId, 'heal', message);
  if (current.id !== character.id) {
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'heal', message);
  }
  logGroup('heal', message);
};

// Usage in healing abilities (e.g., shaman_spirit_mender at line 2113)
case 'shaman_spirit_mender':
  if (!targetCharacter) throw new SenderError('Target required');
  applyHeal(targetCharacter, 6n, 'Spirit Mender'); // Base 6, scaled by caster's WIS
  addCharacterEffect(ctx, targetCharacter.id, 'regen', 3n, 2n, 'Spirit Mender');
  return;
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Stats as display only | Stats affect combat damage/healing | This phase | Builds become meaningful |
| Fixed 5% crit chance | DEX-scaled crit with weapon multipliers | This phase | Dexterity builds viable |
| Armor = only defense | Armor + magic resistance split | This phase | Gear choices more tactical |
| Ability damage = power only | Hybrid formula with stat scaling | This phase | Caster stat investment matters |
| Healing = fixed amounts | WIS-scaled healing | This phase | Healer itemization has purpose |

**Current state (before this phase):**
- Stats exist on Character table but don't affect combat
- All damage comes from weapon stats + ability power + level
- Critical strike fields exist but unused
- No differentiation between magic and physical damage mitigation

**After this phase:**
- Stats are primary/secondary factor in damage (gear still dominant)
- DEX creates crit-focused builds with weapon-specific optimization
- Magic damage requires different defensive strategy than physical
- Ability choice affected by stat allocation (INT vs STR vs WIS)
- Healing classes scale with WIS investment

---

## Open Questions

### Question 1: Exact Armor Scaling Curve Tuning

**What we know:**
- Current formula: `damage * 100 / (100 + armor * 5)` gives 71% reduction at 50 armor
- User wants: ~30% reduction at 50 armor, ~45% total at 100 armor

**What's unclear:**
- Exact scaling factor (1n? 1.5n? 2n?) to achieve user's curve
- Whether to change formula shape (currently `x/(x+k)`, could use quadratic)

**Recommendation:**
- Start with `armor * 1.5n` scaling factor
- Test at 25/50/75/100 armor values
- Adjust based on playtesting feedback
- Document final curve in VERIFICATION.md

---

### Question 2: Weapon Type Assignment for Existing Weapons

**What we know:**
- Weapons have names: "Training Sword", "Training Dagger", etc.
- Need to map to types: "sword", "dagger", etc. for crit multipliers

**What's unclear:**
- Are weapon types stored in database or inferred from name?
- Should new `weaponType` field be added to ItemTemplate table?

**Recommendation:**
- Add `weaponType: t.string()` field to ItemTemplate (index.ts:265)
- Migrate existing weapons with type inference from name
- Future weapons specify type explicitly
- Fallback to "sword" (2.0x multiplier) if type missing

---

### Question 3: Magic Resistance Availability on Gear

**What we know:**
- User wants magic resistance "rarer than armor but more powerful per point"
- No gear currently has magic resistance (field doesn't exist)

**What's unclear:**
- What percentage of gear should have magic resistance? (10%? 25%?)
- Should it replace other bonuses or be additional?
- Should specific slots (e.g., cloaks) favor magic resistance?

**Recommendation:**
- Add `magicResistanceBonus: t.u64()` to ItemTemplate
- ~15-20% of gear items should have magic resistance
- Cloth armor more likely to have it than plate (compensates for low armor)
- Cloaks and jewelry primary sources
- Deferred to content expansion phase (out of scope for 3.1)

---

### Question 4: Hybrid Stat Scaling for Multi-Stat Classes

**What we know:**
- Spellblade, Reaver have INT + STR as primary/secondary
- User allows "abilities can scale from multiple stats"

**What's unclear:**
- Should hybrid abilities average stats, sum them, or use max?
- Example: Spellblade with 15 STR, 20 INT
  - Average: `(15 + 20) / 2 = 17.5` → round to 17?
  - Sum: `15 + 20 = 35`
  - Max: `max(15, 20) = 20`

**Recommendation:**
- Sum both stats (most generous, rewards hybrid investment)
- Example code shows: `return (character.str + character.int);`
- Prevents hybrid classes from being penalized vs pure classes
- Matches user philosophy: "Hybrid classes: abilities can scale from multiple stats"

---

## Sources

### Primary (HIGH confidence)

**User Context Document:**
- C:/projects/uwr/.planning/phases/3.1-combat-balance/3.1-CONTEXT.md — All user decisions on stat scaling, role balance, ability formulas, defensive mechanics

**Codebase Analysis:**
- C:/projects/uwr/spacetimedb/src/index.ts — Character table (line 215), ItemTemplate (265), damage formulas (1900, 4118), combat reducer (1828)
- C:/projects/uwr/spacetimedb/src/data/class_stats.ts — Stat growth, class configurations, armor proficiencies
- C:/projects/uwr/spacetimedb/src/data/ability_catalog.ts — All ability definitions with power/cooldown/cast time
- C:/projects/uwr/spacetimedb/src/reducers/combat.ts — Combat tick logic, damage application, auto-attacks

### Secondary (MEDIUM confidence)

**RPG Game Design Patterns:**
- [Power Scaling in RPGs](https://marcleoseguin.com/2020/11/18/power-scaling-in-rpgs/) — Logarithmic vs linear scaling, stat breakpoints
- [Damage Formulas](https://yujiri.xyz/game-design/damage-formulas.gmi) — Attack-defense formulas, consistency vs diversity
- [Albion Online Armor Mechanics](https://forum.albiononline.com/index.php/Thread/173891-How-armor-and-defense-affect-damage-reduction/) — Diminishing returns formula `armor/(armor + K)`
- [Diminishing Returns for Balance - TV Tropes](https://tvtropes.org/pmwiki/pmwiki.php/Main/DiminishingReturnsForBalance) — Effective health linear with armor despite diminishing % reduction
- [Damage Reduction - TV Tropes](https://tvtropes.org/pmwiki/pmwiki.php/Main/DamageReduction) — Impossibility of reaching 100% reduction

**Critical Strike Mechanics:**
- [Path of Exile Critical Strike Mechanics](https://www.poewiki.net/wiki/Critical_strike) — Base crit + increased crit chance formula, multiplier application
- [Critical Hit Class - TV Tropes](https://tvtropes.org/pmwiki/pmwiki.php/Main/CriticalHitClass) — DEX-based crit classes in RPGs

**Healing and Stats:**
- [ESO Damage Scaling](https://hacktheminotaur.com/eso-guides/dynamic-stat-scaling/) — Stat scaling improves skill efficiency
- [Realm of the Mad God Wisdom Stat](https://www.realmeye.com/wiki/character-stats) — WIS increases healing intensity/range/duration, concrete formula: `0.12 * (WIS + 4.2)`
- [Attribute Systems in RPGs - Wikipedia](https://en.wikipedia.org/wiki/Attribute_(role-playing_games)) — Wisdom controls spell casting, communication to entities

**Role Balance:**
- [Damager, Healer, Tank - TV Tropes](https://tvtropes.org/pmwiki/pmwiki.php/Main/DamagerHealerTank) — Trinity design pillar
- [Should healers deal same damage as dps? - GameDev.net](https://www.gamedev.net/forums/topic/609093-should-healers-deal-same-damage-as-dps/) — Double-stuffing roles creates balance issues
- [Rethinking the Trinity of MMO Design](https://www.gamedeveloper.com/design/rethinking-the-trinity-of-mmo-design) — Hybrid class balance challenges

### Tertiary (LOW confidence)

None — all findings verified through multiple sources or user decisions.

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — No new dependencies, extends existing SpacetimeDB patterns
- Architecture patterns: HIGH — User decisions explicit, existing code provides implementation paths
- Pitfalls: HIGH — BigInt determinism requirement documented in SpacetimeDB rules, validated against codebase
- Weapon types: MEDIUM — Need to confirm if types should be new field vs name inference
- Magic resistance tuning: MEDIUM — Availability % and gear distribution not specified by user
- Armor curve tuning: MEDIUM — Exact scaling factor requires playtesting

**Research date:** 2026-02-12
**Valid until:** 60 days (stable game balance formulas, unlikely to change)

**Critical assumptions:**
1. User decisions in CONTEXT.md are final and locked
2. No major SpacetimeDB API changes in 1.11.x → 1.12.x
3. Existing combat reducer structure remains compatible with stat scaling extensions
4. BigInt arithmetic patterns sufficient for all scaling calculations (no need for fixed-point library)
