---
phase: 3.1-combat-balance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/data/class_stats.ts
  - spacetimedb/src/data/ability_catalog.ts
  - spacetimedb/src/data/combat_scaling.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Each ability has a damageType tag (physical or magic)"
    - "Each weapon template has a weaponType field for crit multiplier lookup"
    - "Combat helper functions exist for stat-scaled damage, crit, healing, and magic resist"
    - "ItemTemplate table has magicResistanceBonus field"
    - "Armor mitigation curve matches user decision (~30% at 50 armor)"
  artifacts:
    - path: "spacetimedb/src/data/combat_scaling.ts"
      provides: "All combat balance constants and helper functions"
      contains: "WEAPON_CRIT_MULTIPLIERS"
    - path: "spacetimedb/src/data/ability_catalog.ts"
      provides: "damageType field on every ability"
      contains: "damageType"
    - path: "spacetimedb/src/data/class_stats.ts"
      provides: "ABILITY_STAT_SCALING mapping"
      contains: "ABILITY_STAT_SCALING"
    - path: "spacetimedb/src/index.ts"
      provides: "magicResistanceBonus on ItemTemplate, weaponType on ItemTemplate, applyArmorMitigation tuned"
      contains: "magicResistanceBonus"
  key_links:
    - from: "spacetimedb/src/data/combat_scaling.ts"
      to: "spacetimedb/src/data/class_stats.ts"
      via: "imports CLASS_CONFIG for stat lookups"
      pattern: "import.*class_stats"
    - from: "spacetimedb/src/data/combat_scaling.ts"
      to: "spacetimedb/src/data/ability_catalog.ts"
      via: "references ABILITIES for scaling lookup"
      pattern: "import.*ability_catalog"
---

<objective>
Create all combat balance data constants, helper functions, and schema additions needed for stat scaling. This plan builds the foundation layer that Plan 02 will wire into the combat pipeline.

Purpose: Stats currently exist on Character table but do NOT affect combat. This plan creates the data and helper functions that make stats meaningful — STR scaling auto-attacks, DEX enabling crits, INT powering spells, WIS boosting heals.

Output: New combat_scaling.ts data file with all scaling helpers, extended ability_catalog.ts with damageType tags, extended class_stats.ts with ability-stat mappings, extended ItemTemplate with weaponType/magicResistanceBonus fields, tuned armor mitigation curve.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3.1-combat-balance/3.1-CONTEXT.md
@.planning/phases/3.1-combat-balance/3.1-RESEARCH.md
@spacetimedb/src/data/class_stats.ts
@spacetimedb/src/data/ability_catalog.ts
@spacetimedb/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create combat_scaling.ts data file and extend class_stats.ts + ability_catalog.ts</name>
  <files>
    spacetimedb/src/data/combat_scaling.ts
    spacetimedb/src/data/class_stats.ts
    spacetimedb/src/data/ability_catalog.ts
  </files>
  <action>
Create a new file `spacetimedb/src/data/combat_scaling.ts` containing ALL combat balance constants and helper functions. Import from class_stats.ts and ability_catalog.ts as needed.

**Constants to define:**

1. `WEAPON_CRIT_MULTIPLIERS: Record<string, bigint>` — weapon type to crit multiplier (per 100n base):
   - dagger: 150n, rapier: 150n, staff: 150n (fast = 1.5x)
   - sword: 200n, blade: 200n, mace: 200n, bow: 200n (medium = 2.0x)
   - axe: 250n (slow = 2.5x)
   - Default fallback: 200n

2. `WEAPON_TYPE_MAP: Record<string, string>` — weapon template name substring to weapon type. Infer from the item name by checking if name includes "Sword", "Dagger", "Staff", "Axe", "Bow", "Mace", "Rapier", "Blade". Case-insensitive. Provide a function `inferWeaponType(weaponName: string): string` that returns the weapon type from a weapon name. Falls back to 'sword'.

3. `STR_SCALING_PER_1000 = 15n` — 1.5% per STR point for auto-attacks (user decision: 1-2% range)

4. `ABILITY_STAT_SCALING_PER_POINT = 2n` — flat stat contribution per point for abilities (ability hybrid formula)

5. `CRIT_BASE_CHANCE = 50n` — 5% base crit chance (per 1000 scale)

6. `CRIT_DEX_BONUS_PER_POINT = 1n` — 0.1% per DEX (per 1000 scale, so 1n per point)

7. `CRIT_CHANCE_CAP = 500n` — 50% max crit chance (per 1000 scale)

8. `HEALING_WIS_SCALING_PER_1000 = 20n` — 2% per WIS point for healing (matches STR/INT magnitude)

9. `MAGIC_RESIST_SCALING = 3n` — magic resist uses 3x multiplier in mitigation formula (vs armor's adjusted multiplier)

**Helper functions to define:**

1. `calculateStatScaledAutoAttack(baseWeaponDamage: bigint, characterStr: bigint): bigint`
   - Formula: `baseWeaponDamage + (baseWeaponDamage * characterStr * STR_SCALING_PER_1000) / 1000n`
   - Per user decision: multiplicative scaling keeps gear dominant

2. `calculateCritChance(characterDex: bigint): bigint`
   - Formula: `min(CRIT_BASE_CHANCE + characterDex * CRIT_DEX_BONUS_PER_POINT, CRIT_CHANCE_CAP)`
   - Returns value on 0-1000 scale

3. `getCritMultiplier(weaponName: string): bigint`
   - Uses inferWeaponType + WEAPON_CRIT_MULTIPLIERS lookup
   - Returns multiplier (150n = 1.5x, 200n = 2.0x, 250n = 2.5x)

4. `getAbilityStatScaling(characterStats: { str: bigint; dex: bigint; cha: bigint; wis: bigint; int: bigint }, abilityKey: string, className: string): bigint`
   - Uses ABILITY_STAT_SCALING mapping (defined below in class_stats.ts extension)
   - Melee abilities: `character.str * ABILITY_STAT_SCALING_PER_POINT`
   - Arcane abilities: `character.int * ABILITY_STAT_SCALING_PER_POINT`
   - Divine/nature abilities: `character.wis * ABILITY_STAT_SCALING_PER_POINT`
   - Hybrid abilities: `(character.str + character.int) * 1n` (sum both stats, 1n per point — slightly lower per-stat than pure classes to match role-based DPS tiers)
   - Bard/CHA abilities: `character.cha * ABILITY_STAT_SCALING_PER_POINT`
   - Returns 0n for utility abilities (no damage)

5. `getAbilityMultiplier(castSeconds: bigint, cooldownSeconds: bigint): bigint`
   - Formula: `100n + castSeconds * 10n + (cooldownSeconds > 0n ? (cooldownSeconds * 5n) / 10n : 0n)`
   - Returns multiplier on 100n = 1.0x scale
   - Per user decision: longer cast = higher multiplier, longer CD = higher burst

6. `calculateHealingPower(baseHealing: bigint, casterWis: bigint, className: string): bigint`
   - Imports getClassConfig from class_stats.ts
   - Only applies WIS scaling if class config has primary='wis' or secondary='wis'
   - Formula: `baseHealing + (baseHealing * casterWis * HEALING_WIS_SCALING_PER_1000) / 1000n`
   - Per user decision: WIS increases healing power for healing classes only

7. `applyMagicResistMitigation(damage: bigint, magicResist: bigint): bigint`
   - Formula: `(damage * 100n) / (100n + magicResist * MAGIC_RESIST_SCALING)`
   - Returns max(mitigated, 1n)
   - Per user decision: rarer but more powerful per point than armor

**Extend class_stats.ts:**

Add `ABILITY_STAT_SCALING: Record<string, 'str' | 'dex' | 'int' | 'wis' | 'cha' | 'hybrid' | 'none'>` mapping every ability key to its scaling stat. Use the following classification:

- STR abilities (melee weapon): warrior_slam, warrior_cleave, warrior_crushing_blow, rogue_shadow_cut, rogue_bleed, rogue_shadow_strike, monk_crippling_kick, monk_palm_strike, monk_tiger_flurry, beastmaster_pack_rush, beastmaster_beast_fang, beastmaster_alpha_assault
- INT abilities (arcane spells): wizard_magic_missile, wizard_frost_shard, wizard_lightning_surge, necromancer_plague_spark, necromancer_wither, necromancer_grave_surge, summoner_conjure_vessel, summoner_conjured_spike, summoner_spectral_lance, enchanter_mind_fray, enchanter_slow, enchanter_charm_fray
- WIS abilities (divine/nature): cleric_smite, cleric_mend, cleric_heal, druid_thorn_lash, druid_bramble, druid_wild_surge, shaman_hex, shaman_stormcall, shaman_spirit_mender, ranger_marked_shot, ranger_rapid_shot, ranger_piercing_arrow
- Hybrid abilities (STR+INT): paladin_holy_strike, paladin_radiant_smite, spellblade_arcane_slash, spellblade_runic_strike, spellblade_spellstorm, reaver_blood_rend, reaver_soul_rend, reaver_oblivion
- CHA abilities: bard_discordant_note, bard_echoed_chord, bard_crushing_crescendo
- None (utility/non-damage): warrior_intimidating_presence, warrior_rally, enchanter_veil_of_calm, enchanter_clarity_ii, cleric_sanctify, cleric_sanctuary, wizard_arcane_reservoir, wizard_mana_shield, rogue_pickpocket, rogue_evasion, paladin_lay_on_hands, paladin_shield_of_faith, paladin_devotion, ranger_track, ranger_natures_balm, necromancer_bone_servant, necromancer_bone_ward, spellblade_rune_ward, spellblade_ward, reaver_blood_pact, reaver_dread_aura, summoner_earth_familiar, summoner_empower, bard_ballad_of_resolve, bard_harmony, beastmaster_call_beast, beastmaster_wild_howl, monk_centering, monk_inner_focus, druid_natures_mark, druid_natures_gift, shaman_spirit_wolf, shaman_ancestral_ward

**Extend ability_catalog.ts:**

Add `damageType: 'physical' | 'magic' | 'none'` field to every ability in ABILITIES. Classification:
- physical: All STR-scaling abilities (warrior, rogue, monk, beastmaster melee)
- magic: All INT, WIS, CHA scaling damage abilities (wizard, necromancer, enchanter, cleric, druid, shaman, summoner, bard damage abilities)
- physical for hybrid (paladin, spellblade, reaver) — they use weapons + magic, but physical is primary damage type
- none: utility/buff abilities that don't deal damage

Also export the type: `export type DamageType = 'physical' | 'magic' | 'none';`

Export all new functions and constants from combat_scaling.ts. All arithmetic MUST use BigInt (no floating point). All division uses integer division.
  </action>
  <verify>
Run TypeScript compiler to check for type errors:
```
cd C:/projects/uwr/spacetimedb && npx tsc --noEmit
```
Confirm combat_scaling.ts exports all 7 helper functions and 9 constants.
Confirm ABILITY_STAT_SCALING has entries for all ability keys in ABILITIES.
Confirm every ability in ABILITIES has a damageType field.
  </verify>
  <done>
combat_scaling.ts exists with all constants and helper functions. class_stats.ts has ABILITY_STAT_SCALING mapping for all abilities. ability_catalog.ts has damageType on every ability. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend schema tables (ItemTemplate, Character) and tune armor mitigation</name>
  <files>
    spacetimedb/src/index.ts
  </files>
  <action>
Make three targeted changes to index.ts:

**1. Add weaponType field to ItemTemplate table (line ~265):**
Add `weaponType: t.string()` after `weaponDps`. This allows explicit weapon type assignment. For existing weapons that don't have it set, the combat code will use `inferWeaponType` from combat_scaling.ts as fallback.

**2. Add magicResistanceBonus field to ItemTemplate table (line ~265):**
Add `magicResistanceBonus: t.u64()` after `armorClassBonus`. Most items will have 0 — magic resistance is intentionally rare (per user decision).

**3. Tune applyArmorMitigation curve (line ~4118):**
Change the scaling factor from `5n` to a value that matches user's desired curve: "First 50 armor = ~30% reduction, next 50 armor = ~15% more" (so 100 armor = ~45% reduction).

The formula `damage * 100 / (100 + armor * K)` gives:
- K=5: 50 armor = 71% reduction (WAY too strong)
- K=2: 50 armor = 50% reduction (still too strong)
- K=1: 50 armor = 33% reduction (close to ~30%)

Use `K = 1n` (i.e., `scaledArmor = armorClass * 1n` which simplifies to just `armorClass`):
```typescript
function applyArmorMitigation(damage: bigint, armorClass: bigint) {
  const mitigated = (damage * 100n) / (100n + armorClass);
  return mitigated > 0n ? mitigated : 1n;
}
```

Verification at target values:
- 50 armor: `100 / (100 + 50) = 66.7%` passes through = 33.3% reduction (close to user's ~30%)
- 100 armor: `100 / (100 + 100) = 50%` passes through = 50% reduction (close to user's ~45%)

This is the closest integer math can get. Document the curve in a comment above the function.

**4. Update getEquippedWeaponStats (line ~1605) to also return the weapon template name** (needed by Plan 02 for crit multiplier lookup):
Change return type to include `name: string`:
```typescript
function getEquippedWeaponStats(ctx: any, characterId: bigint) {
  for (const instance of ctx.db.itemInstance.by_owner.filter(characterId)) {
    if (instance.equippedSlot !== 'mainHand') continue;
    const template = ctx.db.itemTemplate.id.find(instance.templateId);
    if (!template) continue;
    return {
      baseDamage: template.weaponBaseDamage,
      dps: template.weaponDps,
      name: template.name,
      weaponType: template.weaponType,
    };
  }
  return { baseDamage: 0n, dps: 0n, name: '', weaponType: '' };
}
```

**5. Update weapon seed data** to include weaponType values on all existing weapon ItemTemplates. Find the ensureStarterItemTemplates function and add weaponType based on weapon name. For each weapon, set weaponType to the appropriate value: 'sword', 'dagger', 'staff', 'axe', 'bow', 'mace', 'rapier', 'blade'. Set magicResistanceBonus to 0n for all existing items. Also set weaponType to '' (empty string) for non-weapon items.

**IMPORTANT:** All new table fields must be added with default-compatible values. Since SpacetimeDB requires all fields on insert, search the codebase for ALL places that call `ctx.db.itemTemplate.insert(...)` and add `weaponType: ''` and `magicResistanceBonus: 0n` to each insert call. Common locations: ensureStarterItemTemplates, ensureResourceItemTemplates, ensureFoodItemTemplates, ensureLootTables, any item seeding functions. Missing an insert call will cause a runtime error.

Export the updated getEquippedWeaponStats return type through the deps object (line ~6229).
  </action>
  <verify>
Run TypeScript compiler:
```
cd C:/projects/uwr/spacetimedb && npx tsc --noEmit
```
Verify no type errors. Grep for all `itemTemplate.insert` calls to confirm each has weaponType and magicResistanceBonus fields. Verify applyArmorMitigation uses the new scaling factor.
  </verify>
  <done>
ItemTemplate has weaponType and magicResistanceBonus fields. All insert calls include the new fields. applyArmorMitigation uses K=1 curve (~33% at 50 armor, ~50% at 100 armor). getEquippedWeaponStats returns weapon name and weaponType. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles with `npx tsc --noEmit` in spacetimedb directory
- combat_scaling.ts contains all 7 helper functions with BigInt-only arithmetic
- ABILITY_STAT_SCALING covers every key in ABILITIES (no gaps)
- Every ABILITIES entry has damageType field
- ItemTemplate schema has weaponType and magicResistanceBonus
- applyArmorMitigation curve documented and using K=1
- getEquippedWeaponStats returns name + weaponType
</verification>

<success_criteria>
All combat balance data infrastructure exists and compiles. No functional changes to combat yet — that is Plan 02. The foundation is complete: helper functions, constants, schema extensions, armor curve tuning.
</success_criteria>

<output>
After completion, create `.planning/phases/3.1-combat-balance/3.1-01-SUMMARY.md`
</output>
