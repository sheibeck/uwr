---
phase: 13-crafting-system
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/components/CraftingPanel.vue
  - src/composables/useCrafting.ts
  - src/components/InventoryPanel.vue
autonomous: true

must_haves:
  truths:
    - "CraftingPanel shows type filter chips (All / Weapon / Armor / Accessory / Consumable) that filter the recipe list"
    - "CraftingPanel has a toggle to show only craftable recipes (default: show all)"
    - "Missing material requirements are shown in red, available materials in green"
    - "Craft button is disabled when material requirements are not met"
    - "Research Recipes button is removed from the CraftingPanel UI"
    - "Salvage confirmation dialog says 'crafting materials' instead of 'gold'"
    - "All known recipes are visible regardless of material ownership"
    - "Recipe scrolls in inventory have a 'Learn Recipe' action that calls learnRecipeScroll reducer"
  artifacts:
    - path: "src/components/CraftingPanel.vue"
      provides: "Extended crafting UI with filter chips, toggle, and material display"
      contains: "recipeType"
    - path: "src/composables/useCrafting.ts"
      provides: "Extended composable with recipeType filtering and craftable toggle"
      contains: "activeFilter"
    - path: "src/components/InventoryPanel.vue"
      provides: "Updated salvage confirm text and Learn Recipe action for scrolls"
      contains: "crafting materials"
  key_links:
    - from: "src/composables/useCrafting.ts"
      to: "src/components/CraftingPanel.vue"
      via: "composable provides filtered recipes, activeFilter, showOnlyCraftable to component"
      pattern: "activeFilter|showOnlyCraftable"
    - from: "src/components/CraftingPanel.vue"
      to: "src/composables/useCrafting.ts"
      via: "component uses composable for recipe data and filter state"
      pattern: "useCrafting"
    - from: "src/components/InventoryPanel.vue"
      to: "conn.reducers.learnRecipeScroll"
      via: "Learn Recipe button calls learnRecipeScroll reducer for scroll items"
      pattern: "learnRecipeScroll"
---

<objective>
Extend the CraftingPanel UI with type filter chips, show-only-craftable toggle, red/green material requirement display, and remove the Research Recipes button. Update the salvage confirmation dialog text in InventoryPanel.

Purpose: Frontend user experience for the crafting system — players can browse recipes by type, see material requirements with availability indicators, and craft gear.
Output: Updated CraftingPanel.vue, useCrafting.ts composable, and InventoryPanel.vue.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-RESEARCH.md
@.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-01-SUMMARY.md

@src/components/CraftingPanel.vue
@src/composables/useCrafting.ts
@src/components/InventoryPanel.vue
@src/ui/styles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useCrafting composable with recipeType filtering and craftable toggle</name>
  <files>
    src/composables/useCrafting.ts
  </files>
  <action>
Read the existing `useCrafting.ts` composable to understand its current structure. Extend it with:

1. **Add new reactive state:**
   ```typescript
   const activeFilter = ref<string>('All');
   const showOnlyCraftable = ref(false);
   ```

2. **Add recipeType to recipe mapping.** The existing `recipes` computed likely maps `recipeTemplates` rows. After Plan 01, RecipeTemplate rows now have a `recipeType` field. Extend each recipe object in the computed with:
   - `recipeType`: from the RecipeTemplate row's `recipeType` field (default to 'consumable' if undefined for backward compat)
   - `materialType`: from the RecipeTemplate row's `materialType` field (may be undefined)

3. **Add material availability check per requirement.** For each recipe's requirements (req1, req2, req3), compute whether the player has enough of that material. The existing composable likely already does this for the `canCraft` flag. Extend each requirement with a `hasMaterial: boolean` field:
   ```typescript
   requirements: [
     { templateId: recipe.req1TemplateId, name: req1Template?.name, count: recipe.req1Count, owned: ownedCount, hasMaterial: ownedCount >= recipe.req1Count },
     // ... req2, req3 if present
   ]
   ```

4. **Compute available filter types.** Derive the set of unique recipeTypes from known recipes:
   ```typescript
   const recipeTypes = computed(() => {
     const types = new Set(recipes.value.map(r => r.recipeType));
     return ['All', ...Array.from(types).sort()];
   });
   ```

5. **Apply filters to the recipe list.** Create a `filteredRecipes` computed that chains:
   - Filter by `activeFilter` (if not 'All', match recipeType)
   - Filter by `showOnlyCraftable` (if true, only show recipes where canCraft is true)
   ```typescript
   const filteredRecipes = computed(() => {
     return recipes.value
       .filter(r => activeFilter.value === 'All' || r.recipeType === activeFilter.value)
       .filter(r => !showOnlyCraftable.value || r.canCraft);
   });
   ```

6. **Return new properties** from the composable: `activeFilter`, `showOnlyCraftable`, `filteredRecipes`, `recipeTypes`.

7. **Keep existing functionality intact.** Do not remove or change the `craftRecipe` action, the `selectedRecipe` ref, or any existing reactive state. The existing `canCraft` logic should continue working.

**NOTE on `recipeType` field access:** After bindings are regenerated (Plan 01 adds columns to RecipeTemplate), the generated type will include `recipeType` and `materialType`. Until bindings are regenerated, these fields may need `(recipe as any).recipeType` casting. Use the casting approach if the field isn't in the generated type yet — Plan 01's publish+generate step will fix this.
  </action>
  <verify>
    - grep for `activeFilter` in useCrafting.ts
    - grep for `showOnlyCraftable` in useCrafting.ts
    - grep for `filteredRecipes` in useCrafting.ts
    - grep for `recipeTypes` in useCrafting.ts
    - grep for `hasMaterial` in useCrafting.ts
    - Verify existing crafting functionality preserved: grep for `craftRecipe` still exists
  </verify>
  <done>
    - useCrafting.ts exports activeFilter, showOnlyCraftable, filteredRecipes, recipeTypes
    - Each recipe object includes recipeType, materialType, and requirements with hasMaterial flags
    - filteredRecipes applies both type filter and craftable toggle
    - Existing craftRecipe functionality unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CraftingPanel UI with filter chips, toggle, and material display; update InventoryPanel salvage text</name>
  <files>
    src/components/CraftingPanel.vue
    src/components/InventoryPanel.vue
  </files>
  <action>
**Part A: Update CraftingPanel.vue**

Read the existing CraftingPanel.vue to understand its layout and styling. Make these changes:

1. **Remove the "Research Recipes" button.** Find the button/section that calls `researchRecipes` or `onResearchRecipes` and remove it entirely. The research_recipes mechanic is replaced by salvage-to-recipe discovery.

2. **Add type filter chips** at the top of the recipe list area. Use a horizontal row of small buttons/chips:
   ```vue
   <div style="display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap;">
     <button
       v-for="type in recipeTypes"
       :key="type"
       @click="activeFilter = type"
       :style="{
         padding: '2px 8px',
         fontSize: '11px',
         border: '1px solid #555',
         borderRadius: '3px',
         background: activeFilter === type ? '#4a6' : '#333',
         color: activeFilter === type ? '#fff' : '#aaa',
         cursor: 'pointer',
       }"
     >
       {{ type }}
     </button>
   </div>
   ```
   Use `recipeTypes` and `activeFilter` from the composable.

3. **Add show-only-craftable toggle** below the filter chips:
   ```vue
   <label style="display: flex; align-items: center; gap: 4px; fontSize: '11px'; color: '#aaa'; margin-bottom: 6px;">
     <input type="checkbox" v-model="showOnlyCraftable" />
     Show only craftable
   </label>
   ```

4. **Update recipe list to use `filteredRecipes`** instead of the previous unfiltered list. Replace the `v-for` source with `filteredRecipes`.

5. **Show material requirements with red/green coloring.** In each recipe's detail/expanded area, display the material requirements:
   ```vue
   <div v-for="req in recipe.requirements" :key="req.templateId?.toString()">
     <span :style="{ color: req.hasMaterial ? '#4a6' : '#c44' }">
       {{ req.name }}: {{ req.owned }}/{{ req.count }}
     </span>
   </div>
   ```
   - Green (#4a6) when the player has enough
   - Red (#c44) when the player is short

6. **Ensure Craft button disabled state.** The existing Craft button likely has a disabled condition. Ensure it checks `!recipe.canCraft`. If the recipe requires materials the player doesn't have, the button should be disabled and visually dimmed (opacity: 0.5 or similar).

7. **Style consistency.** Use the existing panel styling patterns from the codebase (dark backgrounds #1a1a2e/#2a2a3e, light text #ccc/#aaa, green accents #4a6). Match the existing CraftingPanel's aesthetic.

**Part B: Update InventoryPanel.vue salvage confirmation text**

Find the salvage confirmation dialog/text in InventoryPanel.vue (per research, around line 236). Change the text from referencing gold to referencing crafting materials:

Old: `"Salvage ${item.name}? You will receive gold. This cannot be undone."`
New: `"Salvage ${item.name}? You will receive crafting materials. This cannot be undone."`

If the exact text differs from the research, find the salvage confirm string and update it to mention "crafting materials" instead of "gold".
  </action>
  <verify>
    - Open CraftingPanel.vue and verify: filter chips visible in template, Research Recipes button removed
    - grep for `recipeTypes` in CraftingPanel.vue to confirm chip rendering
    - grep for `showOnlyCraftable` in CraftingPanel.vue to confirm toggle
    - grep for `hasMaterial` in CraftingPanel.vue to confirm red/green coloring
    - grep for `filteredRecipes` in CraftingPanel.vue to confirm filtered list usage
    - grep for 'crafting materials' in InventoryPanel.vue to confirm updated salvage text
    - grep for 'Research' in CraftingPanel.vue — should return nothing (button removed)
  </verify>
  <done>
    - CraftingPanel shows filter chips (All / Weapon / Armor / Accessory / Consumable) at top
    - Active filter chip highlighted in green
    - Show-only-craftable checkbox toggle present
    - Recipe list filtered by active type and craftable toggle
    - Material requirements shown per recipe with green (has enough) / red (insufficient) coloring
    - Craft button disabled when materials insufficient
    - Research Recipes button removed
    - InventoryPanel salvage confirm says "crafting materials" not "gold"
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire scroll-use UI in InventoryPanel for recipe scroll learning</name>
  <files>
    src/components/InventoryPanel.vue
  </files>
  <action>
Add a "Learn Recipe" action for recipe scroll items in InventoryPanel.vue. This connects the `learn_recipe_scroll` reducer (created in Plan 02) to the client UI, making scroll-based recipe discovery reachable by the player.

1. **Detect scroll items.** In the inventory item action/context area (where Equip, Salvage, Use actions are shown), add a condition to detect recipe scrolls. A scroll item has a template name starting with `'Scroll:'`. Check the item's template name:
   ```typescript
   const isRecipeScroll = (item) => item.templateName?.startsWith('Scroll:') || item.name?.startsWith('Scroll:');
   ```
   Adapt to the actual naming pattern used in the component (check how template name is accessed for inventory items — it may be via a lookup or a joined field).

2. **Add "Learn Recipe" button.** When `isRecipeScroll` is true, show a "Learn Recipe" button alongside existing item actions (or instead of the default Use action for scrolls):
   ```vue
   <button
     v-if="isRecipeScroll(item)"
     @click="learnRecipeFromScroll(item)"
     :style="{ /* match existing action button styling */ }"
   >
     Learn Recipe
   </button>
   ```

3. **Implement `learnRecipeFromScroll` handler.** Call the `learnRecipeScroll` reducer:
   ```typescript
   const learnRecipeFromScroll = (item) => {
     const conn = window.__db_conn;
     if (!conn) return;
     const characterId = /* get active character ID from existing pattern in this component */;
     conn.reducers.learnRecipeScroll({ characterId, itemInstanceId: item.id });
   };
   ```
   Look at how existing item actions (Equip, Salvage, Use) get the characterId and conn reference in this component and follow the same pattern.

4. **No confirmation dialog needed.** Learning a recipe is a positive, non-destructive action (the scroll is consumed but the recipe is permanent). Unlike salvage, no confirmation prompt is necessary.

5. **Style consistency.** Match the button styling to existing action buttons in InventoryPanel. Use the same color scheme, font size, and padding as neighboring action buttons.
  </action>
  <verify>
    - grep for `learnRecipeScroll` in InventoryPanel.vue to confirm reducer call is wired
    - grep for `Scroll:` or `isRecipeScroll` in InventoryPanel.vue to confirm scroll detection
    - grep for `Learn Recipe` in InventoryPanel.vue to confirm button text exists
  </verify>
  <done>
    - InventoryPanel shows a "Learn Recipe" button for items whose template name starts with 'Scroll:'
    - Clicking "Learn Recipe" calls conn.reducers.learnRecipeScroll({ characterId, itemInstanceId })
    - Button styling matches existing inventory action buttons
    - Scroll-based recipe discovery path is fully reachable by the player (Plan 01 seeds scrolls, Plan 02 creates reducer, Plan 03 wires UI)
  </done>
</task>

</tasks>

<verification>
- CraftingPanel.vue has type filter chips, craftable toggle, and red/green material display
- Research Recipes button removed from CraftingPanel
- InventoryPanel salvage text updated
- InventoryPanel has "Learn Recipe" action for scroll items calling learnRecipeScroll reducer
- useCrafting.ts exports new filter state and filtered recipe list
- No backend changes (those are Plan 01 and 02)
- Styling consistent with existing dark theme
</verification>

<success_criteria>
The crafting UI is complete: players can filter recipes by type, toggle to show only craftable recipes, see material requirements with availability coloring, and craft items. The salvage confirmation text reflects the new material yield. Recipe scrolls found in inventory can be used via a "Learn Recipe" action. Combined with Plans 01 and 02, the full crafting system is functional end-to-end.
</success_criteria>

<output>
After completion, create `.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-03-SUMMARY.md`
</output>
