---
phase: 13-crafting-system
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - spacetimedb/src/reducers/items.ts
  - spacetimedb/src/helpers/items.ts
autonomous: true

must_haves:
  truths:
    - "Salvaging gear yields crafting materials instead of gold, with material type based on gear slot/armor type"
    - "Salvaging gear has a 75% chance to teach the recipe for that item type if not already known"
    - "Recipe discovery on salvage creates a Log entry: 'You have learned: [Recipe Name]'"
    - "Crafting a gear recipe with materials produces an item with deterministic affixes based on material type"
    - "Material tier determines output quality tier: Tier 1=common, Tier 2=uncommon, Tier 3=rare"
    - "Crafted gear has qualityTier, displayName, and ItemAffix rows written — identical pattern to take_loot"
    - "Consumable recipes still work unchanged (no affixes, no quality)"
    - "Recipe scrolls can be used to learn recipes via a learn_recipe_scroll reducer"
  artifacts:
    - path: "spacetimedb/src/reducers/items.ts"
      provides: "Reworked salvage_item, extended craft_recipe, new learn_recipe_scroll reducer"
      contains: "learn_recipe_scroll"
    - path: "spacetimedb/src/helpers/items.ts"
      provides: "Helper functions for deterministic crafting affix application"
  key_links:
    - from: "spacetimedb/src/reducers/items.ts"
      to: "spacetimedb/src/data/crafting_materials.ts"
      via: "import getCraftedAffixes, getMaterialForSalvage, materialTierToQuality, SALVAGE_YIELD_BY_TIER"
      pattern: "getCraftedAffixes|getMaterialForSalvage"
    - from: "spacetimedb/src/reducers/items.ts"
      to: "spacetimedb/src/helpers/items.ts"
      via: "import addItemToInventory, buildDisplayName, findItemTemplateByName"
      pattern: "addItemToInventory|buildDisplayName"
---

<objective>
Rework the salvage and crafting reducers to implement the material-based crafting system: salvage_item yields materials and triggers recipe discovery, craft_recipe applies deterministic affixes for gear, and a new learn_recipe_scroll reducer enables scroll-based recipe learning.

Purpose: The backend logic that makes crafting functional — materials from salvage, deterministic gear output from crafting, and recipe discovery through salvage and scrolls.
Output: Modified salvage_item, extended craft_recipe, new learn_recipe_scroll reducer.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-RESEARCH.md
@.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-01-SUMMARY.md
@.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-02-SUMMARY.md
@.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-03-SUMMARY.md

@spacetimedb/src/reducers/items.ts
@spacetimedb/src/helpers/items.ts
@spacetimedb/src/data/crafting_materials.ts
@spacetimedb/src/data/affix_catalog.ts
@spacetimedb/src/schema/tables.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rework salvage_item reducer for material yield and recipe discovery</name>
  <files>
    spacetimedb/src/reducers/items.ts
  </files>
  <action>
Modify the existing `salvage_item` reducer in `spacetimedb/src/reducers/items.ts`. The current reducer deletes the item and grants gold scaled by tier+quality. Replace the gold yield with material yield and add recipe discovery.

**Import new dependencies at top of file:**
```typescript
import { getMaterialForSalvage, SALVAGE_YIELD_BY_TIER, MATERIAL_DEFS } from '../data/crafting_materials';
```

**Rework salvage_item reducer body (keep existing validation — ownership, equipped check, slot type guard):**

1. **Remove gold yield entirely.** Delete the gold calculation and `ctx.db.character.id.update` gold grant lines.

2. **Add material yield.** After existing validation:
   - Get the item's template to determine slot, armorType, tier
   - Call `getMaterialForSalvage(template.slot, template.armorType, template.tier)` to get material name
   - If material name is returned (it is equipment), look up the material ItemTemplate using `findItemTemplateByName(ctx, materialName)`
   - If material template found, determine yield count from `SALVAGE_YIELD_BY_TIER[Number(template.tier)]` (default 2n)
   - Call `addItemToInventory(ctx, character.id, materialTemplate.id, yieldCount)` to grant materials
   - Log via `appendPrivateEvent`: `"You salvaged ${item.displayName || template.name} and received ${yieldCount}x ${materialTemplate.name}."`

3. **Add recipe discovery roll (75% chance).** After material yield:
   - Determine if there's a gear recipe for this item type. Strategy: iterate `ctx.db.recipeTemplate.iter()` and find a recipe whose `outputTemplateId === instance.templateId`. This finds the recipe that produces this item type.
   - If a matching recipe exists:
     - Check if already known: `[...ctx.db.recipeDiscovered.by_character.filter(character.id)].some(r => r.recipeTemplateId === recipe.id)`
     - If NOT already known, roll for discovery: use `(ctx.timestamp.microsSinceUnixEpoch + character.id) % 100n` as a deterministic roll. If roll < 75n (75% chance), insert a `RecipeDiscovered` row and log: `"You have learned: ${recipe.name}"`
     - Use `appendPrivateEvent(ctx, character.id, character.ownerUserId, 'system', message)` for the log entry

4. **Keep existing item deletion logic.** The existing code that deletes ItemAffix rows via `by_instance.filter` and then deletes the ItemInstance should remain unchanged.

**IMPORTANT: Do NOT change the salvage validation guards** (ownership, equipped check, slot type blocklist). Keep the existing blocklist that prevents salvaging junk/consumable/food/resource/quest items.
  </action>
  <verify>
    - grep for `getMaterialForSalvage` in reducers/items.ts to confirm import and usage
    - grep for `SALVAGE_YIELD_BY_TIER` in reducers/items.ts to confirm material yield logic
    - grep for `recipeDiscovered` in the salvage_item section to confirm recipe discovery
    - Confirm no gold yield remains: grep for `goldYield` or gold-related lines in salvage_item — should be gone
    - TypeScript compiles without new errors: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | grep -i "crafting_materials\|salvage" | head -10`
  </verify>
  <done>
    - salvage_item no longer grants gold
    - salvage_item grants 2-3 material items based on gear slot/armor type/tier
    - salvage_item has 75% chance to teach the recipe for salvaged item type
    - Recipe discovery creates RecipeDiscovered row and logs "You have learned: [name]"
    - Duplicate recipe discovery is prevented (checks existing discoveries)
    - Existing item deletion (ItemAffix + ItemInstance cleanup) still works
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend craft_recipe for deterministic gear affixes and add learn_recipe_scroll reducer</name>
  <files>
    spacetimedb/src/reducers/items.ts
    spacetimedb/src/helpers/items.ts
  </files>
  <action>
**Part A: Extend `craft_recipe` reducer in `reducers/items.ts`**

The existing `craft_recipe` reducer: validates location (craftingAvailable), checks recipe discovered, consumes materials via `removeItemFromInventory`, and calls `addItemToInventory` for the output. It does NOT set qualityTier or create affixes.

**Add deterministic affix application after the existing `addItemToInventory` call:**

1. Import: `import { getCraftedAffixes, materialTierToQuality } from '../data/crafting_materials';`

2. After `addItemToInventory(ctx, character.id, recipe.outputTemplateId, recipe.outputCount)`:
   - Check if the recipe is a gear recipe: `if (recipe.recipeType && recipe.recipeType !== 'consumable')` — only gear recipes get affixes
   - Determine the material type used. The `materialType` on the recipe (from Plan 01 seeding) indicates which material determines affixes. BUT per user decision, the material TYPE is chosen by the player (not locked per recipe). Implementation approach:
     - Look at the req1 template to determine what material was consumed. Get req1 template: `ctx.db.itemTemplate.id.find(recipe.req1TemplateId)`
     - Find the material key from the template name (lowercase, replace spaces with underscores)
     - Look up the material def in MATERIAL_DEFS to get the tier
     - Alternatively, if `recipe.materialType` is set, use that directly for the affix lookup
   - Compute quality tier: `materialTierToQuality(materialTier)` (Tier 1='common', Tier 2='uncommon', Tier 3='rare')
   - Get affixes: `getCraftedAffixes(materialKey, qualityTier)`
   - If quality is not 'common' (has affixes):
     - Find the newly created ItemInstance: same pattern as `take_loot` — filter `ctx.db.itemInstance.by_owner.filter(character.id)`, find one with matching `templateId === recipe.outputTemplateId` and no `qualityTier` set yet
     - Write ItemAffix rows for each affix using `ctx.db.itemAffix.insert({ id: 0n, itemInstanceId, affixType, affixKey, affixName, statKey, magnitude })`
     - Build display name using `buildDisplayName(outputTemplate.name, affixes)` from helpers/items.ts
     - Update the ItemInstance with qualityTier and displayName: `ctx.db.itemInstance.id.update({ ...newInstance, qualityTier, displayName })`
   - If quality IS 'common' (Tier 1 materials), the item stays as-is (no affixes, no quality update needed — common items are plain)

3. Log the craft with appropriate quality: `appendPrivateEvent(ctx, character.id, character.ownerUserId, 'system', "You crafted: ${displayName || outputTemplate.name}")`

**Part B: Add `learn_recipe_scroll` reducer in `reducers/items.ts`**

Define a new reducer for learning recipes from scroll items:

```typescript
spacetimedb.reducer('learn_recipe_scroll', {
  characterId: t.u64(),
  itemInstanceId: t.u64(),
}, (ctx, { characterId, itemInstanceId }) => {
  // Standard validation: ownership, character alive, etc.
  const character = requireCharacterOwnedBy(ctx, characterId);

  // Find the scroll item
  const instance = ctx.db.itemInstance.id.find(itemInstanceId);
  if (!instance) throw new SenderError('Item not found');
  if (instance.ownerId !== characterId) throw new SenderError('Not your item');

  const template = ctx.db.itemTemplate.id.find(instance.templateId);
  if (!template) throw new SenderError('Template not found');

  // Verify it's a recipe scroll (name starts with "Scroll:" or slot is 'recipe_scroll' or 'resource' with a naming convention)
  if (!template.name.startsWith('Scroll:')) throw new SenderError('Not a recipe scroll');

  // Extract recipe name from scroll name: "Scroll: Longsword" → find recipe with name "Longsword"
  const recipeName = template.name.replace('Scroll: ', '').trim();
  const recipe = [...ctx.db.recipeTemplate.iter()].find(r => r.name === recipeName);
  if (!recipe) throw new SenderError('No recipe found for this scroll');

  // Check if already known
  const alreadyKnown = [...ctx.db.recipeDiscovered.by_character.filter(characterId)]
    .some(r => r.recipeTemplateId === recipe.id);
  if (alreadyKnown) {
    appendPrivateEvent(ctx, characterId, character.ownerUserId, 'system',
      `You already know: ${recipe.name}`);
    // Still consume the scroll
  } else {
    ctx.db.recipeDiscovered.insert({
      id: 0n,
      characterId,
      recipeTemplateId: recipe.id,
      discoveredAt: ctx.timestamp,
    });
    appendPrivateEvent(ctx, characterId, character.ownerUserId, 'system',
      `You have learned: ${recipe.name}`);
  }

  // Consume the scroll (remove 1 from stack)
  removeItemFromInventory(ctx, characterId, instance.templateId, 1n);
});
```

**Part C: Ensure `buildDisplayName` in `helpers/items.ts` works with CraftedAffix format**

The existing `buildDisplayName(baseName, affixes)` in helpers/items.ts was built for the random affix format from Phase 14. Verify it accepts the `CraftedAffix` format from `crafting_materials.ts`. If the function expects `{ affixType, affixName }` fields, the CraftedAffix objects have these same fields so it should work. If the interface differs, add an adapter or update the function signature to accept both formats.

If `buildDisplayName` doesn't exist or has a different signature, create a version that:
- Takes base item name + array of `{ affixType: 'prefix'|'suffix', affixName: string }`
- Finds the first prefix and prepends it: `"Fierce Iron Longsword"`
- Finds the first suffix and appends it: `"Fierce Iron Longsword of Strength"`
  </action>
  <verify>
    - grep for `getCraftedAffixes` in reducers/items.ts to confirm deterministic affix lookup in craft_recipe
    - grep for `learn_recipe_scroll` in reducers/items.ts to confirm new reducer exists
    - grep for `materialTierToQuality` in reducers/items.ts to confirm quality tier derivation
    - Verify buildDisplayName compatibility: read helpers/items.ts to check function signature
    - TypeScript compiles without new errors in these files
  </verify>
  <done>
    - craft_recipe applies deterministic affixes to gear items based on material type and tier
    - Crafted gear gets qualityTier, displayName, and ItemAffix rows (matching take_loot pattern)
    - Consumable recipes bypass the affix logic entirely
    - learn_recipe_scroll reducer exists: validates scroll, extracts recipe name, checks duplicates, inserts RecipeDiscovered, consumes scroll
    - buildDisplayName works with crafted affix format
  </done>
</task>

</tasks>

<verification>
- Salvage_item grants materials (not gold) and has 75% recipe discovery chance
- Craft_recipe applies deterministic affixes for gear recipes using MATERIAL_AFFIX_MAP
- Learn_recipe_scroll reducer enables scroll-based recipe learning
- Consumable recipes unaffected
- No changes to frontend files (that is Plan 03)
- Backend compiles without new errors
</verification>

<success_criteria>
The full crafting reducer pipeline works: salvaging gear yields materials and teaches recipes, crafting gear with materials produces deterministic quality/affix items, and recipe scrolls can be used to learn recipes. Combined with Plan 01's data foundation, the backend crafting system is complete.
</success_criteria>

<output>
After completion, create `.planning/phases/13-crafting-system-weapons-armor-extend-recipe-system-for-gear-crafting-material-requirements-and-gathering-crafted-gear-as-deterministic-progression-path/13-02-SUMMARY.md`
</output>
