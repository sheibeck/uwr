---
phase: 04-llm-architecture
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/composables/useLlmContent.ts
  - src/components/GeneratedTextBlock.vue
  - src/composables/useGameData.ts
  - src/App.vue
autonomous: false

must_haves:
  truths:
    - "Client can call generate_content procedure via conn.procedures.generateContent"
    - "useLlmContent composable exposes generateContent function and loading/error state"
    - "GeneratedTextBlock component renders pending (loading placeholder), ready (generated text), and failed (fallback text) states"
    - "useGameData subscribes to generatedQuestText and generatedEventText tables"
    - "Loading state shows on-tone placeholder text (not generic 'Loading...')"
    - "Human verifies: set_llm_config reducer sets API key, generate_content procedure returns result, table row flips from pending to ready or failed"
  artifacts:
    - path: "src/composables/useLlmContent.ts"
      provides: "generateContent function, loading refs, error handling"
      exports: ["useLlmContent"]
    - path: "src/components/GeneratedTextBlock.vue"
      provides: "Vue component rendering generated text with pending/ready/failed states"
      min_lines: 30
    - path: "src/composables/useGameData.ts"
      provides: "Updated with generatedQuestText and generatedEventText subscriptions"
      contains: "generatedQuestText"
    - path: "src/App.vue"
      provides: "Updated with useLlmContent wiring (minimal — no full UI panel yet)"
      contains: "useLlmContent"
  key_links:
    - from: "src/composables/useLlmContent.ts"
      to: "src/module_bindings"
      via: "imports DbConnection, tables, procedures"
      pattern: "module_bindings"
    - from: "src/composables/useLlmContent.ts"
      to: "conn.procedures.generateContent"
      via: "procedure call"
      pattern: "procedures\\.generateContent"
    - from: "src/components/GeneratedTextBlock.vue"
      to: "src/composables/useGameData.ts"
      via: "receives generatedQuestText/generatedEventText as props"
      pattern: "status.*pending|ready|failed"
---

<objective>
Wire up client-side LLM content integration: composable for calling the procedure, component for rendering generated text states, and useGameData subscriptions for the new tables. Then human-verify the end-to-end flow.

Purpose: Complete the client-side plumbing so future phases (Quests, World Events) can call generateContent and render results. This phase does NOT build consumer UI — just the reusable primitives.

Output: useLlmContent composable, GeneratedTextBlock component, updated useGameData, minimal App.vue wiring. Human-verified end-to-end flow.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-llm-architecture/04-RESEARCH.md
@.planning/phases/04-llm-architecture/04-01-SUMMARY.md
@.planning/phases/04-llm-architecture/04-02-SUMMARY.md
@src/composables/useGameData.ts
@src/main.ts
@src/App.vue
@src/ui/styles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLlmContent composable, GeneratedTextBlock component, and update useGameData</name>
  <files>src/composables/useLlmContent.ts, src/components/GeneratedTextBlock.vue, src/composables/useGameData.ts, src/App.vue</files>
  <action>
**File 1: `src/composables/useLlmContent.ts`** (NEW)

Create a composable that wraps the generate_content procedure call:

```typescript
import { ref } from 'vue';

export interface UseLlmContentArgs {
  conn: any;
}

export const useLlmContent = ({ conn }: UseLlmContentArgs) => {
  const isGenerating = ref(false);
  const lastError = ref<string | null>(null);
  const lastResult = ref<string | null>(null);

  const generateContent = async (contentType: string, contentId: bigint, contextJson: string) => {
    if (!conn.value) {
      lastError.value = 'Not connected';
      return null;
    }
    isGenerating.value = true;
    lastError.value = null;
    lastResult.value = null;
    try {
      const result = await conn.value.procedures.generateContent({
        contentType,
        contentId,
        contextJson,
      });
      lastResult.value = result;
      isGenerating.value = false;
      return result;
    } catch (err: unknown) {
      lastError.value = err instanceof Error ? err.message : 'Generation failed';
      isGenerating.value = false;
      return null;
    }
  };

  return {
    generateContent,
    isGenerating,
    lastError,
    lastResult,
  };
};
```

Note: `conn` is passed as a `Ref` from useGameData (the raw conn from `useSpacetimeDB()`). The procedure call returns a `Promise<string>` per the research (the procedure returns `t.string()`).

**File 2: `src/components/GeneratedTextBlock.vue`** (NEW)

Create a Vue component that renders generated text based on status:

```vue
<script setup lang="ts">
defineProps<{
  status: string | null;      // 'pending' | 'ready' | 'failed' | null
  text: string | null;        // The generated or fallback text (JSON string)
  isGenerating?: boolean;     // True while procedure call is in flight
}>();

const containerStyle = { padding: '8px 0' };
const pendingStyle = { color: '#888', fontStyle: 'italic' };
const readyStyle = { color: '#e0d8c8' };
const fallbackStyle = { color: '#c0b8a8', fontStyle: 'italic' };
const emptyStyle = { color: '#666', fontStyle: 'italic' };

function parseText(text: string): Record<string, unknown> | null {
  try { return JSON.parse(text); } catch { return null; }
}

function displayText(text: string): string {
  try {
    const parsed = JSON.parse(text);
    if (parsed.description) return parsed.description;
    if (parsed.consequence) return parsed.consequence;
    if (parsed.text) return parsed.text;
    return text;
  } catch { return text; }
}
</script>

<template>
  <div :style="containerStyle">
    <div v-if="isGenerating || status === 'pending'" :style="pendingStyle">
      <span>The narrator clears their throat...</span>
    </div>
    <div v-else-if="status === 'ready' && text" :style="readyStyle">
      <slot :parsed="parseText(text)">
        {{ displayText(text) }}
      </slot>
    </div>
    <div v-else-if="status === 'failed' && text" :style="fallbackStyle">
      <slot name="fallback" :parsed="parseText(text)">
        {{ displayText(text) }}
      </slot>
    </div>
    <div v-else :style="emptyStyle">
      <span>The story has yet to be written...</span>
    </div>
  </div>
</template>
```

**File 3: Update `src/composables/useGameData.ts`**

Add two new useTable subscriptions after the existing factionStandings line:

```typescript
const [generatedQuestText] = useTable(tables.generatedQuestText);
const [generatedEventText] = useTable(tables.generatedEventText);
```

Add both to the return object:
```typescript
generatedQuestText,
generatedEventText,
```

**File 4: Update `src/App.vue`** (minimal wiring)

Import and initialize useLlmContent in the script setup section, alongside other composables:

```typescript
import { useLlmContent } from './composables/useLlmContent';
```

In the setup block where other composables are called (after useGameData):
```typescript
const { generateContent, isGenerating, lastError: llmError, lastResult: llmResult } = useLlmContent({ conn });
```

Where `conn` comes from `useGameData()` return value.

Also destructure `generatedQuestText` and `generatedEventText` from the useGameData return.

No UI rendering changes needed in the template yet — this is plumbing only. Future phases (Quest System, World Events) will use `generateContent()` and `<GeneratedTextBlock>` when building their panels.

Optionally, add a `<!-- LLM Content (Phase 4 plumbing — no UI yet) -->` comment in the template where future integration will go.
  </action>
  <verify>Run `npx vite build` (or `npm run build`) to confirm frontend compiles without errors. Verify `useLlmContent` is imported in App.vue. Verify `generatedQuestText` and `generatedEventText` appear in useGameData return. Verify GeneratedTextBlock.vue exists with status/text props.</verify>
  <done>Client plumbing complete: useLlmContent composable wraps procedure call with loading/error state, GeneratedTextBlock renders text by status, useGameData subscribes to generated text tables, App.vue has composable wired (no UI yet).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verification of end-to-end LLM pipeline</name>
  <files>none</files>
  <action>
Human verifies the complete LLM content pipeline end-to-end.

What was built across all 3 plans:
- Backend: LlmConfig, GeneratedQuestText, GeneratedEventText, LlmCircuit tables
- Backend: set_llm_config reducer, reset_llm_circuit scheduled reducer
- Backend: generate_content procedure with Anthropic API call, circuit breaker, fallback writing
- Client: useLlmContent composable, GeneratedTextBlock component, useGameData subscriptions

**Test 1: Set API key (via SpacetimeDB CLI or browser console)**

Option A — Browser console (if connected):
```javascript
window.__db_conn.reducers.setLlmConfig({ adminSecret: 'changeme-shadeslinger-admin', apiKey: 'YOUR_ANTHROPIC_API_KEY', defaultModel: 'claude-haiku-4-5-20251001' })
```

Option B — SpacetimeDB CLI:
```bash
spacetime call uwr set_llm_config '["changeme-shadeslinger-admin", "YOUR_API_KEY", "claude-haiku-4-5-20251001"]'
```

Verify: No error in console. Check `spacetime logs uwr` for confirmation.

**Test 2: Call generate_content procedure (browser console)**
```javascript
const result = await window.__db_conn.procedures.generateContent({ contentType: 'quest_description', contentId: 1n, contextJson: '{"questName":"The Lost Shipment","faction":"Iron Compact"}' })
console.log('Result:', result)
```

Expected: Returns 'ok' if API key is valid, or 'fallback:*' if not.

**Test 3: Verify generated text row exists**

Check `spacetime sql uwr "SELECT * FROM generated_quest_text"` — should show a row with status 'ready' (if API key valid) or 'failed' (if not, with fallback text).

**Test 4: Circuit breaker test (optional)**

Set a bad API key, call generate_content 3 times. 4th call should return 'fallback:circuit_open'.

**Test 5: Prompt injection test (optional)**

Call with contextJson containing injection attempt. Verify sanitized output.

**What to look for:**
1. No errors in `spacetime logs uwr`
2. Generated text rows appear in the database
3. Fallback text is in Shadeslinger tone
4. Frontend compiles and loads without errors
  </action>
  <verify>Human confirms pipeline works: set API key, call procedure, verify row in database with status 'ready' or 'failed' with fallback text. Type "approved" or describe issues.</verify>
  <done>Human has verified the end-to-end LLM content pipeline: admin config, API call, fallback handling, and client compilation all confirmed working.</done>
</task>

</tasks>

<verification>
- Frontend builds without errors (`npx vite build`)
- useLlmContent composable exports generateContent function
- GeneratedTextBlock component renders 4 states (pending, ready, failed, empty)
- useGameData returns generatedQuestText and generatedEventText
- set_llm_config reducer accepts and stores API key
- generate_content procedure calls Anthropic API and writes result
- Fallback text written on any failure — no row stays 'pending'
- Circuit breaker opens after 3 failures, auto-resets after 5 minutes
</verification>

<success_criteria>
Human confirms: Admin sets API key via reducer. Calling generate_content procedure produces a generated text row (status 'ready' with valid API key, or status 'failed' with fallback text). Frontend compiles cleanly. The end-to-end pipeline is verified working.
</success_criteria>

<output>
After completion, create `.planning/phases/04-llm-architecture/04-03-SUMMARY.md`
</output>
