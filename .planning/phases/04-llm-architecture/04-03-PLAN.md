---
phase: 04-llm-architecture
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/composables/useLlmContent.ts
  - src/components/GeneratedTextBlock.vue
  - src/composables/useGameData.ts
  - src/App.vue
autonomous: false

must_haves:
  truths:
    - "Client can call generate_content procedure via conn.procedures.generateContent"
    - "Client can call request_content reducer via conn.reducers.requestContent to insert 'pending' row"
    - "useLlmContent composable exposes requestAndGenerate function that calls requestContent reducer then generateContent procedure"
    - "GeneratedTextBlock component renders pending (loading placeholder), ready (generated text), and failed (fallback text) states"
    - "useGameData subscribes to generatedQuestText and generatedEventText tables"
    - "Loading state shows on-tone placeholder text (not generic 'Loading...')"
    - "Human verifies: set_llm_config reducer sets API key, requestContent inserts pending row, generate_content procedure flips row from pending to ready or failed"
  artifacts:
    - path: "src/composables/useLlmContent.ts"
      provides: "requestAndGenerate function (calls requestContent then generateContent), loading refs, error handling"
      exports: ["useLlmContent"]
    - path: "src/components/GeneratedTextBlock.vue"
      provides: "Vue component rendering generated text with pending/ready/failed states"
      min_lines: 30
    - path: "src/composables/useGameData.ts"
      provides: "Updated with generatedQuestText and generatedEventText subscriptions"
      contains: "generatedQuestText"
    - path: "src/App.vue"
      provides: "Updated with useLlmContent wiring (minimal -- no full UI panel yet)"
      contains: "useLlmContent"
  key_links:
    - from: "src/App.vue"
      to: "src/composables/useLlmContent.ts"
      via: "useLlmContent({ conn }) called from App.vue"
      pattern: "useLlmContent"
    - from: "src/composables/useLlmContent.ts"
      to: "conn.reducers.requestContent"
      via: "reducer call to insert pending row before procedure call"
      pattern: "reducers\\.requestContent"
    - from: "src/composables/useLlmContent.ts"
      to: "conn.procedures.generateContent"
      via: "procedure call"
      pattern: "procedures\\.generateContent"
    - from: "src/components/GeneratedTextBlock.vue"
      to: "src/composables/useGameData.ts"
      via: "receives generatedQuestText/generatedEventText as props"
      pattern: "status.*pending|ready|failed"
---

<objective>
Wire up client-side LLM content integration: composable for calling the request_content reducer then generate_content procedure, component for rendering generated text states, and useGameData subscriptions for the new tables. Then human-verify the end-to-end flow including the pending -> ready lifecycle.

Purpose: Complete the client-side plumbing so future phases (Quests, World Events) can call requestAndGenerate and render results. This phase does NOT build consumer UI -- just the reusable primitives.

Output: useLlmContent composable, GeneratedTextBlock component, updated useGameData, minimal App.vue wiring. Human-verified end-to-end flow.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-llm-architecture/04-RESEARCH.md
@.planning/phases/04-llm-architecture/04-01-SUMMARY.md
@.planning/phases/04-llm-architecture/04-02-SUMMARY.md
@src/composables/useGameData.ts
@src/main.ts
@src/App.vue
@src/ui/styles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLlmContent composable, GeneratedTextBlock component, and update useGameData</name>
  <files>src/composables/useLlmContent.ts, src/components/GeneratedTextBlock.vue, src/composables/useGameData.ts, src/App.vue</files>
  <action>
**File 1: `src/composables/useLlmContent.ts`** (NEW)

Create a composable that wraps the request_content reducer + generate_content procedure flow:

```typescript
import { ref } from 'vue';

export interface UseLlmContentArgs {
  conn: any;
}

export const useLlmContent = ({ conn }: UseLlmContentArgs) => {
  const isGenerating = ref(false);
  const lastError = ref<string | null>(null);
  const lastResult = ref<string | null>(null);

  /**
   * Full lifecycle: insert pending row via reducer, then call procedure to fill it.
   * The pending row is immediately visible to subscribers before the procedure completes.
   */
  const requestAndGenerate = async (contentType: string, contentId: bigint, contextJson: string) => {
    if (!conn.value) {
      lastError.value = 'Not connected';
      return null;
    }
    isGenerating.value = true;
    lastError.value = null;
    lastResult.value = null;
    try {
      // Step 1: Insert 'pending' row via reducer (idempotent)
      conn.value.reducers.requestContent({
        contentType,
        contentId,
      });

      // Step 2: Call procedure to fill the row with generated or fallback content
      const result = await conn.value.procedures.generateContent({
        contentType,
        contentId,
        contextJson,
      });
      lastResult.value = result;
      isGenerating.value = false;
      return result;
    } catch (err: unknown) {
      lastError.value = err instanceof Error ? err.message : 'Generation failed';
      isGenerating.value = false;
      return null;
    }
  };

  return {
    requestAndGenerate,
    isGenerating,
    lastError,
    lastResult,
  };
};
```

Note: `conn` is passed as a `Ref` from useGameData (the raw conn from `useSpacetimeDB()`). The reducer call is fire-and-forget (reducers don't return values). The procedure call returns a `Promise<string>`.

**File 2: `src/components/GeneratedTextBlock.vue`** (NEW)

Create a Vue component that renders generated text based on status:

```vue
<script setup lang="ts">
defineProps<{
  status: string | null;      // 'pending' | 'ready' | 'failed' | null
  text: string | null;        // The generated or fallback text (JSON string)
  isGenerating?: boolean;     // True while procedure call is in flight
}>();

const containerStyle = { padding: '8px 0' };
const pendingStyle = { color: '#888', fontStyle: 'italic' };
const readyStyle = { color: '#e0d8c8' };
const fallbackStyle = { color: '#c0b8a8', fontStyle: 'italic' };
const emptyStyle = { color: '#666', fontStyle: 'italic' };

function parseText(text: string): Record<string, unknown> | null {
  try { return JSON.parse(text); } catch { return null; }
}

function displayText(text: string): string {
  try {
    const parsed = JSON.parse(text);
    if (parsed.description) return parsed.description;
    if (parsed.consequence) return parsed.consequence;
    if (parsed.text) return parsed.text;
    return text;
  } catch { return text; }
}
</script>

<template>
  <div :style="containerStyle">
    <div v-if="isGenerating || status === 'pending'" :style="pendingStyle">
      <span>The narrator clears their throat...</span>
    </div>
    <div v-else-if="status === 'ready' && text" :style="readyStyle">
      <slot :parsed="parseText(text)">
        {{ displayText(text) }}
      </slot>
    </div>
    <div v-else-if="status === 'failed' && text" :style="fallbackStyle">
      <slot name="fallback" :parsed="parseText(text)">
        {{ displayText(text) }}
      </slot>
    </div>
    <div v-else :style="emptyStyle">
      <span>The story has yet to be written...</span>
    </div>
  </div>
</template>
```

**File 3: Update `src/composables/useGameData.ts`**

Add two new useTable subscriptions after the existing factionStandings line:

```typescript
const [generatedQuestText] = useTable(tables.generatedQuestText);
const [generatedEventText] = useTable(tables.generatedEventText);
```

Add both to the return object:
```typescript
generatedQuestText,
generatedEventText,
```

**File 4: Update `src/App.vue`** (minimal wiring)

Import and initialize useLlmContent in the script setup section, alongside other composables:

```typescript
import { useLlmContent } from './composables/useLlmContent';
```

In the setup block where other composables are called (after useGameData):
```typescript
const { requestAndGenerate, isGenerating, lastError: llmError, lastResult: llmResult } = useLlmContent({ conn });
```

Where `conn` comes from `useGameData()` return value.

Also destructure `generatedQuestText` and `generatedEventText` from the useGameData return.

No UI rendering changes needed in the template yet -- this is plumbing only. Future phases (Quest System, World Events) will use `requestAndGenerate()` and `<GeneratedTextBlock>` when building their panels.

Optionally, add a `<!-- LLM Content (Phase 4 plumbing -- no UI yet) -->` comment in the template where future integration will go.
  </action>
  <verify>Run `npx vite build` (or `npm run build`) to confirm frontend compiles without errors. Verify `useLlmContent` is imported in App.vue. Verify `generatedQuestText` and `generatedEventText` appear in useGameData return. Verify GeneratedTextBlock.vue exists with status/text props.</verify>
  <done>Client plumbing complete: useLlmContent composable wraps requestContent reducer + generateContent procedure with loading/error state, GeneratedTextBlock renders text by status, useGameData subscribes to generated text tables, App.vue has composable wired (no UI yet).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verification of end-to-end LLM pipeline including pending row lifecycle</name>
  <files>none</files>
  <action>
Human verifies the complete LLM content pipeline end-to-end, including the pending -> ready/failed lifecycle.

What was built across all 3 plans:
- Backend: LlmConfig, GeneratedQuestText, GeneratedEventText, LlmCircuit tables
- Backend: set_llm_config reducer, reset_llm_circuit scheduled reducer, request_content reducer
- Backend: generate_content procedure with Anthropic API call, circuit breaker, fallback writing
- Client: useLlmContent composable (requestAndGenerate), GeneratedTextBlock component, useGameData subscriptions

**Test 1: Set API key (via SpacetimeDB CLI or browser console)**

Option A -- Browser console (if connected):
```javascript
window.__db_conn.reducers.setLlmConfig({ adminSecret: 'changeme-shadeslinger-admin', apiKey: 'YOUR_ANTHROPIC_API_KEY', defaultModel: 'claude-haiku-4-5-20251001' })
```

Option B -- SpacetimeDB CLI:
```bash
spacetime call uwr set_llm_config '["changeme-shadeslinger-admin", "YOUR_API_KEY", "claude-haiku-4-5-20251001"]'
```

Verify: No error in console. Check `spacetime logs uwr` for confirmation.

**Test 2: Insert pending row via request_content reducer (browser console)**
```javascript
window.__db_conn.reducers.requestContent({ contentType: 'quest_description', contentId: 1n })
```

Verify: `spacetime sql uwr "SELECT * FROM generated_quest_text"` shows a row with status 'pending', empty text, and empty model.

**Test 3: Call generate_content procedure to fill the pending row (browser console)**
```javascript
const result = await window.__db_conn.procedures.generateContent({ contentType: 'quest_description', contentId: 1n, contextJson: '{"questName":"The Lost Shipment","faction":"Iron Compact"}' })
console.log('Result:', result)
```

Expected: Returns 'ok' if API key is valid, or 'fallback:*' if not.

**Test 4: Verify row flipped from pending to ready/failed**

Check `spacetime sql uwr "SELECT * FROM generated_quest_text"` -- the row that was 'pending' should now show status 'ready' (if API key valid) or 'failed' (if not, with fallback text). This confirms the observable pending -> ready/failed lifecycle.

**Test 5: Circuit breaker test (optional)**

Set a bad API key, call generate_content 3 times. 4th call should return 'fallback:circuit_open'.

**Test 6: Idempotency test (optional)**

Call requestContent with the same contentType and contentId again. Verify no duplicate row is created (request_content is idempotent).

**What to look for:**
1. No errors in `spacetime logs uwr`
2. 'pending' row appears after requestContent reducer call
3. Row status flips to 'ready' or 'failed' after generateContent procedure call
4. Fallback text is in Shadeslinger tone
5. Frontend compiles and loads without errors
  </action>
  <verify>Human confirms pipeline works: requestContent creates pending row, generateContent flips it to ready/failed, set API key works, frontend compiles. Type "approved" or describe issues.</verify>
  <done>Human has verified the end-to-end LLM content pipeline: admin config, pending row insertion, API call, fallback handling, pending->ready/failed lifecycle, and client compilation all confirmed working.</done>
</task>

</tasks>

<verification>
- Frontend builds without errors (`npx vite build`)
- useLlmContent composable exports requestAndGenerate function
- GeneratedTextBlock component renders 4 states (pending, ready, failed, empty)
- useGameData returns generatedQuestText and generatedEventText
- set_llm_config reducer accepts and stores API key
- request_content reducer inserts 'pending' row (idempotent)
- generate_content procedure calls Anthropic API and writes result
- Row lifecycle observable: pending -> ready (success) or pending -> failed (any failure)
- Fallback text written on any failure -- no row stays 'pending' after procedure completes
- Circuit breaker opens after 3 failures, auto-resets after 5 minutes
</verification>

<success_criteria>
Human confirms: Admin sets API key via reducer. Calling requestContent inserts a 'pending' row. Calling generateContent flips the row to 'ready' (with valid API key) or 'failed' (with fallback text). Frontend compiles cleanly. The end-to-end pipeline with observable pending -> ready/failed lifecycle is verified working.
</success_criteria>

<output>
After completion, create `.planning/phases/04-llm-architecture/04-03-SUMMARY.md`
</output>
