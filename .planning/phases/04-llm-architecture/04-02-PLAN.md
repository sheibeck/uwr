---
phase: 04-llm-architecture
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - spacetimedb/src/procedures/llm.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "generate_content procedure calls Anthropic API via ctx.http.fetch with 30s timeout"
    - "Procedure reads LlmConfig from DB inside ctx.withTx -- never uses ctx.db directly"
    - "Missing or empty API key causes immediate fallback write -- no API call"
    - "Open circuit state causes immediate fallback write -- no API call"
    - "Successful API response parses JSON and writes to GeneratedQuestText or GeneratedEventText with status 'ready'"
    - "Failed API call (5xx, network error) writes fallback text with status 'failed' -- row never stays 'pending'"
    - "3 failures within 60 seconds opens circuit and schedules LlmCircuit reset 5 minutes later"
    - "429 rate limit does NOT open circuit -- writes fallback only"
    - "Input sanitization strips control characters and limits length before prompt inclusion"
    - "Prompt caching applied via cache_control on system message block"
  artifacts:
    - path: "spacetimedb/src/procedures/llm.ts"
      provides: "generate_content procedure with circuit breaker, fallback, and Anthropic API integration via registerLlmProcedures(deps) factory"
      min_lines: 80
    - path: "spacetimedb/src/index.ts"
      provides: "Updated to call registerLlmProcedures(deps) after schema export"
      contains: "registerLlmProcedures"
  key_links:
    - from: "spacetimedb/src/index.ts"
      to: "spacetimedb/src/procedures/llm.ts"
      via: "registerLlmProcedures(deps) called from index.ts after schema export"
      pattern: "registerLlmProcedures"
    - from: "spacetimedb/src/procedures/llm.ts"
      to: "spacetimedb/src/data/llm_content.ts"
      via: "imports buildAnthropicRequest, FALLBACK_CONTENT, sanitizeForPrompt"
      pattern: "import.*llm_content"
    - from: "spacetimedb/src/procedures/llm.ts"
      to: "https://api.anthropic.com/v1/messages"
      via: "ctx.http.fetch"
      pattern: "ctx\\.http\\.fetch"
---

<objective>
Implement the generate_content procedure -- the core LLM pipeline that calls Anthropic's API, handles failures gracefully, and writes results to content tables.

Purpose: This is the heart of the LLM architecture. The procedure handles the full lifecycle: read config, check circuit breaker, call API, parse response, write result or fallback. It must guarantee that no content row ever stays in 'pending' status after the procedure completes.

Output: New procedures directory with llm.ts containing generate_content procedure via registerLlmProcedures factory. Updated index.ts to import and call it.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-llm-architecture/04-RESEARCH.md
@.planning/phases/04-llm-architecture/04-01-SUMMARY.md
@spacetimedb/src/index.ts
@spacetimedb/src/data/llm_content.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate_content procedure with circuit breaker and fallback logic using registerLlmProcedures factory</name>
  <files>spacetimedb/src/procedures/llm.ts</files>
  <action>
Create directory `spacetimedb/src/procedures/` and file `spacetimedb/src/procedures/llm.ts`.

This file exports a `registerLlmProcedures` factory function (same pattern as `registerLlmReducers` in `reducers/llm.ts`) that receives deps and registers the procedure. It also imports helpers from `../data/llm_content`.

```typescript
import { t } from 'spacetimedb/server';
import {
  buildAnthropicRequest,
  FALLBACK_CONTENT,
  sanitizeForPrompt,
} from '../data/llm_content';

export const registerLlmProcedures = (deps: any) => {
  const { spacetimedb, ScheduleAt, TimeDuration } = deps;

  // ... helper functions and procedure definition below
};
```

**Inside the `registerLlmProcedures` function, define the helper functions and the procedure.**

**CRITICAL: Procedures use `ctx.withTx()` for ALL database access. `ctx.db` does NOT exist in procedures.**

Define the procedure:
```typescript
spacetimedb.procedure(
  'generate_content',
  { contentType: t.string(), contentId: t.u64(), contextJson: t.string() },
  t.string(),
  (ctx, { contentType, contentId, contextJson }) => {
    // ... implementation below
  }
);
```

**Inside the procedure, implement this exact flow:**

1. **Read config (inside withTx):**
```typescript
const config = ctx.withTx((tx: any) => {
  return [...tx.db.llmConfig.iter()][0] ?? null;
});
```

2. **Guard: no config or no API key -> write fallback immediately:**
```typescript
if (!config || !config.apiKey) {
  writeFallback(ctx, contentType, contentId, 'no_config');
  return 'fallback:no_config';
}
```

3. **Guard: circuit open -> write fallback immediately:**
```typescript
if (config.circuitState === 'open') {
  writeFallback(ctx, contentType, contentId, 'circuit_open');
  return 'fallback:circuit_open';
}
```

4. **Sanitize contextJson** -- parse, sanitize all string values, re-stringify:
```typescript
let safeContext = contextJson;
try {
  const parsed = JSON.parse(contextJson);
  if (typeof parsed === 'object' && parsed !== null) {
    for (const key of Object.keys(parsed)) {
      if (typeof parsed[key] === 'string') {
        parsed[key] = sanitizeForPrompt(parsed[key], 200);
      }
    }
    safeContext = JSON.stringify(parsed);
  }
} catch {
  safeContext = sanitizeForPrompt(contextJson, 500);
}
```

5. **Call Anthropic API (OUTSIDE withTx):**
```typescript
try {
  const requestBody = buildAnthropicRequest(contentType, safeContext, config.defaultModel);
  const response = ctx.http.fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'x-api-key': config.apiKey,
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json',
    },
    body: JSON.stringify(requestBody),
    timeout: TimeDuration.fromMillis(30_000),
  });
```

6. **Handle non-OK response:**
```typescript
  if (!response.ok) {
    const status = response.status;
    if (status === 429) {
      // Rate limited -- write fallback but do NOT open circuit
      writeFallback(ctx, contentType, contentId, 'rate_limited');
      return 'fallback:rate_limited';
    }
    // 4xx/5xx -- record failure, possibly open circuit
    recordFailure(ctx, config);
    writeFallback(ctx, contentType, contentId, `api_error_${status}`);
    return `fallback:api_error_${status}`;
  }
```

7. **Parse successful response:**
```typescript
  const body = response.json();
  const generatedText = body.content[0].text;

  // Validate it's valid JSON
  try {
    JSON.parse(generatedText);
  } catch {
    recordFailure(ctx, config);
    writeFallback(ctx, contentType, contentId, 'invalid_json');
    return 'fallback:invalid_json';
  }

  // Write success
  writeSuccess(ctx, contentType, contentId, generatedText, config.defaultModel);
  recordSuccess(ctx, config);
  return 'ok';
```

8. **Catch network/timeout errors:**
```typescript
} catch (e) {
  recordFailure(ctx, config);
  writeFallback(ctx, contentType, contentId, 'network_error');
  return 'fallback:network_error';
}
```

**Helper functions (define before the procedure definition, inside registerLlmProcedures):**

**`writeFallback`**: Picks a deterministic fallback from FALLBACK_CONTENT for the contentType, writes to the appropriate table. Updates the existing 'pending' row if one exists (inserted by request_content reducer), otherwise inserts a new row:
```typescript
function writeFallback(ctx: any, contentType: string, contentId: bigint, reason: string): void {
  const fallbacks = FALLBACK_CONTENT[contentType] ?? FALLBACK_CONTENT['quest_description'];
  // Deterministic selection: use contentId modulo array length (no Math.random)
  const idx = Number(contentId % BigInt(fallbacks.length));
  const text = fallbacks[idx];

  ctx.withTx((tx: any) => {
    if (contentType === 'quest_description') {
      const existing = [...tx.db.generatedQuestText.by_quest_template.filter(contentId)][0];
      if (existing) {
        tx.db.generatedQuestText.id.update({ ...existing, status: 'failed', text, model: `fallback:${reason}` });
      } else {
        tx.db.generatedQuestText.insert({ id: 0n, questTemplateId: contentId, status: 'failed', text, generatedAt: tx.timestamp, model: `fallback:${reason}` });
      }
    } else if (contentType === 'event_consequence') {
      const existing = [...tx.db.generatedEventText.by_event.filter(contentId)][0];
      if (existing) {
        tx.db.generatedEventText.id.update({ ...existing, status: 'failed', text, model: `fallback:${reason}` });
      } else {
        tx.db.generatedEventText.insert({ id: 0n, eventId: contentId, status: 'failed', text, generatedAt: tx.timestamp, model: `fallback:${reason}` });
      }
    }
  });
}
```

**`writeSuccess`**: Writes generated text with status 'ready'. Updates the existing 'pending' row if one exists:
```typescript
function writeSuccess(ctx: any, contentType: string, contentId: bigint, text: string, model: string): void {
  ctx.withTx((tx: any) => {
    if (contentType === 'quest_description') {
      const existing = [...tx.db.generatedQuestText.by_quest_template.filter(contentId)][0];
      if (existing) {
        tx.db.generatedQuestText.id.update({ ...existing, status: 'ready', text, generatedAt: tx.timestamp, model });
      } else {
        tx.db.generatedQuestText.insert({ id: 0n, questTemplateId: contentId, status: 'ready', text, generatedAt: tx.timestamp, model });
      }
    } else if (contentType === 'event_consequence') {
      const existing = [...tx.db.generatedEventText.by_event.filter(contentId)][0];
      if (existing) {
        tx.db.generatedEventText.id.update({ ...existing, status: 'ready', text, generatedAt: tx.timestamp, model });
      } else {
        tx.db.generatedEventText.insert({ id: 0n, eventId: contentId, status: 'ready', text, generatedAt: tx.timestamp, model });
      }
    }
  });
}
```

**`recordFailure`**: Increment failure count, open circuit if 3+ failures within 60s:
```typescript
function recordFailure(ctx: any, config: any): void {
  ctx.withTx((tx: any) => {
    const current = [...tx.db.llmConfig.iter()][0];
    if (!current) return;

    const nowMicros = tx.timestamp.microsSinceUnixEpoch;
    const windowMicros = 60_000_000n; // 60 seconds
    const timeSinceLast = nowMicros - current.lastFailureAtMicros;

    // Reset count if outside the 60s window
    const newCount = timeSinceLast > windowMicros ? 1 : current.failureCount + 1;

    const updated = {
      ...current,
      failureCount: newCount,
      lastFailureAtMicros: nowMicros,
    };

    if (newCount >= 3) {
      // Open circuit
      updated.circuitState = 'open';
      updated.failureCount = 0;
      // Schedule reset in 5 minutes
      tx.db.llmCircuit.insert({
        scheduledId: 0n,
        scheduledAt: ScheduleAt.time(nowMicros + 300_000_000n), // 5 minutes
      });
    }

    tx.db.llmConfig.singletonKey.update(updated);
  });
}
```

**`recordSuccess`**: Reset failure count on success:
```typescript
function recordSuccess(ctx: any, config: any): void {
  ctx.withTx((tx: any) => {
    const current = [...tx.db.llmConfig.iter()][0];
    if (!current) return;
    if (current.failureCount > 0) {
      tx.db.llmConfig.singletonKey.update({ ...current, failureCount: 0 });
    }
  });
}
```

**IMPORTANT CONSTRAINTS:**
- ALL database access MUST use `ctx.withTx(tx => tx.db...)` -- procedures do NOT have `ctx.db`
- The HTTP fetch is synchronous in SpacetimeDB procedures (returns SyncResponse, not Promise)
- `response.json()` returns parsed object directly
- `ScheduleAt` and `TimeDuration` come from deps (passed by index.ts)
- Import `t` from 'spacetimedb/server' at file top level (outside factory)
- Import data helpers from '../data/llm_content' at file top level (outside factory)
  </action>
  <verify>Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` to confirm no type errors. Verify the file contains: `registerLlmProcedures`, `spacetimedb.procedure`, `ctx.http.fetch`, `ctx.withTx`, `writeFallback`, `writeSuccess`, `recordFailure`, `recordSuccess`. Verify no usage of `ctx.db` (only `tx.db` inside withTx callbacks). Verify no `import { spacetimedb } from '../index'` (spacetimedb comes from deps).</verify>
  <done>generate_content procedure defined inside registerLlmProcedures factory with full circuit breaker logic, fallback writing, Anthropic API call with 30s timeout, input sanitization, and prompt caching. No content row stays in 'pending' status after procedure completes. No circular import -- spacetimedb object comes via deps.</done>
</task>

<task type="auto">
  <name>Task 2: Register procedure in index.ts via registerLlmProcedures, publish module, and regenerate bindings</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
1. **Add import at top of `spacetimedb/src/index.ts`** (alongside existing reducer imports):
```typescript
import { registerLlmProcedures } from './procedures/llm';
```

2. **Call `registerLlmProcedures` after `registerReducers(reducerDeps);`:**

Find the line `registerReducers(reducerDeps);` in index.ts and add immediately after it:
```typescript
// Register LLM procedures (must be after schema export)
registerLlmProcedures({
  spacetimedb,
  ScheduleAt,
  TimeDuration,
});
```

This requires `ScheduleAt` and `TimeDuration` to be imported from `'spacetimedb'` at the top of index.ts (if not already). Add to the existing spacetimedb import:
```typescript
import { ScheduleAt, TimeDuration } from 'spacetimedb';
```

The `spacetimedb` variable (the schema object) is already defined in index.ts. This pattern avoids any circular dependency -- `procedures/llm.ts` never imports from `index.ts`.

3. **Publish the module:**
```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb/
```

Use `--clear-database` because we're adding new tables. Check `spacetime server list` first to confirm the default server.

4. **Regenerate client bindings:**
```bash
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb/
```

5. **Verify bindings generated** -- check that `src/module_bindings/` contains references to `generateContent` procedure, `requestContent` reducer, and the new tables (`generatedQuestText`, `generatedEventText`, `llmConfig`).
  </action>
  <verify>Run `spacetime logs uwr` to check for startup errors. Verify `src/module_bindings/` contains generateContent procedure type and requestContent reducer type. Run `npx tsc --noEmit` (frontend) to confirm no client type errors after binding regeneration. Grep index.ts for `registerLlmProcedures` to confirm wiring.</verify>
  <done>Procedure registered in module via registerLlmProcedures factory (no circular import). Module published to SpacetimeDB. Client bindings regenerated with generate_content procedure type and request_content reducer type available for client consumption in Plan 03.</done>
</task>

</tasks>

<verification>
- Module publishes without errors
- `spacetime logs uwr` shows clean startup (no panics, no "reading 'tag'" errors)
- Client bindings include generateContent procedure and requestContent reducer
- No `ctx.db` usage in procedures/llm.ts (only `tx.db` inside withTx)
- No `import { spacetimedb } from '../index'` in procedures/llm.ts (uses deps pattern)
- Circuit breaker logic: 3 failures in 60s opens circuit, 5-minute auto-reset scheduled
- 429 does not open circuit
- Fallback text always written on any failure path
</verification>

<success_criteria>
generate_content procedure is deployed and callable. Client bindings include both the procedure type and request_content reducer type. The full failure handling pipeline works: missing config serves fallback, open circuit serves fallback, API error records failure and serves fallback, 3 failures open circuit, circuit auto-resets after 5 minutes. Successful API calls write 'ready' status text. No circular imports exist.
</success_criteria>

<output>
After completion, create `.planning/phases/04-llm-architecture/04-02-SUMMARY.md`
</output>
