# Phase 13.1: Dual-Axis Gear System, Craft Quality vs Rarity, Material Consolidation, Essence Material, Metadata Consistency — Research

**Researched:** 2026-02-17
**Domain:** SpacetimeDB TypeScript backend schema, seeding system, item crafting system, Vue frontend
**Confidence:** HIGH — all findings are based on direct codebase inspection

---

## Summary

Phase 13.1 is a focused refactor and extension of the Phase 13 crafting system. It introduces five
distinct concerns that interact at the schema, seeding, reducer, and UI layers. The research
confirms none of these changes require new external libraries; all work within the existing
SpacetimeDB TypeScript SDK and Vue/TypeScript stack.

The most impactful change is the dual-axis gear model. Currently, Phase 13 conflates craft quality
with rarity: `materialTierToQuality()` maps material tier 1→common, 2→uncommon, 3→rare, and this
drives which affix set is applied. The user's intent is to separate these two dimensions so that
craft quality (Dented/Standard/Reinforced/Exquisite/Mastercraft) controls base stats, while rarity
(Common through Legendary) independently controls magical affix count and power. This requires a new
field on `ItemInstance` and changes to the craft reducer logic.

The remaining four tasks (metadata consistency, material consolidation, recipe system consolidation,
and Essence material) are additive and lower risk: they extend existing patterns without changing
the data model in breaking ways.

**Primary recommendation:** Implement dual-axis in layers — schema first (add `craftQuality` to
`ItemInstance`), then update seeding and reducer, then frontend. Keep rarity and craft quality as
orthogonal fields from the start to avoid a second refactor.

---

## Standard Stack

### Core (no changes needed)
| Component | Version | Purpose |
|-----------|---------|---------|
| SpacetimeDB TypeScript SDK | 1.11.x | Tables, reducers, bindings |
| Vue 3 | (existing) | Frontend reactivity and components |
| TypeScript | (existing) | Type safety on client and server |

No new packages are required. All work is within the existing module.

---

## Architecture Patterns

### Current Craft Quality Mapping (Phase 13 state to refactor)

In `crafting_materials.ts`, `materialTierToQuality()` maps material tier to a quality tier string
that doubles as rarity:

```typescript
// spacetimedb/src/data/crafting_materials.ts (lines 287-293)
export function materialTierToQuality(tier: bigint): string {
  if (tier === 1n) return 'common';
  if (tier === 2n) return 'uncommon';
  if (tier === 3n) return 'rare';
  return 'common';
}
```

The resulting string is stored in `ItemInstance.qualityTier`. The MATERIAL_AFFIX_MAP uses
`'uncommon' | 'rare' | 'epic'` as inner keys. This creates the coupling to break.

### Current ItemInstance Schema

```typescript
// spacetimedb/src/schema/tables.ts (lines 339-355)
export const ItemInstance = table(
  { name: 'item_instance', public: true,
    indexes: [{ name: 'by_owner', algorithm: 'btree', columns: ['ownerCharacterId'] }] },
  {
    id: t.u64().primaryKey().autoInc(),
    templateId: t.u64(),
    ownerCharacterId: t.u64(),
    equippedSlot: t.string().optional(),
    quantity: t.u64(),
    qualityTier: t.string().optional(),   // 'common'|'uncommon'|'rare'|'epic'|'legendary'
    displayName: t.string().optional(),
    isNamed: t.bool().optional(),
  }
);
```

### Dual-Axis Schema Addition

Add `craftQuality` to `ItemInstance` as a new optional column. This is additive and backward
compatible — all existing items will have `craftQuality: undefined` which the client maps to the
default 'standard'.

```typescript
// Proposed addition to ItemInstance in tables.ts:
craftQuality: t.string().optional(),  // 'dented'|'standard'|'reinforced'|'exquisite'|'mastercraft'
```

The five craft quality levels map to base stat multipliers. `qualityTier` remains as the rarity
axis (Common→Legendary, controls affix budget). The two fields are now independent.

### Current Craft Reducer Pattern (in items.ts)

The `craft_recipe` reducer (lines 980-1030) does:
1. Reads `req1TemplateId` to determine `materialKey`
2. Looks up material in `MATERIAL_DEFS` to get `materialTier`
3. Calls `materialTierToQuality(materialTier)` to get `qualityTier` (currently conflated with rarity)
4. Calls `getCraftedAffixes(materialKey, qualityTier)` to get affixes
5. Inserts `ItemAffix` rows and updates `ItemInstance` with `qualityTier` + `displayName`

After refactor:
- `materialTier` maps to `craftQuality` (Tier 1 → dented, Tier 2 → standard, Tier 3 → reinforced,
  higher tiers for Exquisite/Mastercraft — exact mapping TBD by planner)
- `qualityTier` (rarity) should be set separately: crafted items that are "Common" can still have
  no affixes; adding an Essence material could allow a rarity bump
- `getCraftedAffixes()` key naming must be updated to use the new craft quality scale or a renamed
  mapping

### Current Two-Path Recipe System (the split to unify)

There are currently two separate seeding paths in `ensure_items.ts`:

**Path A — General consumable recipes** (`ensureRecipeTemplates`, lines 1388-1612):
- Uses an `addRecipe()` helper function defined inline
- Recipes have `recipeType: 'consumable'` by default
- Three required ingredients supported (req1, req2, optional req3)

**Path B — Gear recipes** (`ensureGearRecipeTemplates`, lines 1900-1970):
- Uses a different `addGearRecipe()` helper function
- Recipes always use `copperOre` and `roughHide` as placeholders (req1/req2)
- `recipeType` is always 'weapon' | 'armor' | 'accessory'
- `materialType: undefined` (material selection is dynamic at craft time via affix logic)

The split exists because gear recipes have different semantics — the actual material used is the
req1TemplateId's item, not a fixed per-recipe material. The consolidation goal is to have a single
`addRecipe()` helper shared by both paths, with `recipeType` distinguishing behavior.

### Current Material Ensure List Split (the consolidation target)

`Copper Ore` exists in `ensureResourceItemTemplates()` (line 1189 in ensure_items.ts), inserted as
a general resource. The other 9 crafting materials are in `ensureGearMaterialItemTemplates()`. Both
are called from `syncAllContent()` in the correct order (resource items first, then gear materials),
but a comment in `ensureGearMaterialItemTemplates()` at line 1826 explicitly notes "Copper Ore
already exists from ensureResourceItemTemplates — reused."

The consolidation fix is simply to remove `Copper Ore` from `ensureResourceItemTemplates()` (or
note it belongs in `ensureGearMaterialItemTemplates()`) and ensure `ensureGearMaterialItemTemplates`
covers all 10 crafting materials including copper ore. The order in `syncAllContent()` must be
preserved — resource items before gear materials.

### Metadata Consistency (item descriptions)

Currently, `ItemTemplate` has no `description` field. Item descriptions shown in the tooltip
(App.vue lines 505-506) are computed client-side in `useInventory.ts` (lines 144-153):

```typescript
const description =
  foodDescription ||
  ([
    tierLabel,
    qualityTier,
    typeField,
    template?.slot,
  ]
    .filter((value) => value && value.length > 0)
    .join(' • ') ?? '');
```

This computed description is a minimal tier/slot/type string, not a flavor description. The scope
note says "consistently stored with the DB items (not hardcoded client-side)" — the fix is to add
`description: t.string().optional()` to `ItemTemplate` and seed it from backend data constants.
Client then reads `template.description` directly.

IMPORTANT: After adding `description` to `ItemTemplate`, `spacetime generate` must be re-run to
update `src/module_bindings/`.

### Essence Material Pattern

The new Essence material follows the exact same pattern as existing drop-only materials (Rough Hide,
Bone Shard, Spirit Essence, etc.) in `MATERIAL_DEFS`. Key design points:

1. Essence needs a `tier` field — but since essence tier is based on monster level (not material
   tier 1-3), there will likely be multiple Essence types: "Tier 1 Essence", "Tier 2 Essence",
   "Tier 3 Essence" as separate `ItemTemplate` rows.
2. Or: a single "Essence" item template per tier stored with `tier: 1n|2n|3n`, sharing the same
   MATERIAL_DEFS pattern.
3. Essence must be added to `MATERIAL_DEFS` to participate in affix logic.
4. Essence must be added to `ensureGearMaterialItemTemplates()` as a new `upsertMaterial()` call.
5. Essence must be added to `ensureMaterialLootEntries()` — dropped from monsters by tier.
6. Essence must be required in gear recipes (as req3 or as a separate constraint in the reducer).

The current recipe schema supports up to 3 required ingredients (req1, req2, req3). Essence as a
third required ingredient for gear recipes is the natural fit, but requires `ensureGearRecipeTemplates`
to be updated so each gear recipe lists Essence as req3 with a count.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead |
|---------|-------------|-------------|
| Schema migration | Custom migration script | SpacetimeDB additive column addition (optional field = backward compatible) |
| Affix name building | Custom string formatter | Existing `buildDisplayName()` in `helpers/items.ts` |
| Upsert pattern | Custom insert-or-update | Existing `upsertMaterial()` / `findItemTemplateByName()` patterns |
| Client bindings | Hand-editing module_bindings | `spacetime generate` — MUST be run after schema changes |

---

## Common Pitfalls

### Pitfall 1: Schema Change Without Regenerating Bindings
**What goes wrong:** Adding `craftQuality` or `description` to tables in `tables.ts` but not
re-running `spacetime generate`. The client will not see the new fields.
**How to avoid:** After any schema change, run:
```bash
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```
Then republish:
```bash
spacetime publish <db-name> --clear-database -y --project-path spacetimedb
```

### Pitfall 2: Dual-Axis Naming Collision with Existing `qualityTier`
**What goes wrong:** Renaming `qualityTier` to mean rarity while the old code uses it to mean both.
The client code in `useInventory.ts`, `useCombat.ts`, `LootPanel.vue`, etc. references
`qualityTier` everywhere as a rarity concept — this is actually correct post-refactor.
**How to avoid:** Keep `qualityTier` as the rarity field. Add `craftQuality` as a NEW field. Do not
rename existing `qualityTier`.

### Pitfall 3: MATERIAL_AFFIX_MAP Keys Out of Sync with Craft Quality Levels
**What goes wrong:** MATERIAL_AFFIX_MAP uses `'uncommon' | 'rare' | 'epic'` as quality tier keys,
but after the dual-axis refactor these strings no longer mean rarity — they mean craft quality
bands. If the planner renames these to 'dented'/'standard'/'reinforced'/etc., `getCraftedAffixes()`
calls in the reducer must be updated to match.
**How to avoid:** Decide at planning time whether to rename the MATERIAL_AFFIX_MAP inner keys or
introduce a mapping layer. The simplest path is to keep the existing map keys but rename the helper
function parameters and comments to clarify they are craft quality levels, not rarity tiers.

### Pitfall 4: Copper Ore Duplicate Template
**What goes wrong:** After consolidating ensure lists, if Copper Ore appears in both
`ensureResourceItemTemplates` and `ensureGearMaterialItemTemplates`, there will be two templates
with the same name, which breaks the `findItemTemplateByName()` lookups used in seeding and the
reducer.
**How to avoid:** The `ensureGearMaterialItemTemplates` `upsertMaterial` function already guards
with `if (findItemTemplateByName(ctx, args.name)) return;` — so the second insert is a no-op.
However, both templates still need to appear in the same list conceptually. The cleanest fix is to
remove Copper Ore from `ensureResourceItemTemplates` and add it to `ensureGearMaterialItemTemplates`
so all 10 crafting materials are seeded in one place. The `ensureResourceItemTemplates` must run
first in `syncAllContent` anyway (other resources are used by recipe templates).

### Pitfall 5: Recipe Consolidation Breaking Salvage Discovery
**What goes wrong:** The `salvage_item` reducer (lines 1601-1620) finds a recipe by matching
`outputTemplateId`. If recipe consolidation changes recipe keys or output template IDs, salvage
discovery breaks.
**How to avoid:** Only consolidate the helper function that creates recipes — do not change recipe
keys or output template IDs during consolidation.

### Pitfall 6: `recipeTemplate.iter()` Performance
**What goes wrong:** The `research_recipes` reducer (line 888) and `salvage_item` reducer (line
1601) both do `[...ctx.db.recipeTemplate.iter()]` — a full table scan. This is fine for small
tables but if recipe count grows significantly, it could become slow.
**How to avoid:** RecipeTemplate has no index on key/name — `iter()` scan is the only option for
now. Adding Essence as req3 does not materially increase recipe count. This is an acceptable known
limitation.

### Pitfall 7: Essence Drop Rate Must Be Tier-Gated
**What goes wrong:** If Essence drops from all enemies regardless of tier, low-level characters
accumulate high-tier Essence which breaks progression.
**How to avoid:** In `ensureMaterialLootEntries()`, gate Essence drops by the same tier logic used
for other materials (low-tier enemies drop Tier 1 Essence, etc.). The current tier logic uses
`isHighTier` and `isMidTier` booleans derived from terrain type — this pattern must be followed for
Essence.

---

## Code Examples

### Pattern: Adding Optional Column to SpacetimeDB Table

```typescript
// In spacetimedb/src/schema/tables.ts
export const ItemInstance = table(
  { name: 'item_instance', public: true,
    indexes: [{ name: 'by_owner', algorithm: 'btree', columns: ['ownerCharacterId'] }] },
  {
    id: t.u64().primaryKey().autoInc(),
    templateId: t.u64(),
    ownerCharacterId: t.u64(),
    equippedSlot: t.string().optional(),
    quantity: t.u64(),
    qualityTier: t.string().optional(),    // rarity axis: 'common'|'uncommon'|'rare'|'epic'|'legendary'
    craftQuality: t.string().optional(),   // NEW: craft quality axis: 'dented'|'standard'|'reinforced'|'exquisite'|'mastercraft'
    displayName: t.string().optional(),
    isNamed: t.bool().optional(),
  }
);
```

### Pattern: Adding Optional Column to ItemTemplate

```typescript
// In spacetimedb/src/schema/tables.ts
export const ItemTemplate = table(
  { name: 'item_template', public: true },
  {
    id: t.u64().primaryKey().autoInc(),
    name: t.string(),
    slot: t.string(),
    // ... (all existing fields) ...
    description: t.string().optional(),   // NEW: flavor/metadata description seeded from backend
  }
);
```

### Pattern: Unified addRecipe Helper

The two existing helpers (`addRecipe` in `ensureRecipeTemplates` and `addGearRecipe` in
`ensureGearRecipeTemplates`) can be unified into a single function exported from `ensure_items.ts`:

```typescript
// Unified helper — replaces both addRecipe and addGearRecipe
const addRecipeTemplate = (ctx: any, args: {
  key: string;
  name: string;
  output: any;           // ItemTemplate row
  outputCount: bigint;
  req1: any;             // ItemTemplate row
  req1Count: bigint;
  req2: any;             // ItemTemplate row
  req2Count: bigint;
  req3?: any;            // optional third ingredient (e.g., Essence)
  req3Count?: bigint;
  recipeType: string;    // 'consumable' | 'weapon' | 'armor' | 'accessory'
  materialType?: string;
}) => {
  if (!args.output || !args.req1 || !args.req2) return;
  const existing = [...ctx.db.recipeTemplate.iter()].find((row) => row.key === args.key);
  if (existing) {
    ctx.db.recipeTemplate.id.update({ ...existing, /* all fields */ });
    return;
  }
  ctx.db.recipeTemplate.insert({ id: 0n, /* all fields */ });
};
```

### Pattern: Material Upsert With Essence

```typescript
// In ensureGearMaterialItemTemplates() — add Essence tier entries:
upsertMaterial({ name: 'Essence I', tier: 1n, vendorValue: 3n });
upsertMaterial({ name: 'Essence II', tier: 2n, vendorValue: 6n });
upsertMaterial({ name: 'Essence III', tier: 3n, vendorValue: 12n });
```

### Pattern: craft_recipe Reducer After Dual-Axis Refactor

```typescript
// In reducers/items.ts — craft_recipe reducer (conceptual after refactor):
const req1Template = ctx.db.itemTemplate.id.find(recipe.req1TemplateId);
const materialKey = req1Template
  ? req1Template.name.toLowerCase().replace(/\s+/g, '_')
  : '';
const materialDef = MATERIAL_DEFS.find((m) => m.key === materialKey);
const materialTier = materialDef ? materialDef.tier : 1n;

// Craft quality from material tier (base stats axis)
const craftQuality = materialTierToCraftQuality(materialTier);
// e.g., tier 1 → 'standard', tier 2 → 'reinforced', tier 3 → 'exquisite'

// Rarity is now independent — crafted items start as 'common' unless Essence is consumed
// (optional: consuming Essence bumps rarity to 'uncommon'/'rare' etc.)
const qualityTier = 'common';  // base rarity for crafted items; Essence logic can override

// Affixes are determined by craft quality (not rarity)
const craftedAffixes = getCraftedAffixes(materialKey, craftQuality);
```

---

## Open Questions

1. **Craft quality to stat multiplier mapping**
   - What are the exact base stat values for each craft quality level (Dented/Standard/Reinforced/
     Exquisite/Mastercraft)? The user described these as affecting "base physical stats (armor value,
     weapon damage, core bonuses)" but no specific numbers were given.
   - Recommendation: The planner should define a `CRAFT_QUALITY_STAT_MULTIPLIER` table in
     `crafting_materials.ts` mapping quality level → multiplier. Keep it data-driven from the start.

2. **Essence and rarity interaction**
   - Does consuming Essence at craft time grant a rarity bump (e.g., Common → Uncommon), or does
     Essence gate craft quality upgrades (e.g., required for Exquisite tier)?
   - The user said "Essence is required for gear crafting" — this implies Essence is a mandatory
     ingredient, not an optional rarity booster.
   - Recommendation: Treat Essence as a required third ingredient (req3) for gear recipes. Essence
     tier must match or exceed the material tier.

3. **How many Essence variants?**
   - Three distinct ItemTemplates ("Tier 1 Essence", "Tier 2 Essence", "Tier 3 Essence") following
     the existing tier system, or one ItemTemplate with tier field?
   - Recommendation: Three named templates ("Essence I", "Essence II", "Essence III") following the
     naming convention for clarity in the UI. Each is a separate `ItemTemplate` row.

4. **Do existing crafted items need migration?**
   - When `craftQuality` is added as an optional field, existing `ItemInstance` rows will have
     `craftQuality: undefined`. The client must handle this gracefully.
   - Recommendation: In client display code, treat `undefined` craftQuality as 'standard'. No
     backend migration needed since `--clear-database` will be used during development.

5. **MATERIAL_AFFIX_MAP key rename?**
   - The map currently uses `'uncommon' | 'rare' | 'epic'` as inner keys (craft quality bands).
     After the dual-axis refactor these no longer correspond to rarity values.
   - Recommendation: Rename the inner keys to match craft quality levels
     ('dented'/'standard'/'reinforced'/'exquisite'/'mastercraft') and update `getCraftedAffixes()`
     accordingly. Document clearly that these are craft quality levels, not rarity tiers.

6. **Recipe consolidation: should addRecipe be exported or stay inline?**
   - Currently `addRecipe` is defined inside `ensureRecipeTemplates()` as a local closure.
   - Recommendation: Extract to a module-level helper or top of file so it can be shared. Keep it
     in `ensure_items.ts` — no need for a separate file.

---

## Detailed Finding: Current State vs Target State

| Concern | Current State | Target State |
|---------|---------------|--------------|
| Craft quality axis | Does not exist — material tier drives affix magnitude only | New `craftQuality` field on `ItemInstance`: 'dented'\|'standard'\|'reinforced'\|'exquisite'\|'mastercraft' |
| Rarity axis | `qualityTier` on `ItemInstance` doubles as both craft quality and rarity | `qualityTier` remains as pure rarity (Common→Legendary) |
| Item descriptions | Computed client-side as "Tier X • rarity • slot" string | Stored in `ItemTemplate.description` field, seeded from backend constants |
| Material ensure lists | Copper Ore in `ensureResourceItemTemplates`, other 9 materials in `ensureGearMaterialItemTemplates` | All 10 crafting materials (+ new Essence variants) in `ensureGearMaterialItemTemplates` |
| Recipe system | Two separate helpers: `addRecipe` (consumable) and `addGearRecipe` (gear) with different signatures | Single unified `addRecipeTemplate` helper used by both paths |
| Essence material | Does not exist | 3 Essence tiers (I/II/III) as drop-only materials required in gear recipes as req3 |

---

## File Impact Summary

### Backend files that change:
| File | Change |
|------|--------|
| `spacetimedb/src/schema/tables.ts` | Add `craftQuality: t.string().optional()` to `ItemInstance`; add `description: t.string().optional()` to `ItemTemplate` |
| `spacetimedb/src/data/crafting_materials.ts` | Add `materialTierToCraftQuality()` helper; rename MATERIAL_AFFIX_MAP inner keys to craft quality levels; add Essence entries to MATERIAL_DEFS |
| `spacetimedb/src/seeding/ensure_items.ts` | Move Copper Ore to `ensureGearMaterialItemTemplates`; add Essence upserts; add `description` field to all material+gear template seeds; unify `addRecipe` + `addGearRecipe` into one helper; update `ensureGearRecipeTemplates` to add req3=Essence |
| `spacetimedb/src/seeding/ensure_enemies.ts` | Add Essence loot entries to `ensureMaterialLootEntries` |
| `spacetimedb/src/reducers/items.ts` | Update `craft_recipe` to set `craftQuality` separately from `qualityTier`; update affix lookup to use craft quality key |

### Frontend files that change:
| File | Change |
|------|--------|
| `src/module_bindings/` | Regenerate after schema changes |
| `src/composables/useInventory.ts` | Read `craftQuality` from `ItemInstance`, read `description` from `ItemTemplate` |
| `src/composables/useCrafting.ts` | Potentially expose `craftQuality` in recipe output |
| `src/components/InventoryPanel.vue` | Display `craftQuality` in item tooltip/description |
| `src/App.vue` | Tooltip rendering to use `template.description` and `instance.craftQuality` |

---

## Sources

### Primary (HIGH confidence — direct codebase inspection)
- `C:/projects/uwr/spacetimedb/src/data/crafting_materials.ts` — All material definitions, affix map, helper functions
- `C:/projects/uwr/spacetimedb/src/schema/tables.ts` — `ItemTemplate`, `ItemInstance`, `RecipeTemplate` schemas
- `C:/projects/uwr/spacetimedb/src/seeding/ensure_items.ts` — `ensureGearMaterialItemTemplates`, `ensureGearRecipeTemplates`, `ensureRecipeTemplates`
- `C:/projects/uwr/spacetimedb/src/seeding/ensure_enemies.ts` — `ensureMaterialLootEntries` function
- `C:/projects/uwr/spacetimedb/src/seeding/ensure_content.ts` — `syncAllContent` ordering
- `C:/projects/uwr/spacetimedb/src/reducers/items.ts` — `craft_recipe`, `salvage_item`, `learn_recipe_scroll` reducers
- `C:/projects/uwr/src/composables/useInventory.ts` — Client-side description generation (lines 132-153)
- `C:/projects/uwr/src/composables/useCrafting.ts` — Recipe filtering and craft reducer call
- `C:/projects/uwr/src/components/CraftingPanel.vue` — Crafting UI structure
- `C:/projects/uwr/src/App.vue` — Tooltip rendering using `description` field

---

## Metadata

**Confidence breakdown:**
- Schema changes: HIGH — patterns well understood, additive optional fields
- Craft quality axis: HIGH — data model clear, implementation pattern established
- Material consolidation: HIGH — trivial restructuring of existing lists
- Recipe consolidation: HIGH — mechanical helper unification
- Essence material: HIGH — follows exact same pattern as existing drop materials
- Metadata consistency: HIGH — existing `description` pattern on other tables (Npc, Location, Faction, Race) provides exact template

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable domain — no external dependencies)
