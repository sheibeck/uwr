---
phase: 05-llm-architecture
plan: 03
type: execute
wave: 3
depends_on:
  - 05-02
files_modified:
  - src/composables/useLlmContent.ts
  - src/composables/useGameData.ts
  - src/components/GeneratedTextBlock.vue
autonomous: false
requirements:
  - REQ-042
  - REQ-084

must_haves:
  truths:
    - "Client can call conn.procedures.generateContent({ contentType, contentId, contextJson }) and await the result"
    - "GeneratedTextBlock.vue renders pending state with Shadeslinger-tone flavor text per content type"
    - "GeneratedTextBlock.vue renders ready state with the generated text content"
    - "GeneratedTextBlock.vue renders fallback state with fallback text (visually same as ready, but optionally dimmed)"
    - "useLlmContent composable exposes triggerGeneration function and isGenerating ref"
    - "GeneratedQuestText, GeneratedEventText, GeneratedNpcContent tables subscribed in useGameData"
  artifacts:
    - path: "src/composables/useLlmContent.ts"
      provides: "triggerGeneration(contentType, contentId, contextJson), isGenerating ref"
      exports: ["useLlmContent"]
    - path: "src/components/GeneratedTextBlock.vue"
      provides: "Status-gated rendering component with loading flavor text"
      contains: "pending"
    - path: "src/composables/useGameData.ts"
      provides: "generatedQuestTexts, generatedEventTexts, generatedNpcContents subscriptions"
      contains: "generatedQuestText"
  key_links:
    - from: "src/composables/useLlmContent.ts"
      to: "conn.procedures.generateContent"
      via: "useSpacetimeDB() + conn.procedures call"
      pattern: "procedures.generateContent"
    - from: "src/components/GeneratedTextBlock.vue"
      to: "useLlmContent"
      via: "optional composable integration or direct prop passing"
      pattern: "status.*pending|ready|fallback"
    - from: "src/composables/useGameData.ts"
      to: "tables.generatedQuestText"
      via: "useTable(tables.generatedQuestText)"
      pattern: "useTable.*generatedQuestText"
---

<objective>
Implement the client-side integration layer: the `useLlmContent` composable for triggering content generation via procedure, the `GeneratedTextBlock` Vue component with status-gated rendering and Shadeslinger-tone loading flavor text, and subscription wiring in useGameData.

Purpose: Connects the backend LLM pipeline to the Vue UI. Any component that needs to display or trigger generation of quest/event/NPC text will use these two building blocks.
Output: useLlmContent.ts, GeneratedTextBlock.vue, updated useGameData.ts subscriptions.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llm-architecture/05-RESEARCH.md
@.planning/phases/05-llm-architecture/05-02-SUMMARY.md

@src/composables/useGameData.ts
@src/composables/useCombat.ts
@src/components/QuestPanel.vue
@src/module_bindings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLlmContent.ts composable and GeneratedTextBlock.vue component</name>
  <files>
    src/composables/useLlmContent.ts
    src/components/GeneratedTextBlock.vue
  </files>
  <action>
**A: Create `src/composables/useLlmContent.ts`**

```typescript
// src/composables/useLlmContent.ts
// Composable for triggering LLM content generation via SpacetimeDB procedure.
// Pattern: fire-and-forget — procedure writes to content table, subscription auto-updates UI.
// Usage:
//   const { triggerGeneration, isGenerating, lastError } = useLlmContent();
//   await triggerGeneration('quest', questId, JSON.stringify({ questName, enemyName }));

import { ref } from 'vue';
import { useSpacetimeDB } from 'spacetimedb/vue';

export type ContentType = 'quest' | 'event' | 'npc';

export const useLlmContent = () => {
  const conn = useSpacetimeDB();
  const isGenerating = ref(false);
  const lastError = ref<string | null>(null);

  const triggerGeneration = async (
    contentType: ContentType,
    contentId: bigint,
    contextJson: string
  ): Promise<string | null> => {
    if (!conn?.procedures?.generateContent) {
      lastError.value = 'Procedure not available';
      return null;
    }

    isGenerating.value = true;
    lastError.value = null;

    try {
      // Returns: 'ok' | 'fallback' | 'circuit_open' | 'error'
      const result = await conn.procedures.generateContent({
        contentType,
        contentId,
        contextJson,
      });
      return result;
    } catch (err: any) {
      lastError.value = err?.message ?? 'Unknown error';
      return null;
    } finally {
      isGenerating.value = false;
    }
  };

  return { triggerGeneration, isGenerating, lastError };
};
```

**B: Create `src/components/GeneratedTextBlock.vue`**

The component renders a generated content row with status-gated display:
- `pending`: show Shadeslinger-tone flavor text (per REQ-084) while generation runs
- `ready`: show generated text
- `fallback`: show fallback text (same visual as ready — don't stigmatize fallback content)

Loading flavor texts per content type (from research):
- quest pending: "The ink is still wet."
- event pending: "Word is still traveling."
- npc pending: "They're gathering their thoughts."
- generic: "The scribes are working on it..."

```vue
<template>
  <div class="generated-text-block">
    <template v-if="status === 'pending'">
      <span class="generated-pending generated-loading-text">{{ loadingText }}</span>
    </template>
    <template v-else-if="primaryText">
      <p class="generated-text">{{ primaryText }}</p>
      <p v-if="secondaryText" class="generated-text generated-secondary">{{ secondaryText }}</p>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';

// Content type drives the loading flavor text (REQ-084)
type ContentType = 'quest' | 'event' | 'npc' | 'generic';

// Status mirrors the server-side GeneratedQuestText / GeneratedEventText / GeneratedNpcContent status column
type ContentStatus = 'pending' | 'ready' | 'fallback';

interface Props {
  status: ContentStatus;
  contentType?: ContentType;
  // Primary text field: flavorText (quest), announcementText (event), greeting (npc)
  primaryText?: string;
  // Secondary text field: hookText (quest), resolutionText (event), personalityNote (npc)
  secondaryText?: string;
}

const props = withDefaults(defineProps<Props>(), {
  contentType: 'generic',
  primaryText: '',
  secondaryText: '',
});

const LOADING_TEXTS: Record<ContentType, string> = {
  quest: 'The ink is still wet.',
  event: 'Word is still traveling.',
  npc: "They're gathering their thoughts.",
  generic: 'The scribes are working on it...',
};

const loadingText = computed(() => LOADING_TEXTS[props.contentType ?? 'generic']);
</script>

<style scoped>
.generated-text-block {
  margin: 0.25rem 0;
}

.generated-loading-text {
  font-style: italic;
  opacity: 0.6;
  font-size: 0.875em;
}

.generated-text {
  margin: 0.25rem 0;
  line-height: 1.5;
}

.generated-secondary {
  font-size: 0.875em;
  opacity: 0.8;
}
</style>
```
  </action>
  <verify>
Both files exist:
- `src/composables/useLlmContent.ts`
- `src/components/GeneratedTextBlock.vue`

TypeScript compiles: run `npx tsc --noEmit` from the project root (or `npm run build` to confirm Vue compilation).
  </verify>
  <done>useLlmContent.ts exports useLlmContent composable with triggerGeneration (calls conn.procedures.generateContent), isGenerating ref, lastError ref. GeneratedTextBlock.vue renders pending/ready/fallback states with correct loading flavor texts. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Add generated content table subscriptions to useGameData</name>
  <files>src/composables/useGameData.ts</files>
  <action>
Open `src/composables/useGameData.ts` and add subscriptions for the three new generated content tables.

After the existing `useTable` calls, add:

```typescript
const [generatedQuestTexts] = useTable(tables.generatedQuestText);
const [generatedEventTexts] = useTable(tables.generatedEventText);
const [generatedNpcContents] = useTable(tables.generatedNpcContent);
```

Add these three to the return object of the composable (alongside the existing returned values).

Also verify that the subscription builder in `src/main.ts` (or wherever `subscriptionBuilder().subscribe([...])` is called) includes the new tables. If the subscription is using wildcard selects or already subscribes to all public tables, no change needed. If it uses explicit SQL selects, add:
- `'SELECT * FROM generated_quest_text'`
- `'SELECT * FROM generated_event_text'`
- `'SELECT * FROM generated_npc_content'`

Check how other public tables are subscribed — follow the same pattern already used by tables like `world_event`, `quest_template`, etc.

IMPORTANT: Do NOT subscribe to `llm_config` — it is private and not accessible to clients.
  </action>
  <verify>
1. `useGameData.ts` exports `generatedQuestTexts`, `generatedEventTexts`, `generatedNpcContents`.
2. Client connects to SpacetimeDB in dev environment (`npm run dev`) without console errors about unknown tables.
3. In browser console: `window.__db_conn.db.generatedQuestText` exists (or check via Vue devtools).
  </verify>
  <done>useGameData returns generatedQuestTexts, generatedEventTexts, generatedNpcContents arrays. Tables subscribed correctly. Client compiles and connects without subscription errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification of client-side LLM pipeline integration</name>
  <action>Claude has automated all of the above. This checkpoint verifies the implementation works end-to-end before the phase is marked complete.</action>
  <what-built>
- useLlmContent composable (triggerGeneration procedure call, isGenerating/lastError state)
- GeneratedTextBlock.vue (pending/ready/fallback rendering, Shadeslinger loading flavor text)
- useGameData subscriptions for 3 new generated content tables
- Local SpacetimeDB module published with generate_content procedure and new tables
  </what-built>
  <how-to-verify>
1. Run `npm run dev` and open the app. Confirm no console errors on startup.

2. Open browser console. Run:
   ```javascript
   window.__db_conn.procedures.generateContent
   ```
   This should be a function (not undefined). If undefined, bindings were not regenerated after adding the procedure.

3. Test admin config (requires being the admin identity):
   ```javascript
   window.__db_conn.reducers.setLlmConfig({ apiKey: 'test-key-123', defaultModel: 'gpt-5-mini' })
   ```
   Should not throw for admin identity.

4. Test pending row creation (manual test — insert a pending row, then trigger generation):
   The generate_content procedure can be tested by calling it with a fake contentId after manually inserting a pending row via admin commands or spacetime CLI.

5. Verify fallback behavior: call the procedure with circuit_open=true or without a valid API key — the row status should flip to 'fallback' with Shadeslinger-tone text.

6. Vue component test: temporarily render `<GeneratedTextBlock status="pending" contentType="quest" />` in any component and confirm "The ink is still wet." appears in the UI.
  </how-to-verify>
  <verify>Human confirms procedure is callable, component renders correctly, no console errors.</verify>
  <done>Human types "approved" confirming the LLM pipeline integration works end-to-end.</done>
  <resume-signal>Type "approved" if useLlmContent and GeneratedTextBlock work as described. Describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `src/composables/useLlmContent.ts` exports useLlmContent with triggerGeneration, isGenerating, lastError.
2. `src/components/GeneratedTextBlock.vue` renders three states: pending (flavor text), ready (generated text), fallback (same as ready).
3. `src/composables/useGameData.ts` returns generatedQuestTexts, generatedEventTexts, generatedNpcContents.
4. `conn.procedures.generateContent` is a function in browser console (not undefined).
5. No TypeScript or Vue compilation errors.
6. Human verifies the component renders correctly and procedure is reachable.
</verification>

<success_criteria>
- conn.procedures.generateContent is callable from browser console (not undefined)
- GeneratedTextBlock.vue pending state: shows content-type-specific Shadeslinger flavor text
- GeneratedTextBlock.vue ready state: shows generated text
- GeneratedTextBlock.vue fallback state: shows fallback text
- useGameData provides generatedQuestTexts, generatedEventTexts, generatedNpcContents
- useLlmContent provides triggerGeneration async function that awaits procedure result
- No console errors on app startup
- Human verifies UI component renders correctly (checkpoint approved)
</success_criteria>

<output>
After completion, create `.planning/phases/05-llm-architecture/05-03-SUMMARY.md`
</output>
