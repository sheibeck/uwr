---
phase: 05-llm-architecture
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - spacetimedb/src/procedures/llm.ts
  - spacetimedb/src/reducers/llm.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/index.ts
  - src/module_bindings/index.ts
  - src/module_bindings/generate_content_procedure.ts
  - src/module_bindings/set_llm_config_reducer.ts
  - src/module_bindings/reset_llm_circuit_reducer.ts
  - src/module_bindings/generated_quest_text_table.ts
  - src/module_bindings/generated_event_text_table.ts
  - src/module_bindings/generated_npc_content_table.ts
  - src/module_bindings/llm_circuit_table.ts
autonomous: true
requirements:
  - REQ-040
  - REQ-041
  - REQ-042
  - REQ-043
  - REQ-044
  - REQ-045
  - REQ-046
  - REQ-047

must_haves:
  truths:
    - "generate_content procedure is callable from client via conn.procedures.generateContent({...})"
    - "set_llm_config reducer is admin-only and creates/updates LlmConfig singleton"
    - "reset_llm_circuit reducer fires from LlmCircuit scheduled table and resets circuitOpen to false"
    - "Procedure reads LlmConfig in a withTx, closes tx, makes HTTP call, opens new withTx for writes"
    - "Circuit breaker opens after 3 failures within 60 seconds and schedules auto-reset in 5 minutes"
    - "Fallback content is always written on failure — status never left as 'pending'"
    - "Procedure returns string: 'ok' | 'fallback' | 'circuit_open' | 'error'"
    - "Module bindings regenerated and include generate_content procedure and new table types"
  artifacts:
    - path: "spacetimedb/src/procedures/llm.ts"
      provides: "generate_content procedure with OpenAI Responses API call, circuit breaker, fallback writing"
      exports: ["registerProcedures"]
    - path: "spacetimedb/src/reducers/llm.ts"
      provides: "set_llm_config reducer, reset_llm_circuit scheduled reducer"
      exports: ["registerLlmReducers"]
    - path: "spacetimedb/src/reducers/index.ts"
      provides: "registerLlmReducers call included"
      contains: "registerLlmReducers"
    - path: "spacetimedb/src/index.ts"
      provides: "procedures/llm.ts imported for registration"
      contains: "procedures/llm"
    - path: "src/module_bindings/index.ts"
      provides: "generated generate_content procedure binding"
      contains: "generateContent"
  key_links:
    - from: "spacetimedb/src/procedures/llm.ts"
      to: "https://api.openai.com/v1/responses"
      via: "ctx.http.fetch POST with Bearer auth"
      pattern: "ctx.http.fetch.*openai"
    - from: "spacetimedb/src/procedures/llm.ts"
      to: "tx.db.llmConfig.singletonKey.find(0n)"
      via: "withTx for config read before HTTP"
      pattern: "withTx.*llmConfig"
    - from: "spacetimedb/src/procedures/llm.ts"
      to: "tx.db.generatedQuestText / generatedEventText / generatedNpcContent"
      via: "withTx for writing success or fallback"
      pattern: "withTx.*generated"
    - from: "spacetimedb/src/reducers/llm.ts"
      to: "ctx.db.llmConfig.singletonKey"
      via: "set_llm_config reducer upsert, reset_llm_circuit reducer update"
      pattern: "llmConfig.singletonKey"
---

<objective>
Implement the backend behavior layer: the `generate_content` procedure with OpenAI Responses API integration and circuit breaker, the `set_llm_config` admin reducer, the `reset_llm_circuit` scheduled reducer. Publish to local SpacetimeDB and regenerate client bindings.

Purpose: This is the core of the LLM pipeline — the procedure that makes HTTP calls, validates JSON, writes content rows, and manages circuit state.
Output: procedures/llm.ts, reducers/llm.ts, wired into index.ts, local publish, regenerated module_bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llm-architecture/05-RESEARCH.md
@.planning/phases/05-llm-architecture/05-01-SUMMARY.md

@spacetimedb/src/index.ts
@spacetimedb/src/reducers/index.ts
@spacetimedb/src/data/admin.ts
@spacetimedb/src/schema/tables.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create procedures/llm.ts (generate_content procedure)</name>
  <files>spacetimedb/src/procedures/llm.ts</files>
  <action>
Create the directory `spacetimedb/src/procedures/` and the file `spacetimedb/src/procedures/llm.ts`.

The procedure implements the OpenAI Responses API call with circuit breaker, JSON validation, and fallback writing. Follow the verified patterns from 05-RESEARCH.md exactly.

```typescript
// spacetimedb/src/procedures/llm.ts
// generate_content procedure: calls OpenAI Responses API, writes to content tables.
// Pattern: read config in withTx → close → HTTP → new withTx for writes
// CRITICAL: ctx.db does NOT exist in procedures. Always ctx.withTx(tx => tx.db...)
// CRITICAL: Cannot hold transaction during ctx.http.fetch (SDK limitation)

import { t } from 'spacetimedb/server';
import { ScheduleAt, TimeDuration } from 'spacetimedb';
import { spacetimedb } from '../schema/tables';
import {
  SHADESLINGER_SYSTEM_PROMPT,
  buildUserPrompt,
  getSchemaForType,
  isValidResponse,
  ContentType,
} from '../data/llm_prompts';
import { FALLBACK_CONTENT } from '../data/llm_fallbacks';

// Circuit breaker thresholds (per REQ-044)
const CIRCUIT_FAILURE_THRESHOLD = 3;
const CIRCUIT_WINDOW_MICROS = 60_000_000n;   // 60 seconds
const CIRCUIT_RESET_MICROS = 300_000_000n;   // 5 minutes (auto-reset via LlmCircuit scheduled table)

function pickFallback(contentType: ContentType): typeof FALLBACK_CONTENT['quest'][0] | typeof FALLBACK_CONTENT['event'][0] | typeof FALLBACK_CONTENT['npc'][0] {
  const options = FALLBACK_CONTENT[contentType] as readonly any[];
  // Use modular selection (no Math.random — reducers/procedures must be deterministic for circuit reset,
  // but fallback selection variance is acceptable here; use fixed rotation if determinism required)
  return options[0]!; // Always use first fallback for determinism (per research: no random in server-side code)
}

function writeFallbackContent(ctx: any, contentType: ContentType, contentId: bigint): void {
  const fallback = pickFallback(contentType);
  const now = ctx.timestamp;

  ctx.withTx((tx: any) => {
    if (contentType === 'quest') {
      const f = fallback as typeof FALLBACK_CONTENT['quest'][0];
      tx.db.generatedQuestText.id.update({
        id: contentId,
        status: 'fallback',
        flavorText: f.flavorText,
        hookText: f.hookText,
        generatedAt: now,
        questTemplateId: 0n, // will be overwritten by update spread pattern below
      });
      // Use find + update spread to preserve questTemplateId
      const existing = tx.db.generatedQuestText.id.find(contentId);
      if (existing) {
        tx.db.generatedQuestText.id.update({
          ...existing,
          status: 'fallback',
          flavorText: f.flavorText,
          hookText: f.hookText,
          generatedAt: now,
        });
      }
    } else if (contentType === 'event') {
      const f = fallback as typeof FALLBACK_CONTENT['event'][0];
      const existing = tx.db.generatedEventText.id.find(contentId);
      if (existing) {
        tx.db.generatedEventText.id.update({
          ...existing,
          status: 'fallback',
          announcementText: f.announcementText,
          resolutionText: f.resolutionText,
          generatedAt: now,
        });
      }
    } else {
      const f = fallback as typeof FALLBACK_CONTENT['npc'][0];
      const existing = tx.db.generatedNpcContent.id.find(contentId);
      if (existing) {
        tx.db.generatedNpcContent.id.update({
          ...existing,
          status: 'fallback',
          greeting: f.greeting,
          personalityNote: f.personalityNote,
          generatedAt: now,
        });
      }
    }
  });
}

function writeSuccessContent(ctx: any, contentType: ContentType, contentId: bigint, parsed: any): void {
  const now = ctx.timestamp;
  ctx.withTx((tx: any) => {
    if (contentType === 'quest') {
      const existing = tx.db.generatedQuestText.id.find(contentId);
      if (existing) {
        tx.db.generatedQuestText.id.update({
          ...existing,
          status: 'ready',
          flavorText: parsed.flavorText,
          hookText: parsed.hookText,
          generatedAt: now,
        });
      }
    } else if (contentType === 'event') {
      const existing = tx.db.generatedEventText.id.find(contentId);
      if (existing) {
        tx.db.generatedEventText.id.update({
          ...existing,
          status: 'ready',
          announcementText: parsed.announcementText,
          resolutionText: parsed.resolutionText,
          generatedAt: now,
        });
      }
    } else {
      const existing = tx.db.generatedNpcContent.id.find(contentId);
      if (existing) {
        tx.db.generatedNpcContent.id.update({
          ...existing,
          status: 'ready',
          greeting: parsed.greeting,
          personalityNote: parsed.personalityNote,
          generatedAt: now,
        });
      }
    }
  });
}

function recordFailureAndMaybeOpenCircuit(ctx: any, config: any): void {
  const now = ctx.timestamp.microsSinceUnixEpoch;
  const windowStart = now - CIRCUIT_WINDOW_MICROS;

  // Reset count if last failure was outside the rolling window
  const newCount = config.lastFailureAtMicros >= windowStart
    ? config.failureCount + 1
    : 1;

  if (newCount >= CIRCUIT_FAILURE_THRESHOLD) {
    ctx.withTx((tx: any) => {
      tx.db.llmConfig.singletonKey.update({
        ...config,
        circuitOpen: true,
        failureCount: newCount,
        lastFailureAtMicros: now,
        openedAtMicros: now,
      });
      // Schedule auto-reset via LlmCircuit scheduled table
      tx.db.llmCircuit.insert({
        scheduledId: 0n,
        scheduledAt: ScheduleAt.time(now + CIRCUIT_RESET_MICROS),
      });
    });
  } else {
    ctx.withTx((tx: any) => {
      tx.db.llmConfig.singletonKey.update({
        ...config,
        failureCount: newCount,
        lastFailureAtMicros: now,
      });
    });
  }
}

spacetimedb.procedure(
  'generate_content',
  {
    contentType: t.string(),   // 'quest' | 'event' | 'npc'
    contentId: t.u64(),        // PK of the pending row to update
    contextJson: t.string(),   // game context as JSON string (sanitized by client)
  },
  t.string(),                  // returns: 'ok' | 'fallback' | 'circuit_open' | 'error'
  (ctx: any, { contentType, contentId, contextJson }: { contentType: string; contentId: bigint; contextJson: string }) => {
    const validTypes: ContentType[] = ['quest', 'event', 'npc'];
    if (!validTypes.includes(contentType as ContentType)) {
      return 'error';
    }
    const type = contentType as ContentType;

    // Step 1: Read config inside withTx, then close transaction before HTTP
    const config = ctx.withTx((tx: any) => {
      return tx.db.llmConfig.singletonKey.find(0n) ?? null;
    });

    if (!config || !config.apiKey) {
      writeFallbackContent(ctx, type, contentId);
      return 'error';
    }

    // Step 2: Check circuit breaker
    if (config.circuitOpen) {
      writeFallbackContent(ctx, type, contentId);
      return 'circuit_open';
    }

    // Step 3: HTTP call OUTSIDE withTx (cannot hold transaction during HTTP)
    // OpenAI Responses API format (per REQ-041, research verified):
    // - instructions: system prompt at request root (NOT in input array)
    // - input: user message array
    // - text.format: structured JSON output schema
    // - Authorization: Bearer header (NOT x-api-key — that was Anthropic)
    // - response.output_text: convenience accessor for generated text
    const requestBody = JSON.stringify({
      model: config.defaultModel,   // 'gpt-5-mini' per user decision (REQ-047)
      instructions: SHADESLINGER_SYSTEM_PROMPT,
      input: [
        { role: 'user', content: buildUserPrompt(type, contextJson) },
      ],
      text: {
        format: {
          type: 'json_schema',
          name: 'content_response',
          strict: true,
          schema: getSchemaForType(type),
        },
      },
      max_output_tokens: 512,
    });

    try {
      const response = ctx.http.fetch('https://api.openai.com/v1/responses', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.apiKey}`,  // OpenAI uses Bearer, NOT x-api-key
          'Content-Type': 'application/json',
        },
        body: requestBody,
        timeout: TimeDuration.fromMillis(30_000),
      });

      if (!response.ok) {
        recordFailureAndMaybeOpenCircuit(ctx, config);
        writeFallbackContent(ctx, type, contentId);
        return 'fallback';
      }

      // Step 4: Parse and validate JSON
      // response.output_text is the convenience accessor (OpenAI Responses API pattern)
      // Do NOT use response.content[0].text — that is the Anthropic response shape
      const responseBody = response.json();
      const outputText: string = responseBody.output_text;

      let parsed: any;
      try {
        parsed = JSON.parse(outputText);
      } catch {
        recordFailureAndMaybeOpenCircuit(ctx, config);
        writeFallbackContent(ctx, type, contentId);
        return 'fallback';
      }

      if (!isValidResponse(type, parsed)) {
        recordFailureAndMaybeOpenCircuit(ctx, config);
        writeFallbackContent(ctx, type, contentId);
        return 'fallback';
      }

      // Step 5: Write success in new withTx
      writeSuccessContent(ctx, type, contentId, parsed);

      // Reset failure count on success (optional: only if it was non-zero)
      if (config.failureCount > 0) {
        ctx.withTx((tx: any) => {
          const refreshed = tx.db.llmConfig.singletonKey.find(0n);
          if (refreshed) {
            tx.db.llmConfig.singletonKey.update({
              ...refreshed,
              failureCount: 0,
            });
          }
        });
      }

      return 'ok';

    } catch (_e: any) {
      recordFailureAndMaybeOpenCircuit(ctx, config);
      writeFallbackContent(ctx, type, contentId);
      return 'fallback';
    }
  }
);

export const registerProcedures = (_deps: any) => {
  // Procedures are registered by importing this file (spacetimedb.procedure() called at module level above)
  // This export is a no-op marker for index.ts to import
};
```

CRITICAL REMINDERS from research:
- `ctx.db` does NOT exist in procedures — always `ctx.withTx(tx => tx.db...)`
- Never call `ctx.http.fetch` while a `withTx` is open
- OpenAI auth header is `Authorization: Bearer` NOT `x-api-key`
- OpenAI response text accessed via `responseBody.output_text` NOT `content[0].text`
- System prompt goes in `instructions` field, NOT inside the `input` array
  </action>
  <verify>File exists at `spacetimedb/src/procedures/llm.ts`. TypeScript compiles without errors (`npx tsc --noEmit` in spacetimedb directory).</verify>
  <done>procedures/llm.ts defines generate_content procedure with correct OpenAI Responses API format. All ctx.db accesses use ctx.withTx. No transaction held during HTTP call. Circuit breaker logic present. Fallback always written on failure. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Create reducers/llm.ts and wire everything into index.ts, then publish and regenerate bindings</name>
  <files>
    spacetimedb/src/reducers/llm.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**Step A: Create `spacetimedb/src/reducers/llm.ts`**

```typescript
// spacetimedb/src/reducers/llm.ts
// set_llm_config: admin-only, creates/updates LlmConfig singleton (REQ-040)
// reset_llm_circuit: scheduled reducer fired by LlmCircuit table (REQ-044)

import { t, SenderError } from 'spacetimedb/server';
import { requireAdmin } from '../data/admin';

export const registerLlmReducers = ({ spacetimedb, LlmCircuit }: any) => {
  spacetimedb.reducer(
    'set_llm_config',
    {
      apiKey: t.string(),
      defaultModel: t.string(),  // typically 'gpt-5-mini' per user decision
    },
    (ctx: any, { apiKey, defaultModel }: { apiKey: string; defaultModel: string }) => {
      requireAdmin(ctx);
      const model = defaultModel || 'gpt-5-mini';
      const existing = ctx.db.llmConfig.singletonKey.find(0n);
      if (existing) {
        ctx.db.llmConfig.singletonKey.update({
          ...existing,
          apiKey,
          defaultModel: model,
        });
      } else {
        ctx.db.llmConfig.insert({
          singletonKey: 0n,
          apiKey,
          defaultModel: model,
          circuitOpen: false,
          failureCount: 0,
          lastFailureAtMicros: 0n,
          openedAtMicros: 0n,
        });
      }
    }
  );

  spacetimedb.reducer(
    'reset_llm_circuit',
    { arg: LlmCircuit.rowType },
    (ctx: any) => {
      // Scheduled reducer: fires from LlmCircuit table after CIRCUIT_RESET_MICROS
      // LlmCircuit row is auto-deleted after this reducer completes
      const config = ctx.db.llmConfig.singletonKey.find(0n);
      if (!config) return;
      ctx.db.llmConfig.singletonKey.update({
        ...config,
        circuitOpen: false,
        failureCount: 0,
        openedAtMicros: 0n,
      });
    }
  );
};
```

Note: `failureCount: 0` uses a number literal (not bigint) because the column is u32. If the TypeScript type infers differently based on actual t.u32() / t.u64() type check results from Task 1, use the appropriate literal (0 for u32, 0n for u64).

**Step B: Update `spacetimedb/src/reducers/index.ts`**

Add `import { registerLlmReducers } from './llm';` at the top with the other imports.

Add `registerLlmReducers(deps);` to the `registerReducers` function body.

Pass `LlmCircuit` in the deps object. The `LlmCircuit` table type is exported from `schema/tables.ts` — check what is already passed to `registerReducers` to understand how to thread it through. Looking at the existing pattern, `reducerDeps` in `index.ts` contains table types. Add `LlmCircuit` there.

**Step C: Update `spacetimedb/src/index.ts`**

1. Import `LlmCircuit` from `./schema/tables` (add to existing import list from that file)
2. Import `registerProcedures` from `./procedures/llm` (add new import): `import { registerProcedures } from './procedures/llm';`
3. Add `LlmCircuit` to the `reducerDeps` object passed to `registerReducers`
4. Add `registerProcedures(reducerDeps);` call after `registerReducers(reducerDeps);`

The import of `./procedures/llm` causes the `spacetimedb.procedure(...)` calls at module level to execute, registering the procedure with the spacetimedb instance.

**Step D: Publish to local SpacetimeDB**

IMPORTANT per MEMORY.md: Only publish to local automatically. NEVER publish to maincloud automatically.

```bash
spacetime publish uwr --project-path C:/projects/uwr/spacetimedb
```

If publish fails due to TypeScript errors, fix the errors first. Review logs with:
```bash
spacetime logs uwr
```

**Step E: Regenerate client bindings**

```bash
spacetime generate --lang typescript --out-dir C:/projects/uwr/src/module_bindings --project-path C:/projects/uwr/spacetimedb
```

This will update `src/module_bindings/index.ts` and create new files for the procedure and new tables. Do NOT manually edit the generated files.

After regeneration, verify `src/module_bindings/index.ts` contains the generate_content procedure binding (look for `generateContent` in the procedure imports section around line 260-261 where it was empty before).
  </action>
  <verify>
1. `spacetime publish uwr --project-path C:/projects/uwr/spacetimedb` exits successfully.
2. `spacetime logs uwr` shows no errors.
3. `src/module_bindings/index.ts` contains generate_content procedure binding (search for `generateContent` or `generate_content`).
4. New files exist in `src/module_bindings/`: generated_quest_text_table.ts, generated_event_text_table.ts, generated_npc_content_table.ts.
  </verify>
  <done>reducers/llm.ts created. registerLlmReducers called in reducers/index.ts. procedures/llm.ts imported in index.ts. Local publish succeeds. Bindings regenerated with generate_content procedure and new table types visible in module_bindings/index.ts.</done>
</task>

</tasks>

<verification>
1. `spacetime publish uwr --project-path C:/projects/uwr/spacetimedb` completes without errors.
2. `spacetime logs uwr` shows no panic or TypeScript compilation errors.
3. `src/module_bindings/index.ts` procedure section (was empty at line 260-261) now contains `generateContent` binding.
4. `src/module_bindings/generated_quest_text_table.ts`, `generated_event_text_table.ts`, `generated_npc_content_table.ts` exist.
5. set_llm_config reducer requires admin identity (throws if non-admin calls it).
6. reset_llm_circuit scheduled reducer exists and accepts LlmCircuit.rowType arg.
</verification>

<success_criteria>
- procedures/llm.ts: generate_content procedure defined, uses ctx.withTx for all DB access, makes OpenAI Responses API call with correct format (Bearer auth, instructions field, text.format for JSON schema, output_text for response), circuit breaker logic, fallback on any failure
- reducers/llm.ts: set_llm_config (admin-only via requireAdmin), reset_llm_circuit (scheduled reducer)
- reducers/index.ts: registerLlmReducers called
- index.ts: procedures/llm imported and registerProcedures called
- Local SpacetimeDB publish succeeds
- Module bindings regenerated: generate_content procedure callable via conn.procedures.generateContent({...})
- New table types in module_bindings: GeneratedQuestText, GeneratedEventText, GeneratedNpcContent, LlmCircuit
</success_criteria>

<output>
After completion, create `.planning/phases/05-llm-architecture/05-02-SUMMARY.md`
</output>
