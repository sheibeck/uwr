---
phase: 12-overall-renown-system
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/characters.ts
  - spacetimedb/src/schema/tables.ts
autonomous: true

must_haves:
  truths:
    - "New characters are initialized with a Renown row at 0 points, rank 1"
    - "Combat victory against enemies awards renown to all living participants via server-first tracking"
    - "EnemyTemplate has an isBoss field distinguishing boss enemies from regular enemies"
    - "Boss kills award large renown (BOSS_KILL_BASE) with server-first diminishing returns"
    - "Regular enemy kills award small renown based on enemy level"
    - "Perk passive stat bonuses are applied in combat damage and healing calculations"
    - "Module publishes successfully and client bindings are regenerated"
  artifacts:
    - path: "spacetimedb/src/reducers/characters.ts"
      provides: "Renown row initialization at character creation"
      contains: "renown"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Renown award on combat victory, perk bonus application"
      contains: "awardRenown"
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "isBoss optional field on EnemyTemplate"
      contains: "isBoss"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/renown.ts"
      via: "imports awardRenown, awardServerFirst, calculatePerkBonuses"
      pattern: "import.*awardRenown.*from.*helpers/renown"
    - from: "spacetimedb/src/reducers/characters.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "ctx.db.renown.insert at character creation"
      pattern: "ctx\\.db\\.renown\\.insert"
---

<objective>
Integrate the renown system into existing game systems: character creation (Renown row initialization), combat victory (renown awards with server-first tracking for boss kills), and combat stat calculations (perk passive bonuses). Then publish the module and regenerate client bindings.

Purpose: Connects the renown backend from Plan 01 to live game events so players earn renown through gameplay. Boss kills are the primary prestige renown source with diminishing returns. Perk stat bonuses become active in combat.

Output: Character creation initializes Renown rows. Combat victory awards renown (scaled for bosses). Perk bonuses apply to combat stats. Published module with regenerated bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-overall-renown-system-character-wide-renown-separate-from-factions-renown-ranks-with-unlockable-perks-renown-gain-sources-from-events-bosses-achievements/12-01-SUMMARY.md
@spacetimedb/src/reducers/characters.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/helpers/renown.ts
@spacetimedb/src/data/renown_data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isBoss field to EnemyTemplate and integrate renown into character creation and combat</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/reducers/characters.ts
    spacetimedb/src/reducers/combat.ts
  </files>
  <action>
**In `spacetimedb/src/schema/tables.ts`:**

Add `isBoss: t.bool().optional()` as the last field on the EnemyTemplate table definition (after `factionId`). This is optional so existing enemies won't require migration — they'll default to undefined (not a boss).

**In `spacetimedb/src/reducers/characters.ts`:**

In the character creation flow (find where FactionStanding rows are initialized — around the `factionStanding.insert` calls), add Renown row initialization immediately after:

```typescript
ctx.db.renown.insert({
  id: 0n,
  characterId: newCharacter.id,  // Use the actual variable name for the newly created character
  points: 0n,
  currentRank: 1n,
  updatedAt: ctx.timestamp,
});
```

Pattern: Follow the same approach as FactionStanding initialization (eager creation at character creation time).

Also in the character deletion flow (find where FactionStanding rows are cleaned up), add cleanup for Renown, RenownPerk, and Achievement rows:

```typescript
// Clean up renown data
for (const row of ctx.db.renown.by_character.filter(characterId)) {
  ctx.db.renown.id.delete(row.id);
}
for (const row of ctx.db.renownPerk.by_character.filter(characterId)) {
  ctx.db.renownPerk.id.delete(row.id);
}
for (const row of ctx.db.achievement.by_character.filter(characterId)) {
  ctx.db.achievement.id.delete(row.id);
}
```

**In `spacetimedb/src/reducers/combat.ts`:**

Add renown imports at the top:
```typescript
import { awardRenown, awardServerFirst } from '../helpers/renown';
import { RENOWN_GAIN } from '../data/renown_data';
```

**Integration point 1: Renown on combat victory.**

Find the combat victory section where XP is awarded to living participants (around the `awardCombatXp` calls for participants where `p.status !== 'dead'`). After XP award but before clearing combat artifacts, add renown awards:

For each living participant:
```typescript
// Award renown based on enemy type
const combatEnemies = [...ctx.db.combatEnemy.by_combat.filter(combat.id)];
const primaryEnemy = combatEnemies[0];
if (primaryEnemy) {
  const template = ctx.db.enemyTemplate.id.find(primaryEnemy.enemyTemplateId);
  if (template) {
    if (template.isBoss) {
      // Boss kill: server-first tracking with diminishing returns
      const bossKey = `boss_${template.name.toLowerCase().replace(/\\s+/g, '_')}`;
      const serverFirstRenown = awardServerFirst(ctx, character, 'boss_kill', bossKey, RENOWN_GAIN.BOSS_KILL_BASE);
      awardRenown(ctx, character, serverFirstRenown, `Defeating ${template.name}`);
    } else {
      // Regular enemy: small renown based on enemy level (1 renown per level, minimum 1)
      const renownAmount = template.level > 0n ? template.level : 1n;
      awardRenown(ctx, character, renownAmount, `Victory in combat`);
    }
  }
}
```

IMPORTANT: This renown award block should be placed INSIDE the existing per-participant loop where `p.status !== 'dead'` and after the XP award. Do NOT create a separate loop. Check variable names carefully — the character variable and combat variable must match what's already in scope.

**Integration point 2: Perk stat bonuses in combat.**

Import `calculatePerkBonuses` from helpers/renown.ts.

Find where auto-attack damage is calculated for player characters (the `calculateStatScaledAutoAttack` call). Before or alongside equipment stat lookups, calculate perk bonuses and add them to the character's effective stats.

This integration should be lightweight — add the perk bonus to the character's STR/INT/etc values before they're used in damage calculations. The simplest approach:

Find where the character row is read for combat calculations (e.g., `const character = ctx.db.character.id.find(...)` in the auto-attack or ability execution sections). After reading the character, calculate perk bonuses:

```typescript
const perkBonuses = calculatePerkBonuses(ctx, character.id);
// Use perkBonuses.str, perkBonuses.maxHp etc. to augment effective stats
```

If this integration is too deeply embedded in existing combat code, create a simpler approach: add a `getEffectiveStats` wrapper that sums character base stats + perk bonuses, and use it in one representative place (auto-attack damage calculation). The full integration across all combat paths can be expanded later.

The key is to wire at least one visible stat application path so perks have a measurable effect, without refactoring the entire combat system.
  </action>
  <verify>
    Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` to verify no type errors.
  </verify>
  <done>
    EnemyTemplate has isBoss field. Character creation initializes Renown row. Character deletion cleans up Renown/RenownPerk/Achievement rows. Combat victory awards renown (small for regular enemies, server-first tracked for bosses). Perk stat bonuses are applied in at least one combat calculation path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Publish module and regenerate client bindings</name>
  <files>
    src/module_bindings/
  </files>
  <action>
Publish the SpacetimeDB module and regenerate client bindings:

1. **Check the default server** — run `spacetime server list` and use whichever server is marked as default (***).

2. **Publish with --clear-database** since new tables are added:
   ```bash
   spacetime publish uwr --clear-database -y --project-path spacetimedb
   ```
   If the database name differs, check the most recent publish command in git log or STATE.md for the correct name.

3. **Regenerate client bindings:**
   ```bash
   spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
   ```

4. **Verify the generated bindings include the new tables** by checking that `renown`, `renownPerk`, `renownServerFirst`, and `achievement` appear in the generated files.

5. **Verify TypeScript compilation** of the client:
   ```bash
   npx tsc --noEmit
   ```
   Fix any import issues if the generated bindings have different names than expected.
  </action>
  <verify>
    Run `spacetime logs uwr` (or the correct db name) to verify module is running. Run `npx tsc --noEmit` in the client project root to verify client compiles. Check that `ls src/module_bindings/` includes renown-related generated files.
  </verify>
  <done>
    Module published with new Renown tables. Client bindings regenerated and include Renown, RenownPerk, RenownServerFirst, Achievement table types. Client compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- Module compiles and publishes without errors
- Client bindings regenerated with all new table types
- Character creation produces a Renown row (verified via spacetime logs or SQL)
- Combat victory produces renown award log messages
- No regressions in existing combat functionality
</verification>

<success_criteria>
Renown system is live in the running module. Characters start with Renown rows, combat awards renown, boss kills use server-first tracking, and perk bonuses apply in combat. Client bindings are ready for UI work in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/12-overall-renown-system-character-wide-renown-separate-from-factions-renown-ranks-with-unlockable-perks-renown-gain-sources-from-events-bosses-achievements/12-02-SUMMARY.md`
</output>
