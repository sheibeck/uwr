---
phase: 14-loot-gear-progression
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/items.ts
  - spacetimedb/src/data/affix_catalog.ts
autonomous: true

must_haves:
  truths:
    - "Named/boss enemy kills drop their assigned Legendary item as CombatLoot with isNamed=true"
    - "Legendary drops have fixed affixes from LEGENDARIES catalog, not random rolls"
    - "Legendary drops go to first eligible participant only (not duplicated across group)"
    - "Salvaging gear destroys the item and grants crafting materials scaled by tier+quality"
    - "Salvaging deletes both ItemInstance and associated ItemAffix rows"
  artifacts:
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Named legendary drop path in combat end"
      contains: "isNamed"
    - path: "spacetimedb/src/reducers/items.ts"
      provides: "salvage_item reducer"
      contains: "salvage_item"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/data/affix_catalog.ts"
      via: "LEGENDARIES lookup by enemy template name"
      pattern: "LEGENDARIES"
    - from: "spacetimedb/src/reducers/items.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "ItemAffix deletion on salvage"
      pattern: "itemAffix\\.by_instance\\.filter"
---

<objective>
Add named legendary drops from boss enemies and the salvage reducer for gear recycling.

Purpose: Legendaries are the aspirational endgame — named uniques with fixed affixes that drop from specific bosses. Salvage provides a use for obsolete gear. Together they complete the gear lifecycle: drop -> equip -> outgrow -> salvage.
Output: Legendary drop path in combat, salvage_item reducer.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-02-SUMMARY.md
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/reducers/items.ts
@spacetimedb/src/data/affix_catalog.ts
@spacetimedb/src/seeding/ensure_enemies.ts
@spacetimedb/src/seeding/ensure_items.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add named legendary drop path in combat end</name>
  <files>spacetimedb/src/reducers/combat.ts, spacetimedb/src/data/affix_catalog.ts</files>
  <action>
In the combat end logic (the section in `combat.ts` where enemies die and loot is generated), add a separate legendary drop check AFTER the regular loot generation:

1. Import `LEGENDARIES` from '../data/affix_catalog'.
2. When an enemy is killed, check if the enemy template name matches any legendary's `enemyTemplateName`. Also check if the killed enemy is from the `NamedEnemy` table (not a regular spawn) — read the `NamedEnemy` rows for this combat to determine if the kill was a boss kill.
3. If a legendary match is found:
   - Find the base ItemTemplate by the legendary's `baseTemplateName` (iterate itemTemplate to find by name).
   - If found, create ONE CombatLoot row for the FIRST participant only (not all group members — per research pitfall #5):
     ```typescript
     const firstParticipant = activeParticipants[0] ?? participants[0];
     const legendaryAffixJson = JSON.stringify(legendary.affixes);
     ctx.db.combatLoot.insert({
       id: 0n,
       combatId,
       ownerUserId: firstParticipant.ownerUserId,
       characterId: firstParticipant.characterId,
       itemTemplateId: baseTemplate.id,
       createdAt: ctx.timestamp,
       qualityTier: 'legendary',
       affixDataJson: legendaryAffixJson,
       isNamed: true,
     });
     ```
   - Log a special group/location event: `"${legendary.name} has dropped!"` in gold/orange color.

4. The legendary check should use the enemy template's `name` field for matching (not ID, since IDs can change across redeploys).

5. In `affix_catalog.ts`, verify the `enemyTemplateName` values map to actual enemy template names. Read `ensure_enemies.ts` to find existing boss-type enemy names. The LEGENDARIES array may need updating if placeholder names were used in Plan 01. If real boss names are found, update them. If no boss enemies exist yet at appropriate levels, create the legendary entries with the best available high-level enemy names and note this in the summary.

6. The `take_loot` reducer from Plan 02 already handles `isNamed: true` — it creates ItemAffix rows from the affixDataJson and sets isNamed on the ItemInstance. No changes needed there for legendaries specifically.

NOTE: Legendary items are NOT part of the regular RNG tier pool per user decision. They ONLY drop from their assigned named enemy. The regular quality roll in generateLootTemplates should never produce 'legendary' — it caps at 'epic'.
  </action>
  <verify>
`npx tsc --noEmit --project spacetimedb/tsconfig.json` passes. Verify the legendary drop path is separate from regular loot generation. Verify only one CombatLoot row is created per legendary drop (not per participant). Verify rollQualityTier never returns 'legendary'.
  </verify>
  <done>
Named enemy kills check LEGENDARIES catalog by enemy template name. Matching legendaries create a single CombatLoot row (isNamed=true, qualityTier='legendary') for the first participant only. Special log message announces the drop. Regular quality rolls cap at 'epic', never 'legendary'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add salvage_item reducer for gear recycling</name>
  <files>spacetimedb/src/reducers/items.ts</files>
  <action>
Add a new `salvage_item` reducer in items.ts:

```typescript
spacetimedb.reducer('salvage_item', { characterId: t.u64(), itemInstanceId: t.u64() }, (ctx, args) => {
  const character = requireCharacterOwnedBy(ctx, args.characterId);
  const instance = ctx.db.itemInstance.id.find(args.itemInstanceId);
  if (!instance) return failItem(ctx, character, 'Item not found');
  if (instance.ownerCharacterId !== character.id) return failItem(ctx, character, 'Not your item');
  if (instance.equippedSlot) return failItem(ctx, character, 'Unequip item first');

  const template = ctx.db.itemTemplate.id.find(instance.templateId);
  if (!template) return failItem(ctx, character, 'Item template not found');

  // Only gear can be salvaged (equipment slots only)
  if (template.isJunk) return failItem(ctx, character, 'Cannot salvage junk items');
  const nonSalvageSlots = ['consumable', 'food', 'resource', 'quest'];
  if (nonSalvageSlots.includes(template.slot)) {
    return failItem(ctx, character, 'Cannot salvage this item type');
  }

  // Determine salvage yield based on tier and quality
  const tier = Number(template.tier ?? 1n);
  const quality = instance.qualityTier ?? 'common';
  const baseYield = getSalvageYield(tier, quality);

  // Delete associated ItemAffix rows first
  for (const affix of ctx.db.itemAffix.by_instance.filter(instance.id)) {
    ctx.db.itemAffix.id.delete(affix.id);
  }

  // Delete the item instance
  ctx.db.itemInstance.id.delete(instance.id);

  // Grant salvage materials
  const itemName = instance.displayName ?? template.name;
  const grantedNames: string[] = [];
  for (const mat of baseYield) {
    addItemToInventory(ctx, character.id, mat.templateId, mat.quantity);
    grantedNames.push(`${mat.quantity}x ${mat.name}`);
  }

  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'reward',
    `You salvage ${itemName} into ${grantedNames.join(', ')}.`
  );
});
```

Add a helper function `getSalvageYield(tier: number, quality: string)`:
- Returns `{ templateId: bigint, quantity: bigint, name: string }[]`.
- Look up existing crafting material ItemTemplates by name. Read `ensure_items.ts` to find material templates. Common materials might be named things like "Iron Scrap", "Leather Scrap", "Cloth Scrap", "Arcane Dust" etc.
- If no crafting materials exist yet from Phase 13, create a simple approach:
  - Search for ANY resource-slot item template that could serve as salvage output.
  - If nothing suitable exists, just grant gold instead: modify character gold directly (`ctx.db.character.id.update({ ...character, gold: character.gold + goldAmount })`).
  - Gold yield: Common=2, Uncommon=5, Rare=10, Epic=20, Legendary=50 (scaled by tier).
- Scale yield by quality: Common=base, Uncommon=base*2, Rare=base*3, Epic=base*5.

The exact implementation depends on what crafting material templates exist. Check `ensure_items.ts` for any resource templates. If materials exist, use them. If not, fall back to gold-only salvage and note in summary that material salvage will be enhanced when Phase 13 crafting materials are available.

Import `addItemToInventory` if not already imported. Import `appendPrivateEvent` from helpers.
  </action>
  <verify>
`npx tsc --noEmit --project spacetimedb/tsconfig.json` passes. Verify salvage_item validates ownership, equipped status, and slot type. Verify it deletes ItemAffix rows before deleting ItemInstance. Verify it grants materials or gold and logs a private event.
  </verify>
  <done>
salvage_item reducer validates item ownership and type, deletes ItemAffix rows and ItemInstance, grants scaled rewards (crafting materials or gold based on tier and quality). Equipped items must be unequipped first. Junk, consumables, food, resources, and quest items cannot be salvaged.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles
- Legendary drops only occur from matching named enemy kills
- Only one legendary CombatLoot row per kill (not per group member)
- rollQualityTier never returns 'legendary'
- salvage_item properly cleans up both ItemAffix and ItemInstance
- Salvage rewards scale with tier and quality
- No Math.random() used anywhere
</verification>

<success_criteria>
- Named boss enemies drop their assigned Legendary item
- Legendary items have fixed affixes from catalog, not random rolls
- Old gear can be salvaged for materials/gold
- Salvage properly cleans up affix data
- Complete gear lifecycle: drop -> equip -> outgrow -> salvage/sell
</success_criteria>

<output>
After completion, create `.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-03-SUMMARY.md`
</output>
