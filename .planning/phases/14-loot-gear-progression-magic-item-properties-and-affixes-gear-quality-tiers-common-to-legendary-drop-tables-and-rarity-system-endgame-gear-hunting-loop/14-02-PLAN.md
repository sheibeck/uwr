---
phase: 14-loot-gear-progression
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - spacetimedb/src/helpers/items.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/items.ts
autonomous: true

must_haves:
  truths:
    - "Enemy kills roll a quality tier based on creature level using deterministic seeds"
    - "CombatLoot rows include qualityTier and affixDataJson for non-Common gear drops"
    - "Taking loot creates ItemAffix rows and sets qualityTier/displayName on ItemInstance"
    - "Equipped affix bonuses are included in getEquippedBonuses stat totals"
  artifacts:
    - path: "spacetimedb/src/helpers/items.ts"
      provides: "generateAffixData(), buildDisplayName(), getEquippedBonuses() with affix support"
      contains: "generateAffixData"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Quality tier rolling and affix data generation in generateLootTemplates()"
      contains: "rollQualityTier"
    - path: "spacetimedb/src/reducers/items.ts"
      provides: "take_loot creates ItemAffix rows and updates ItemInstance quality fields"
      contains: "affixDataJson"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/items.ts"
      via: "generateAffixData() called from generateLootTemplates()"
      pattern: "generateAffixData"
    - from: "spacetimedb/src/reducers/items.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "ItemAffix row creation in take_loot"
      pattern: "itemAffix.*insert"
    - from: "spacetimedb/src/helpers/items.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "getEquippedBonuses reads ItemAffix rows via by_instance index"
      pattern: "itemAffix\\.by_instance\\.filter"
---

<objective>
Implement the loot generation pipeline: quality tier rolling, affix data generation at drop time, affix application at take time, and equipped affix bonuses in combat.

Purpose: This is the core mechanic — enemies drop gear with quality tiers and affixes, players take loot and get stat bonuses from affixes. Without this, the affix schema from Plan 01 is inert.
Output: Working backend loot pipeline from enemy kill through equipped combat bonuses.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-01-SUMMARY.md
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/reducers/items.ts
@spacetimedb/src/helpers/items.ts
@spacetimedb/src/data/affix_catalog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add quality tier rolling and affix generation to loot pipeline</name>
  <files>spacetimedb/src/helpers/items.ts, spacetimedb/src/reducers/combat.ts</files>
  <action>
**In helpers/items.ts**, add the following new exports:

1. `getMaxTierForLevel(level: bigint): number` — Returns tier ceiling:
   - level <= 10n: return 1
   - level <= 20n: return 2
   - level <= 30n: return 3
   - else: return 4

2. `rollQualityTier(creatureLevel: bigint, seedBase: bigint): string` — Deterministic quality roll using `Number((seedBase + 31n) % 100n)`:
   - Tier 1 ceiling (level 1-10): uncommon threshold = min(25, Number(creatureLevel) * 2). Roll below threshold = 'uncommon', else 'common'.
   - Tier 2 ceiling (level 11-20): roll < 10 = 'rare', < 40 = 'uncommon', else 'common'.
   - Tier 3 ceiling (level 21-30): roll < 5 = 'epic', < 20 = 'rare', < 50 = 'uncommon', else 'common'.
   - Tier 4+ ceiling: roll < 3 = 'epic', < 15 = 'rare', < 45 = 'uncommon', else 'common'.
   - IMPORTANT: Seed offset is 31n (not colliding with existing 11n, 19n, 23n offsets in combat.ts).

3. `generateAffixData(slot: string, qualityTier: string, seedBase: bigint)` — Returns array of affix data objects:
   - Import PREFIXES, SUFFIXES, AFFIX_COUNT_BY_QUALITY from '../data/affix_catalog'.
   - Map qualityTier string to tier number: common=0, uncommon=1, rare=2, epic=3, legendary=4.
   - Get affix count from AFFIX_COUNT_BY_QUALITY. If 0, return empty array.
   - Filter PREFIXES to those where `slots.includes(slot)` AND `minTier <= tierNum`.
   - Filter SUFFIXES similarly.
   - For uncommon (1 affix): pick one prefix using seed + 37n.
   - For rare (2 affixes): pick one prefix (seed + 37n) and one suffix (seed + 41n).
   - For epic (3 affixes): pick one prefix (seed + 37n), one suffix (seed + 41n), then a second prefix or suffix (seed + 43n) from whichever pool has remaining options (exclude already-chosen keys).
   - Each result: `{ affixKey, affixType, magnitude: magnitudeByTier[tierNum - 1], statKey, affixName }`.
   - Use `Number(seed % BigInt(pool.length))` for index selection.

4. `buildDisplayName(baseItemName: string, affixes: { affixType: string; affixName: string }[]): string` — Combines prefix + base name + suffix:
   - Find first prefix affixName, find first suffix affixName.
   - Join: `[prefix, baseItemName, suffix].filter(Boolean).join(' ')`.

**In reducers/combat.ts**, extend `generateLootTemplates()`:

After the existing gear roll succeeds (the `if (rollGear < Number(gearChance))` block where a gear template is picked), add quality tier and affix generation:

1. Import `rollQualityTier`, `generateAffixData`, `buildDisplayName` from '../helpers/items'.
2. After a gear template is picked, roll quality: `const quality = rollQualityTier(enemyTemplate.level ?? 1n, seedBase)`.
3. If quality is NOT 'common', generate affix data: `const affixes = generateAffixData(template.slot, quality, seedBase)`.
4. Serialize affix data to JSON: `const affixDataJson = JSON.stringify(affixes)`.
5. Instead of just pushing the template, create an object with extra metadata: `{ template, qualityTier: quality, affixDataJson, isNamed: false }`.

Modify the return and consumption of `generateLootTemplates()`: currently it returns `template[]`. Change it to return `{ template, qualityTier?, affixDataJson?, isNamed? }[]`. Update all callers that iterate the result to handle the new shape.

Where CombatLoot rows are inserted (find the `ctx.db.combatLoot.insert(...)` call in the combat end logic), pass the new fields:
```typescript
ctx.db.combatLoot.insert({
  id: 0n,
  combatId,
  ownerUserId: participant.ownerUserId,
  characterId: participant.characterId,
  itemTemplateId: lootItem.template.id,
  createdAt: ctx.timestamp,
  qualityTier: lootItem.qualityTier ?? undefined,
  affixDataJson: lootItem.affixDataJson ?? undefined,
  isNamed: lootItem.isNamed ?? undefined,
});
```

CRITICAL: Use deterministic seed offsets (31n, 37n, 41n, 43n). NO Math.random() anywhere. All randomness derived from `ctx.timestamp.microsSinceUnixEpoch + characterId` variants per established pattern.
  </action>
  <verify>
`npx tsc --noEmit --project spacetimedb/tsconfig.json` passes. Verify `rollQualityTier` exists and uses seed + 31n. Verify `generateAffixData` returns correct number of affixes per quality tier. Verify CombatLoot.insert calls include the new optional fields.
  </verify>
  <done>
generateLootTemplates() rolls quality tier per creature level, generates affix data for non-Common gear, and stores qualityTier + affixDataJson on CombatLoot rows. Quality thresholds match user decisions: Tier 1 = Common/Uncommon only, Tier 2 adds Rare, Tier 3 adds Epic. Fixed values per tier with no range rolling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend take_loot to create ItemAffix rows and update getEquippedBonuses for affix stats</name>
  <files>spacetimedb/src/reducers/items.ts, spacetimedb/src/helpers/items.ts</files>
  <action>
**In reducers/items.ts**, extend the `take_loot` reducer:

After the existing `addItemToInventory(ctx, character.id, template.id, 1n)` call:

1. Check if the CombatLoot row has affix data: `if (loot.qualityTier && loot.qualityTier !== 'common')`.
2. Find the newly created ItemInstance — it's the most recent one for this character+template with no qualityTier set:
   ```typescript
   const instances = [...ctx.db.itemInstance.by_owner.filter(character.id)];
   const newInstance = instances.find(i =>
     i.templateId === loot.itemTemplateId &&
     !i.equippedSlot &&
     !i.qualityTier
   );
   ```
3. If found and `loot.affixDataJson`:
   - Parse the JSON: `const affixes = JSON.parse(loot.affixDataJson)`.
   - For each affix, insert an ItemAffix row:
     ```typescript
     ctx.db.itemAffix.insert({
       id: 0n,
       itemInstanceId: newInstance.id,
       affixType: affix.affixType,
       affixKey: affix.affixKey,
       affixName: affix.affixName,
       statKey: affix.statKey,
       magnitude: BigInt(affix.magnitude),
     });
     ```
   - Build display name: `const displayName = buildDisplayName(template.name, affixes)`.
   - Update the ItemInstance with quality data:
     ```typescript
     ctx.db.itemInstance.id.update({
       ...newInstance,
       qualityTier: loot.qualityTier,
       displayName,
       isNamed: loot.isNamed ?? undefined,
     });
     ```
4. Import `buildDisplayName` from '../helpers/items'.
5. Update the log message to use the display name if available (e.g., "You receive Sturdy Scout Jerkin of Haste" instead of just "You receive Scout Jerkin").

**In helpers/items.ts**, extend `getEquippedBonuses()`:

Currently it sums template stat bonuses for equipped items. Add affix bonus summation:

1. Add new fields to the bonuses object:
   ```typescript
   const bonuses = {
     str: 0n, dex: 0n, cha: 0n, wis: 0n, int: 0n,
     hpBonus: 0n, manaBonus: 0n, armorClassBonus: 0n,
     // NEW affix stat fields:
     magicResistanceBonus: 0n,
     lifeOnHit: 0n,
     cooldownReduction: 0n,
     manaRegen: 0n,
     weaponBaseDamage: 0n,
   };
   ```
2. After reading template bonuses for each equipped item, also iterate ItemAffix rows:
   ```typescript
   for (const affix of ctx.db.itemAffix.by_instance.filter(instance.id)) {
     const key = affix.statKey;
     if (key === 'strBonus') bonuses.str += affix.magnitude;
     else if (key === 'dexBonus') bonuses.dex += affix.magnitude;
     else if (key === 'intBonus') bonuses.int += affix.magnitude;
     else if (key === 'wisBonus') bonuses.wis += affix.magnitude;
     else if (key === 'chaBonus') bonuses.cha += affix.magnitude;
     else if (key === 'hpBonus') bonuses.hpBonus += affix.magnitude;
     else if (key === 'manaBonus') bonuses.manaBonus += affix.magnitude;
     else if (key === 'armorClassBonus') bonuses.armorClassBonus += affix.magnitude;
     else if (key === 'magicResistanceBonus') bonuses.magicResistanceBonus += affix.magnitude;
     else if (key === 'lifeOnHit') bonuses.lifeOnHit += affix.magnitude;
     else if (key === 'cooldownReduction') bonuses.cooldownReduction += affix.magnitude;
     else if (key === 'manaRegen') bonuses.manaRegen += affix.magnitude;
     else if (key === 'weaponBaseDamage') bonuses.weaponBaseDamage += affix.magnitude;
   }
   ```
3. Also add `magicResistanceBonus` to the existing template bonus reading (it already exists on ItemTemplate but may not be summed): `bonuses.magicResistanceBonus += template.magicResistanceBonus;`.

NOTE: The returned `lifeOnHit`, `cooldownReduction`, and `manaRegen` fields are available for future combat integration. For now they're summed and returned but not yet consumed by combat reducers (Tier 3+ affix types). The stat bonuses (str, dex, int, wis, hp, armor, magicResistance) are already consumed by `recomputeCharacterDerived()`.

Also update `sell_item` reducer: when selling an item that has affixes, delete the ItemAffix rows first before deleting the ItemInstance. Find and delete via `ctx.db.itemAffix.by_instance.filter(instance.id)`.
  </action>
  <verify>
`npx tsc --noEmit --project spacetimedb/tsconfig.json` passes. Verify take_loot creates ItemAffix rows when affixDataJson is present. Verify getEquippedBonuses iterates ItemAffix rows for equipped items. Verify sell_item cleans up ItemAffix rows.
  </verify>
  <done>
take_loot creates ItemAffix rows from CombatLoot.affixDataJson, sets qualityTier/displayName/isNamed on ItemInstance. getEquippedBonuses sums affix stat bonuses (str, dex, int, wis, hp, armor, magicResistance, lifeOnHit, cooldownReduction, manaRegen, weaponBaseDamage) from equipped items' ItemAffix rows. sell_item cleans up affixes before deleting item.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors
- generateLootTemplates returns quality + affix data alongside templates
- CombatLoot rows contain qualityTier and affixDataJson for non-Common drops
- take_loot creates correct number of ItemAffix rows (1 for uncommon, 2 for rare, 3 for epic)
- ItemInstance updated with qualityTier and displayName after taking affixed loot
- getEquippedBonuses returns all base + affix bonuses for equipped items
- sell_item deletes ItemAffix rows before deleting ItemInstance
- All randomness uses deterministic seeds (no Math.random())
</verification>

<success_criteria>
- Complete backend loot pipeline: kill -> quality roll -> affix generation -> CombatLoot -> take_loot -> ItemAffix rows -> equipped bonuses
- Fixed values per tier (no range rolling) per user decision
- Uncommon items have 1 affix, Rare have 2, Epic have 3
- Level-gated quality: Tier 1 zone drops Common/Uncommon only, etc.
- Affix stat bonuses properly flow into character derived stats
</success_criteria>

<output>
After completion, create `.planning/phases/14-loot-gear-progression-magic-item-properties-and-affixes-gear-quality-tiers-common-to-legendary-drop-tables-and-rarity-system-endgame-gear-hunting-loop/14-02-SUMMARY.md`
</output>
