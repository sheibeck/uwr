---
plan: 22-03
title: executeAbility switch cases for all new abilities
phase: 22
status: pending
estimated_tasks: 3
---

# Plan 22-03: executeAbility switch cases for all new abilities

## Goal
Add a switch case for every new ability key introduced in Plan 22-02, implement all new mechanics (stances, BardSong activation, life drain, charm-pet, conjure items, temp equipment), remove cases for retired keys, and add the `tick_bard_songs` reducer plus temp item logout cleanup.

## Prerequisites
- Plan 22-01 (schema changes live — ActiveBardSong, BardSongTick, ownerCharacterId, isTemporary, stun handling)
- Plan 22-02 (new ability keys defined in data files)

## Tasks

### Task 1: Remove retired cases and add new cases for classes 1–8

**File:** `spacetimedb/src/helpers/combat.ts`

**Action:** In the `runAbility()` switch inside `executeAbility()`, remove cases for keys that no longer exist and add cases for all new keys from classes 1–8.

**Details:**

**Remove these cases entirely** (keys from old files replaced by new keys):
- `warrior_rally` — was level 4n, now level 9n (keep the case, just ensure it matches new behavior)
- `warrior_cleave` — was level 3n, now level 7n (keep case, re-check still works)
- `bard_ballad_of_resolve` — REMOVE (replaced by `bard_melody_of_mending`)
- `bard_echoed_chord` — REMOVE (replaced by `bard_chorus_of_vigor`)
- `bard_harmony` — REMOVE (replaced by `bard_march_of_wayfarers` / `bard_battle_hymn`)
- `bard_crushing_crescendo` — REMOVE (replaced by `bard_finale`)
- `enchanter_veil_of_calm` — REMOVE (replaced by `enchanter_mesmerize`)
- `enchanter_slow` — REMOVE (replaced by `enchanter_bewilderment`)
- `enchanter_clarity_ii` — REMOVE (replaced by `enchanter_clarity`)
- `enchanter_charm_fray` — REMOVE (replaced by `enchanter_charm`)
- `monk_palm_strike` — REMOVE (replaced by `monk_stunning_strike`)
- `monk_inner_focus` — RENAME to `monk_centering` uses (centering behavior stays, key changes)
- `monk_centering` — was level 2n, now level 7n (keep case behavior)
- `ranger_rapid_shot` — was level 3n (hits: 2n), now level 9n (keep, no behavior change needed)
- `druid_bramble` — REMOVE (replaced by `druid_entangle`)
- `druid_natures_gift` — keep (level changed from 4n to 7n, no behavior change)
- `summoner_conjure_vessel` — REMOVE (replaced by `summoner_earth_elemental`)
- `summoner_earth_familiar` — REMOVE (renamed to `summoner_earth_elemental`)
- `summoner_conjured_spike` — REMOVE (no direct damage abilities for summoner now)
- `summoner_empower` — REMOVE (replaced by `summoner_water_elemental`)
- `summoner_spectral_lance` — REMOVE (replaced by `summoner_fire_elemental`)
- `necromancer_bone_ward` — REMOVE (replaced by `necromancer_soul_rot`)
- `necromancer_grave_surge` — REMOVE (replaced by `necromancer_plague_lord_form`)
- `reaver_dread_aura` — update (now AoE all enemies, behavior needs update)
- `spellblade_arcane_slash` — REMOVE (replaced by `spellblade_flame_strike`)
- `spellblade_rune_ward` — REMOVE (replaced by `spellblade_frost_armor`)
- `spellblade_runic_strike` — REMOVE (replaced by `spellblade_thunder_cleave`)
- `spellblade_ward` — REMOVE (replaced by `spellblade_stone_skin`)
- `spellblade_spellstorm` — REMOVE (replaced by `spellblade_elemental_surge`)
- `beastmaster_pack_rush` — was level 1n, now level 3n (keep case)
- `beastmaster_call_beast` — was level 2n, now level 1n (keep case)
- `beastmaster_beast_fang` — was level 3n, now level 9n (keep case, add DoT)
- `beastmaster_alpha_assault` — was level 5n, now level 5n (keep)
- `beastmaster_wild_howl` — was level 4n, now level 7n (keep)
- `paladin_lay_on_hands` — was level 2n, now level 7n (keep)
- `paladin_shield_of_faith` — was level 3n, now level 3n (keep)
- `paladin_devotion` — was level 4n, now level 9n (keep)
- `paladin_radiant_smite` — was level 5n, now level 5n (keep)

**Add these new cases** for classes 1–8 (replace the `default:` append with these before it):

```typescript
// ===== WARRIOR NEW =====
case 'warrior_berserker_rage':
  // 30s stance: +50% physical damage, blocks defensive abilities
  addCharacterEffect(ctx, character.id, 'damage_up', 5n, 6n, 'Berserker Rage');
  addCharacterEffect(ctx, character.id, 'berserker_stance', 1n, 6n, 'Berserker Rage');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Berserker Rage ignites your fury! Physical damage increased. Cannot use defensive abilities.'
  );
  return;

// ===== CLERIC NEW =====
case 'cleric_blessing_of_might':
  // Group STR buff ~45min = 450 rounds (EffectTick fires every ~6s)
  applyPartyEffect('str_bonus', 3n, 450n, 'Blessing of Might');
  for (const member of partyMembers) {
    recomputeCharacterDerived(ctx, member);
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Blessing of Might strengthens the party with divine power.'
  );
  return;

case 'cleric_sanctify':
  // Group AC + HP regen buff ~45min
  applyPartyEffect('ac_bonus', 3n, 450n, 'Sanctify');
  applyPartyEffect('regen', 4n, 450n, 'Sanctify');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Sanctify blesses the party with divine protection.'
  );
  return;

case 'cleric_holy_nova':
  // AoE magic damage to all enemies + heal all allies simultaneously
  applyDamage(0n, 0n);
  for (const member of partyMembers) {
    applyHeal(member, 20n, 'Holy Nova');
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Holy Nova erupts in divine light!'
  );
  return;

// ===== WIZARD NEW =====
case 'wizard_arcane_storm':
  applyDamage(0n, 0n);
  return;

case 'wizard_arcane_explosion':
  applyDamage(0n, 0n);
  return;

// ===== ROGUE NEW =====
case 'rogue_death_mark': {
  if (!enemy || !combatId) throw new SenderError('You have no target to unleash this upon.');
  // damage_up on the ENEMY (debuff that increases damage taken)
  addEnemyEffect(ctx, combatId, enemy.id, 'damage_taken', 5n, 3n, 'Death Mark');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Death Mark condemns ${enemyName} — all damage to them increased.`
  );
  return;
}

// ===== RANGER NEW =====
case 'ranger_rapid_shot':
  applyDamage(0n, 0n, { hits: 2n });
  return;

case 'ranger_rain_of_arrows':
  applyDamage(0n, 0n);
  return;

// ===== DRUID NEW =====
case 'druid_entangle':
  applyDamage(0n, 0n);
  return;

case 'druid_shapeshifter_form':
  // +40% physical damage for ~5 rounds (30s), temp HP buffer as hp_bonus
  addCharacterEffect(ctx, character.id, 'damage_up', 4n, 5n, 'Shapeshifter Form');
  addCharacterEffect(ctx, character.id, 'shapeshifter_stance', 1n, 5n, 'Shapeshifter Form');
  applyHpBonus(ctx, character, 20n, 5n, 'Shapeshifter Form');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'You shift into a primal beast form! Physical damage increased.'
  );
  return;

// ===== BARD SONG SYSTEM =====
// All bard songs follow the same pattern: insert/update ActiveBardSong row,
// schedule a BardSongTick if none exists for this bard in this combat.
// The existing song (if any) is set to isFading=true for 1 tick, then replaced.

case 'bard_discordant_note':
case 'bard_melody_of_mending':
case 'bard_chorus_of_vigor':
case 'bard_march_of_wayfarers':
case 'bard_battle_hymn': {
  if (!combatId || !combat) throw new SenderError('Songs can only be sung in combat.');
  // Mark previous song as fading
  const prevSong = [...ctx.db.activeBardSong.by_bard.filter(character.id)][0];
  if (prevSong) {
    ctx.db.activeBardSong.id.update({ ...prevSong, isFading: true });
  } else {
    // Schedule first tick (subsequent ticks are rescheduled from the tick reducer)
    ctx.db.bardSongTick.insert({
      scheduledId: 0n,
      scheduledAt: ScheduleAt.time(nowMicros + 6_000_000n),
      bardCharacterId: character.id,
      combatId,
    });
  }
  // Insert new active song
  if (prevSong) {
    ctx.db.activeBardSong.id.delete(prevSong.id);
  }
  ctx.db.activeBardSong.insert({
    id: 0n,
    bardCharacterId: character.id,
    combatId,
    songKey: abilityKey,
    startedAtMicros: nowMicros,
    isFading: false,
  });
  const songNames: Record<string, string> = {
    bard_discordant_note: 'Discordant Note',
    bard_melody_of_mending: 'Melody of Mending',
    bard_chorus_of_vigor: 'Chorus of Vigor',
    bard_march_of_wayfarers: 'March of Wayfarers',
    bard_battle_hymn: 'Battle Hymn',
  };
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `You begin singing ${songNames[abilityKey] ?? abilityKey}.`
  );
  return;
}

case 'bard_finale': {
  // Burst all active/fading songs: apply their effect once immediately
  const activeSong = [...ctx.db.activeBardSong.by_bard.filter(character.id)][0];
  if (!activeSong) {
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
      'No active song to unleash.'
    );
    return;
  }
  // Apply the current song's effect immediately once
  _applyBardSongEffect(ctx, character, activeSong.songKey, combatId, combat, enemy, partyMembers, partyMembers, actorGroupId);
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Finale! Your song crescendos in a powerful burst!'
  );
  return;
}

// ===== MONK NEW =====
case 'monk_stunning_strike':
  // Physical damage + stun (enemy stun via CombatEnemyEffect)
  applyDamage(0n, 0n, {
    debuff: { type: 'stun', magnitude: 1n, rounds: 4n, source: 'Stunning Strike' },
  });
  return;

case 'monk_centering':
  // Restore stamina directly
  {
    const latest = ctx.db.character.id.find(character.id);
    if (latest) {
      const restored = latest.stamina + 15n > latest.maxStamina ? latest.maxStamina : latest.stamina + 15n;
      ctx.db.character.id.update({ ...latest, stamina: restored });
    }
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
      'Centering restores your inner energy.'
    );
  }
  return;

case 'monk_inner_focus':
  addCharacterEffect(ctx, character.id, 'damage_up', 3n, 3n, 'Inner Focus');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Inner Focus sharpens your combat senses.'
  );
  return;

case 'monk_hundred_fists':
  applyDamage(0n, 0n, {
    hits: 5n,
    perHitMessage: (damage, hitIndex, totalHits) =>
      `Hundred Fists strikes ${enemyName} for ${damage} damage. (${hitIndex}/${totalHits})`,
  });
  return;
```

**Note on `_applyBardSongEffect`:** This is a helper function that must be defined BEFORE the `executeAbility` function (or inside it as a `const`). Add it as a local const inside `executeAbility` just before the `runAbility` switch:

```typescript
const _applyBardSongEffect = (
  ctx: any, char: any, songKey: string, cId: bigint | null, cbt: any,
  en: any, members: any[], _allMembers: any[], grpId: bigint | undefined
) => {
  switch (songKey) {
    case 'bard_discordant_note':
    case 'bard_battle_hymn':
      if (en && cId) {
        const enemies = [...ctx.db.combatEnemy.by_combat.filter(cId)];
        for (const tEnemy of enemies) {
          if (tEnemy.currentHp === 0n) continue;
          const dmg = 5n + char.level;
          const nextHp = tEnemy.currentHp > dmg ? tEnemy.currentHp - dmg : 0n;
          ctx.db.combatEnemy.id.update({ ...tEnemy, currentHp: nextHp });
        }
        if (songKey === 'bard_battle_hymn') {
          for (const m of members) {
            const fresh = ctx.db.character.id.find(m.id);
            if (!fresh) continue;
            const healed = fresh.hp + 8n > fresh.maxHp ? fresh.maxHp : fresh.hp + 8n;
            ctx.db.character.id.update({ ...fresh, hp: healed });
            const freshM2 = ctx.db.character.id.find(m.id);
            if (freshM2) {
              const manaRestored = freshM2.mana + 4n > freshM2.maxMana ? freshM2.maxMana : freshM2.mana + 4n;
              ctx.db.character.id.update({ ...freshM2, mana: manaRestored });
            }
          }
        }
      }
      break;
    case 'bard_melody_of_mending':
      for (const m of members) {
        const fresh = ctx.db.character.id.find(m.id);
        if (!fresh) continue;
        const healed = fresh.hp + 10n > fresh.maxHp ? fresh.maxHp : fresh.hp + 10n;
        ctx.db.character.id.update({ ...fresh, hp: healed });
      }
      break;
    case 'bard_chorus_of_vigor':
      for (const m of members) {
        const fresh = ctx.db.character.id.find(m.id);
        if (!fresh || fresh.maxMana === 0n) continue;
        const manaGain = fresh.mana + 8n > fresh.maxMana ? fresh.maxMana : fresh.mana + 8n;
        ctx.db.character.id.update({ ...fresh, mana: manaGain });
      }
      break;
    case 'bard_march_of_wayfarers':
      // Travel discount is handled in movement.ts via CharacterEffect.
      // On each tick, refresh the travel_discount effect on all party members.
      for (const m of members) {
        addCharacterEffect(ctx, m.id, 'travel_discount', 3n, 2n, 'March of Wayfarers');
      }
      break;
  }
};
```

**Verify:** `grep -n "bard_discordant_note\|bard_melody\|bard_chorus\|bard_march\|bard_battle_hymn\|bard_finale\|monk_stunning_strike\|monk_hundred_fists\|warrior_berserker_rage" spacetimedb/src/helpers/combat.ts` shows all new cases.

**Done:** All new class 1–8 ability cases are in the switch. Old retired cases are removed. BardSong insertion logic is functional.

---

### Task 2: Add new cases for classes 9–16 plus Wither life drain update

**File:** `spacetimedb/src/helpers/combat.ts`

**Action:** Add switch cases for all new keys from classes 9–16. Update Wither to use `ownerCharacterId` on the DoT effect.

**Details:**

Add these cases inside the `runAbility()` switch (before the `default:` case):

```typescript
// ===== PALADIN NEW =====
case 'paladin_holy_strike':
  applyDamage(0n, 0n, { threatBonus: 5n });
  addCharacterEffect(ctx, character.id, 'ac_bonus', 2n, 2n, 'Holy Strike');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Holy Strike steadies your guard.'
  );
  return;

case 'paladin_consecrated_ground': {
  // AoE DoT all enemies + HoT all allies simultaneously
  applyDamage(0n, 0n);
  for (const member of partyMembers) {
    addCharacterEffect(ctx, member.id, 'regen', 8n, 3n, 'Consecrated Ground');
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Consecrated Ground burns your enemies and heals your allies!'
  );
  return;
}

// ===== SHAMAN NEW =====
case 'shaman_spirit_mender':
  if (!targetCharacter) throw new SenderError('Target required');
  // HoT via ability metadata hotPowerSplit
  applyHeal(targetCharacter, 15n, 'Spirit Mender');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Spirit Mender soothes ${targetCharacter.name}.`
  );
  return;

case 'shaman_hex':
  applyDamage(0n, 0n, {
    debuff: { type: 'ac_bonus', magnitude: -2n, rounds: 3n, source: 'Hex' },
  });
  return;

case 'shaman_stormcall':
  applyDamage(0n, 0n);
  return;

case 'shaman_spirit_wolf':
  summonPet('Spirit Wolf', 'a spirit wolf', [
    'Mistfang', 'Ghostpaw', 'Duskhowl', 'Frostpad', 'Silent',
  ], undefined, { damageBase: 4n, damagePerLevel: 2n, weaponScalePercent: 45n });
  return;

case 'shaman_ancestral_ward':
  if (!targetCharacter) throw new SenderError('Target required');
  addCharacterEffect(ctx, targetCharacter.id, 'ac_bonus', 4n, 4n, 'Ancestral Ward');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Ancestral Ward shields ${targetCharacter.name}.`
  );
  return;

case 'shaman_earthquake':
  // AoE physical damage + stun all enemies
  applyDamage(0n, 0n);
  if (combatId) {
    const allEnemies = [...ctx.db.combatEnemy.by_combat.filter(combatId)];
    for (const en of allEnemies) {
      if (en.currentHp === 0n) continue;
      addEnemyEffect(ctx, combatId, en.id, 'stun', 1n, 4n, 'Earthquake');
    }
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Earthquake shakes the ground, stunning all enemies!'
  );
  return;

// ===== NECROMANCER UPDATED =====
case 'necromancer_wither': {
  // Life drain DoT: damages enemy AND heals caster per tick
  // Use ownerCharacterId on the CombatEnemyEffect to trigger heal in combat loop tick
  if (!enemy || !combatId) throw new SenderError('You have no target to unleash this upon.');
  const witherDotDamage = 5n + character.level;
  addEnemyEffect(ctx, combatId, enemy.id, 'dot', witherDotDamage, 3n, 'Wither');
  // Find the just-inserted effect and add ownerCharacterId
  // Search for the effect we just inserted (same source and type)
  const witherEffect = [...ctx.db.combatEnemyEffect.by_enemy.filter(enemy.id)]
    .find(e => e.effectType === 'dot' && e.sourceAbility === 'Wither');
  if (witherEffect) {
    ctx.db.combatEnemyEffect.id.update({ ...witherEffect, ownerCharacterId: character.id });
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Wither drains life from ${enemyName}.`
  );
  return;
}

case 'necromancer_soul_rot': {
  // DoT + AC debuff per tick — apply the DoT damage and also add armor debuff
  applyDamage(0n, 0n, {
    debuff: { type: 'ac_bonus', magnitude: -2n, rounds: 3n, source: 'Soul Rot' },
    dot: { magnitude: 4n, rounds: 3n, source: 'Soul Rot' },
  });
  return;
}

case 'necromancer_plague_lord_form':
  // 30s stance: all DoTs tick at 2x speed (simulated as damage_up on DoT effects)
  // Implemented as a marker CharacterEffect the combat loop checks
  addCharacterEffect(ctx, character.id, 'plague_lord_stance', 1n, 5n, 'Plague Lord Form');
  addCharacterEffect(ctx, character.id, 'damage_up', 4n, 5n, 'Plague Lord Form');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Plague Lord Form consumes you with dark power!'
  );
  return;

// ===== BEASTMASTER NEW =====
case 'beastmaster_call_beast':
  summonPet(
    'Beast', 'a wild beast',
    ['Brindle', 'Moss', 'Cinder', 'Tawny', 'Thorn'],
    { key: 'pet_bleed', cooldownSeconds: 10n },
    { damageBase: 3n, damagePerLevel: 2n, weaponScalePercent: 40n }
  );
  return;

case 'beastmaster_pack_rush':
  applyDamage(0n, 0n, {
    hits: 2n,
    perHitMessage: (damage, hitIndex, totalHits) =>
      `Pack Rush strikes ${enemyName} for ${damage} damage. (${hitIndex}/${totalHits})`,
  });
  return;

case 'beastmaster_alpha_assault':
  applyDamage(0n, 0n);
  return;

case 'beastmaster_wild_howl':
  // Empower the pet: apply a damage_up to the pet via CharacterEffect on owner (pet inherits)
  applyPartyEffect('damage_up', 3n, 4n, 'Wild Howl');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Wild Howl emboldens you and your beast!'
  );
  return;

case 'beastmaster_beast_fang':
  applyDamage(0n, 0n, { dot: { magnitude: 3n, rounds: 2n, source: 'Beast Fang' } });
  return;

case 'beastmaster_wild_hunt':
  // Pet AoE: applies AoE damage from the character (acting as pet-proxy)
  applyDamage(0n, 0n);
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Wild Hunt! Your beast ravages all enemies!'
  );
  return;

// ===== ENCHANTER NEW =====
case 'enchanter_mind_fray':
  applyDamage(0n, 0n, { dot: { magnitude: 3n, rounds: 3n, source: 'Mind Fray' } });
  return;

case 'enchanter_mesmerize':
  applyDamage(0n, 0n, {
    debuff: { type: 'stun', magnitude: 1n, rounds: 4n, source: 'Mesmerize' },
  });
  return;

case 'enchanter_clarity':
  if (!targetCharacter) throw new SenderError('Target required');
  addCharacterEffect(ctx, targetCharacter.id, 'mana_regen', 8n, 4n, 'Clarity');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Clarity rapidly restores ${targetCharacter.name}'s mana.`
  );
  return;

case 'enchanter_haste':
  // Party-wide haste buff (auto-attack and cast time reduction)
  applyPartyEffect('haste', 1n, 5n, 'Haste');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Haste accelerates the entire party!'
  );
  return;

case 'enchanter_bewilderment':
  // AoE AC debuff on all enemies
  if (combatId) {
    const allEnemies = [...ctx.db.combatEnemy.by_combat.filter(combatId)];
    for (const en of allEnemies) {
      if (en.currentHp === 0n) continue;
      addEnemyEffect(ctx, combatId, en.id, 'ac_bonus', -3n, 3n, 'Bewilderment');
    }
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Bewilderment confuses all enemies, reducing their defenses!'
  );
  return;

case 'enchanter_charm': {
  // Spawn a psychic copy of the current enemy as a CombatPet
  if (!enemy || !combatId) throw new SenderError('You have no target to unleash this upon.');
  const enemyTpl = ctx.db.enemyTemplate.id.find(enemy.enemyTemplateId);
  summonPet(
    'Charmed', `a charmed ${enemyName}`,
    [enemyName, 'Echo', 'Mirror'],
    undefined,
    {
      hpBase: enemy.maxHp / 2n > 10n ? enemy.maxHp / 2n : 10n,
      hpPerLevel: 0n,
      damageBase: enemy.attackDamage / 2n > 2n ? enemy.attackDamage / 2n : 2n,
      damagePerLevel: 0n,
      weaponScalePercent: 0n,
    }
  );
  return;
}

// ===== REAVER UPDATED =====
case 'reaver_blood_rend': {
  const dealt = applyDamage(0n, 0n);
  if (dealt > 0n) {
    const leech = (dealt * 20n) / 100n;
    applyHeal(character, leech > 0n ? leech : 1n, 'Blood Rend');
  }
  return;
}

case 'reaver_soul_rend':
  applyDamage(0n, 0n);
  return;

case 'reaver_oblivion':
  applyDamage(0n, 0n);
  return;

case 'reaver_dread_aura':
  // AoE debuff all enemies
  if (combatId) {
    const allEnemies = [...ctx.db.combatEnemy.by_combat.filter(combatId)];
    for (const en of allEnemies) {
      if (en.currentHp === 0n) continue;
      addEnemyEffect(ctx, combatId, en.id, 'damage_down', -3n, 3n, 'Dread Aura');
    }
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Dread Aura weakens all enemies around you.'
  );
  return;

case 'reaver_blood_pact':
  addCharacterEffect(ctx, character.id, 'damage_up', 4n, 4n, 'Blood Pact');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Blood Pact fuels your dark power.'
  );
  return;

case 'reaver_deaths_embrace':
  // 30s stance: lifesteal 30% + damage_up 25%
  addCharacterEffect(ctx, character.id, 'deaths_embrace_stance', 1n, 5n, "Death's Embrace");
  addCharacterEffect(ctx, character.id, 'damage_up', 3n, 5n, "Death's Embrace");
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    "Death's Embrace empowers you with dark vitality!"
  );
  return;

// ===== SPELLBLADE NEW =====
case 'spellblade_flame_strike':
  applyDamage(0n, 0n, { dot: { magnitude: 3n, rounds: 2n, source: 'Flame Strike' } });
  return;

case 'spellblade_frost_armor':
  addCharacterEffect(ctx, character.id, 'ac_bonus', 4n, 4n, 'Frost Armor');
  addCharacterEffect(ctx, character.id, 'damage_shield', 5n, 4n, 'Frost Armor');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Frost Armor encases you in protective ice.'
  );
  return;

case 'spellblade_thunder_cleave':
  applyDamage(0n, 0n);
  return;

case 'spellblade_stone_skin':
  addCharacterEffect(ctx, character.id, 'ac_bonus', 8n, 5n, 'Stone Skin');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Stone Skin hardens you like the earth itself.'
  );
  return;

case 'spellblade_magma_shield':
  addCharacterEffect(ctx, character.id, 'ac_bonus', 5n, 5n, 'Magma Shield');
  addCharacterEffect(ctx, character.id, 'damage_shield', 8n, 5n, 'Magma Shield');
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Magma Shield surrounds you in molten protection.'
  );
  return;

case 'spellblade_elemental_surge':
  applyDamage(0n, 0n);
  return;

// ===== SUMMONER NEW =====
case 'summoner_earth_elemental':
  summonPet(
    'Earth Elemental', 'an earth elemental',
    ['Granite', 'Boulder', 'Stone', 'Clay', 'Bedrock'],
    { key: 'pet_taunt', cooldownSeconds: 8n },
    { hpBase: 30n, hpPerLevel: 8n, damageBase: 2n, damagePerLevel: 1n, weaponScalePercent: 20n }
  );
  return;

case 'summoner_conjure_sustenance': {
  // Give all party members food (bandages/food item from existing templates)
  const bandageTemplate = [...ctx.db.itemTemplate.iter()].find(
    t => t.name.toLowerCase().includes('bandage')
  );
  const foodTemplate = [...ctx.db.itemTemplate.iter()].find(
    t => t.isJunk === false && t.wellFedDurationMicros > 0n
  );
  let conjured = 0;
  for (const member of partyMembers) {
    if (bandageTemplate && hasInventorySpace(ctx, member.id, bandageTemplate.id)) {
      addItemToInventory(ctx, member.id, bandageTemplate.id, 2n);
      conjured++;
    }
    if (foodTemplate && hasInventorySpace(ctx, member.id, foodTemplate.id)) {
      addItemToInventory(ctx, member.id, foodTemplate.id, 1n);
    }
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    `Conjure Sustenance provides supplies to ${conjured} party members.`
  );
  return;
}

case 'summoner_fire_elemental':
  // Replace current pet with fire elemental
  summonPet(
    'Fire Elemental', 'a fire elemental',
    ['Ember', 'Blaze', 'Scorch', 'Cinder', 'Pyre'],
    undefined,
    { hpBase: 18n, hpPerLevel: 5n, damageBase: 5n, damagePerLevel: 3n, weaponScalePercent: 60n }
  );
  return;

case 'summoner_water_elemental':
  // Water elemental: pet with heal ability key (handled in combat loop pet tick)
  summonPet(
    'Water Elemental', 'a water elemental',
    ['Tide', 'Current', 'Flow', 'Rill', 'Mist'],
    { key: 'pet_heal', cooldownSeconds: 6n },
    { hpBase: 22n, hpPerLevel: 6n, damageBase: 2n, damagePerLevel: 1n, weaponScalePercent: 25n }
  );
  return;

case 'summoner_conjure_equipment': {
  // Create temporary weapon and armor items marked isTemporary=true
  const weaponCandidates = [...ctx.db.itemTemplate.iter()].filter(
    t => t.slot === 'mainHand' && !t.isJunk
  );
  const armorCandidates = [...ctx.db.itemTemplate.iter()].filter(
    t => t.slot === 'chest' && !t.isJunk
  );
  const seed = nowMicros + character.id;
  const weaponTpl = weaponCandidates.length > 0
    ? weaponCandidates[Number(seed % BigInt(weaponCandidates.length))]
    : null;
  const armorTpl = armorCandidates.length > 0
    ? armorCandidates[Number((seed + 7n) % BigInt(armorCandidates.length))]
    : null;

  if (weaponTpl && hasInventorySpace(ctx, character.id, weaponTpl.id)) {
    ctx.db.itemInstance.insert({
      id: 0n,
      templateId: weaponTpl.id,
      ownerCharacterId: character.id,
      equippedSlot: undefined,
      quantity: 1n,
      qualityTier: 'uncommon',
      craftQuality: undefined,
      displayName: `Conjured ${weaponTpl.name}`,
      isNamed: undefined,
      isTemporary: true,
    });
  }
  if (armorTpl && hasInventorySpace(ctx, character.id, armorTpl.id)) {
    ctx.db.itemInstance.insert({
      id: 0n,
      templateId: armorTpl.id,
      ownerCharacterId: character.id,
      equippedSlot: undefined,
      quantity: 1n,
      qualityTier: 'uncommon',
      craftQuality: undefined,
      displayName: `Conjured ${armorTpl.name}`,
      isNamed: undefined,
      isTemporary: true,
    });
  }
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'Conjure Equipment materializes temporary gear.'
  );
  return;
}

case 'summoner_primal_titan':
  summonPet(
    'Primal Titan', 'the Primal Titan',
    ['Titan', 'Colossus', 'Ancient'],
    { key: 'pet_aoe_heal', cooldownSeconds: 6n },
    { hpBase: 60n, hpPerLevel: 12n, damageBase: 6n, damagePerLevel: 4n, weaponScalePercent: 70n }
  );
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'ability',
    'The Primal Titan answers your call!'
  );
  return;
```

**Verify:** `grep -n "shaman_earthquake\|enchanter_charm\|reaver_deaths_embrace\|summoner_primal_titan\|necromancer_plague_lord_form\|paladin_consecrated_ground" spacetimedb/src/helpers/combat.ts` shows all new cases.

**Done:** All new ability cases for classes 9–16 are in the switch. Wither uses `ownerCharacterId`. Old retired cases are gone.

---

### Task 3: Add tick_bard_songs reducer and temp item logout cleanup

**File:** `spacetimedb/src/reducers/combat.ts` (or a new file `spacetimedb/src/reducers/bard.ts` if preferred — add to whichever file contains other scheduled reducers like `tick_effects`)

**Action:** Add the `tick_bard_songs` scheduled reducer. Update `character_logout` in `reducers/characters.ts` to delete temporary items.

**Details:**

**tick_bard_songs reducer** — Add this reducer using `spacetimedb.reducer`:

```typescript
spacetimedb.reducer(
  'tick_bard_songs',
  { arg: BardSongTick.rowType },
  (ctx, { arg }) => {
    const combat = ctx.db.combatEncounter.id.find(arg.combatId);
    if (!combat || combat.state !== 'active') {
      // Combat over — clean up active song rows for this bard
      for (const song of ctx.db.activeBardSong.by_bard.filter(arg.bardCharacterId)) {
        ctx.db.activeBardSong.id.delete(song.id);
      }
      return;
    }

    const bard = ctx.db.character.id.find(arg.bardCharacterId);
    if (!bard) return;

    const songs = [...ctx.db.activeBardSong.by_bard.filter(arg.bardCharacterId)];
    if (songs.length === 0) return;

    const activeSong = songs[0];

    // Apply song effect based on songKey
    const partyMembers = [...ctx.db.combatParticipant.by_combat.filter(arg.combatId)]
      .map(p => ctx.db.character.id.find(p.characterId))
      .filter(Boolean);
    const enemies = [...ctx.db.combatEnemy.by_combat.filter(arg.combatId)]
      .filter(e => e.currentHp > 0n);

    switch (activeSong.songKey) {
      case 'bard_discordant_note':
        // AoE sonic damage to all enemies
        for (const en of enemies) {
          const dmg = 5n + bard.level;
          const nextHp = en.currentHp > dmg ? en.currentHp - dmg : 0n;
          ctx.db.combatEnemy.id.update({ ...en, currentHp: nextHp });
        }
        break;
      case 'bard_melody_of_mending':
        // Group HP regen tick
        for (const member of partyMembers) {
          if (!member) continue;
          const healed = member.hp + 10n > member.maxHp ? member.maxHp : member.hp + 10n;
          ctx.db.character.id.update({ ...member, hp: healed });
        }
        break;
      case 'bard_chorus_of_vigor':
        // Group mana regen tick
        for (const member of partyMembers) {
          if (!member || member.maxMana === 0n) continue;
          const gained = member.mana + 8n > member.maxMana ? member.maxMana : member.mana + 8n;
          ctx.db.character.id.update({ ...member, mana: gained });
        }
        break;
      case 'bard_march_of_wayfarers':
        // Refresh travel discount for all party members (2 rounds)
        for (const member of partyMembers) {
          if (!member) continue;
          addCharacterEffect(ctx, member.id, 'travel_discount', 3n, 2n, 'March of Wayfarers');
        }
        break;
      case 'bard_battle_hymn':
        // AoE damage + party HP + mana regen simultaneously
        for (const en of enemies) {
          const dmg = 6n + bard.level;
          const nextHp = en.currentHp > dmg ? en.currentHp - dmg : 0n;
          ctx.db.combatEnemy.id.update({ ...en, currentHp: nextHp });
        }
        for (const member of partyMembers) {
          if (!member) continue;
          const healed = member.hp + 8n > member.maxHp ? member.maxHp : member.hp + 8n;
          ctx.db.character.id.update({ ...member, hp: healed });
          const freshM = ctx.db.character.id.find(member.id);
          if (freshM && freshM.maxMana > 0n) {
            const gained = freshM.mana + 4n > freshM.maxMana ? freshM.maxMana : freshM.mana + 4n;
            ctx.db.character.id.update({ ...freshM, mana: gained });
          }
        }
        break;
    }

    // If the song was fading, delete it after this tick
    if (activeSong.isFading) {
      ctx.db.activeBardSong.id.delete(activeSong.id);
      return; // No reschedule
    }

    // Reschedule next tick in 6 seconds
    ctx.db.bardSongTick.insert({
      scheduledId: 0n,
      scheduledAt: ScheduleAt.time(ctx.timestamp.microsSinceUnixEpoch + 6_000_000n),
      bardCharacterId: arg.bardCharacterId,
      combatId: arg.combatId,
    });
  }
);
```

The `tick_bard_songs` reducer needs `addCharacterEffect` from helpers/combat.ts. Import it at the top of the file where the reducer is added. Also import `BardSongTick` and `ActiveBardSong` from schema/tables if not already present.

**Temp item logout cleanup** — In `spacetimedb/src/reducers/characters.ts`, inside the `character_logout` reducer (around line 555), add temp item deletion BEFORE the friends loop:

```typescript
spacetimedb.reducer(
  'character_logout',
  { arg: CharacterLogoutTick.rowType },
  (ctx, { arg }) => {
    const character = ctx.db.character.id.find(arg.characterId);
    if (!character) return;
    for (const player of ctx.db.player.iter()) {
      if (player.activeCharacterId === character.id) {
        return;
      }
    }

    // NEW: Delete all temporary items for this character
    for (const instance of ctx.db.itemInstance.by_owner.filter(arg.characterId)) {
      if (instance.isTemporary) {
        ctx.db.itemInstance.id.delete(instance.id);
      }
    }

    const friends = friendUserIds(ctx, arg.ownerUserId);
    for (const friendId of friends) {
      appendPrivateEvent(
        ctx,
        character.id,
        friendId,
        'presence',
        `${character.name} went offline.`
      );
    }
  }
);
```

**Verify:**
1. `grep -n "tick_bard_songs" spacetimedb/src/reducers/combat.ts` (or bard.ts) shows the reducer
2. `grep -n "isTemporary" spacetimedb/src/reducers/characters.ts` shows the logout cleanup
3. TypeScript compiles without errors: `cd spacetimedb && npx tsc --noEmit` (or equivalent build check)

**Done:** `tick_bard_songs` reducer fires every 6 seconds per active bard song, applies effects, and reschedules itself. Temporary items are deleted when their character logs out.

## Verification

1. `grep -rn "bard_discordant_note\|bard_melody_of_mending\|bard_chorus_of_vigor\|bard_march_of_wayfarers\|bard_battle_hymn\|bard_finale" spacetimedb/src/helpers/combat.ts` — all 6 bard cases present
2. `grep -n "tick_bard_songs" spacetimedb/src/` — reducer present
3. `grep -n "isTemporary" spacetimedb/src/reducers/characters.ts` — logout cleanup present
4. No TypeScript compile errors
5. `grep -n "bard_ballad_of_resolve\|bard_echoed_chord\|bard_harmony\|bard_crushing_crescendo\|enchanter_veil_of_calm\|enchanter_slow\|enchanter_clarity_ii\|enchanter_charm_fray\|monk_palm_strike\|druid_bramble\|summoner_conjure_vessel\|summoner_earth_familiar\|summoner_conjured_spike\|summoner_empower\|summoner_spectral_lance\|necromancer_bone_ward\|necromancer_grave_surge\|spellblade_arcane_slash\|spellblade_rune_ward\|spellblade_runic_strike\|spellblade_ward\|spellblade_spellstorm" spacetimedb/src/helpers/combat.ts` — zero matches (all retired cases removed)

## Commit Message
`feat(22-03): add executeAbility cases for all new abilities and bard song tick reducer`
