---
phase: 03.1.3-enemy-ai-and-aggro-management
plan: 02
type: execute
wave: 2
depends_on: ["03.1.3-01"]
files_modified:
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/index.ts
autonomous: true
must_haves:
  truths:
    - "Enemy healers prioritize healing when an ally is below 30% HP (score bonus makes heal top priority)"
    - "Enemy buff abilities are prioritized early in combat (first 10 seconds)"
    - "Enemies reset to spawn and heal to full when combat location differs from spawn location (leash)"
    - "All players in leashed combat receive defeat result and combat ends cleanly"
  artifacts:
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Combat-state-aware AI scoring and leash check"
      contains: "healPriority"
    - path: "spacetimedb/src/index.ts"
      provides: "No new artifacts (index.ts may receive minor adjustments only)"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts AI scoring"
      to: "spacetimedb/src/reducers/combat.ts combat_loop"
      via: "Enhanced score calculation in ability candidate loop"
      pattern: "healPriority|buffEarly"
    - from: "spacetimedb/src/reducers/combat.ts leash check"
      to: "spacetimedb/src/reducers/combat.ts clearCombatArtifacts"
      via: "Leash triggers combat cleanup and enemy reset"
      pattern: "leash|locationId.*spawnLocation"
---

<objective>
Enhance enemy AI scoring with combat-state awareness and add leashing mechanics.

Purpose: Currently enemy AI uses static weights for ability selection — healers don't prioritize healing when allies are dying, and buffers don't prioritize buffs early in combat. Enemies can also be kited indefinitely since there's no leashing mechanic. These gaps make enemies feel unintelligent and allow exploit-free kills via kiting.

Output: Enemy healers heal urgently when allies are low HP, buffers buff early in combat, debuffers target highest-threat players, and enemies leash (reset) when combat moves away from their spawn location.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1.3-enemy-ai-and-aggro-management/03.1.3-RESEARCH.md
@.planning/phases/03.1.3-enemy-ai-and-aggro-management/03.1.3-01-SUMMARY.md
@spacetimedb/src/reducers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add combat-state-aware AI scoring bonuses</name>
  <files>spacetimedb/src/reducers/combat.ts</files>
  <action>
In the combat_loop reducer, locate the enemy AI ability scoring block (around lines 1590-1608). This is inside the `for (const ability of enemyAbilities)` loop, after the existing static scoring:

```typescript
let score = baseWeight;
if (ability.kind === 'dot') score += 30;
if (ability.targetRule === 'lowest_hp') score += 20;
if (ability.targetRule === 'aggro') score += 10;
```

Replace those 4 lines with enhanced combat-state-aware scoring. The new scoring keeps the existing static bonuses and adds dynamic bonuses:

```typescript
let score = baseWeight;

// --- Static bonuses (existing) ---
if (ability.kind === 'dot') score += 30;
if (ability.targetRule === 'lowest_hp') score += 20;
if (ability.targetRule === 'aggro') score += 10;

// --- Dynamic combat-state bonuses (new) ---

// Heal priority: when ANY living ally is below 30% HP, heal abilities get massive priority
if (ability.kind === 'heal') {
  const allies = [...ctx.db.combatEnemy.by_combat.filter(combat.id)]
    .filter((e: any) => e.currentHp > 0n && e.id !== enemy.id);
  const lowestAlly = allies.reduce((low: any, e: any) => {
    const tmpl = ctx.db.enemyTemplate.id.find(e.enemyTemplateId);
    const maxHp = tmpl?.maxHp ?? 100n;
    const hpPercent = (e.currentHp * 100n) / maxHp;
    const lowTmpl = low ? ctx.db.enemyTemplate.id.find(low.enemyTemplateId) : null;
    const lowMaxHp = lowTmpl?.maxHp ?? 100n;
    const lowPercent = low ? (low.currentHp * 100n) / lowMaxHp : 100n;
    return hpPercent < lowPercent ? e : low;
  }, null as any);
  if (lowestAlly) {
    const tmpl = ctx.db.enemyTemplate.id.find(lowestAlly.enemyTemplateId);
    const maxHp = tmpl?.maxHp ?? 100n;
    const hpPercent = Number((lowestAlly.currentHp * 100n) / maxHp);
    if (hpPercent < 30) {
      score += 100;  // Healing becomes top priority when ally below 30% HP
    } else if (hpPercent < 60) {
      score += 40;   // Moderate heal priority when ally below 60% HP
    }
  }
  // Also boost heal priority for self when caster is low HP
  const selfTemplate = ctx.db.enemyTemplate.id.find(enemy.enemyTemplateId);
  const selfMaxHp = selfTemplate?.maxHp ?? 100n;
  const selfHpPercent = Number((enemy.currentHp * 100n) / selfMaxHp);
  if (selfHpPercent < 30) {
    score += 80;  // Self-preservation bonus
  }
}

// Buff priority: buff abilities score higher in early combat (first 10 seconds = 10,000,000 microseconds)
if (ability.kind === 'buff') {
  const combatAge = nowMicros - combat.createdAt;
  if (combatAge < 10_000_000n) {
    score += 50;  // Strong buff priority in opening seconds
  } else if (combatAge < 30_000_000n) {
    score += 20;  // Moderate buff priority in first 30 seconds
  }
}

// Debuff targeting: debuff abilities prefer the highest-threat player (to slow down the tank)
if (ability.kind === 'debuff') {
  const highestThreatEntry = [...ctx.db.aggroEntry.by_combat.filter(combat.id)]
    .filter((e: any) => e.enemyId === enemy.id && !e.petId)
    .sort((a: any, b: any) => a.value > b.value ? -1 : a.value < b.value ? 1 : 0)[0];
  if (highestThreatEntry && highestThreatEntry.characterId === targetId) {
    score += 25;  // Bonus for debuffing the highest-threat target
  }
}
```

**Important notes:**
- `combat.createdAt` is already a field on CombatEncounter. If the field is named differently (e.g., `startedAt`), use that field. Check the CombatEncounter table definition in index.ts to get the correct field name for the combat start timestamp. If no such field exists, use the combat's `id` as a proxy by checking `if (enemies.every(e => e.nextAutoAttackAt <= nowMicros + AUTO_ATTACK_INTERVAL * 3n))` for "early combat" detection.
- The heal scoring uses `ctx.db.combatEnemy.by_combat.filter(combat.id)` to find allies — same pattern used in executeEnemyAbility's heal kind handler.
- Keep the existing jitter/hash randomness code AFTER the new scoring lines (it adds variance on top of the enhanced base score).
  </action>
  <verify>
Run `spacetime build --project-path spacetimedb` to verify compilation. Grep for `healPriority\|below 30\|Buff priority\|Debuff targeting\|buff priority\|heal priority\|Self-preservation` in combat.ts to confirm all three dynamic scoring bonuses are present.
  </verify>
  <done>
Enemy AI scoring is combat-state-aware: heal abilities get +100 score when any ally is below 30% HP (or +40 below 60%), buff abilities get +50 in first 10 seconds of combat (or +20 in first 30 seconds), debuff abilities get +25 when targeting the highest-threat player. The jitter randomness still applies on top of enhanced scores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add leashing mechanics for combat reset</name>
  <files>spacetimedb/src/reducers/combat.ts</files>
  <action>
Leashing prevents kiting exploits. In this game, combat is location-based (each CombatEncounter has a locationId, and enemies have a spawn locationId). When the combat's location no longer matches the spawn's location, enemies should leash (reset).

However, reviewing the combat system: players don't move locations during combat (combat is location-locked). The real leash scenario is: if all players flee combat (leave the location via travel), enemies should reset. The existing system already handles this partially — `leave_combat` reducer exists, and combat ends when no active participants remain.

**What actually needs implementation:** When all remaining active participants leave combat (via `leave_combat` or travel), the combat should end with enemies resetting to full HP at their spawn. Currently the `stillActive` check at the bottom of `combat_loop` (around line 2243-2252) handles the "all dead" case. We need to also handle the "all fled" case similarly.

Locate the `combat_loop` reducer's participant-death check block (around line 2243, `let stillActive = false`). This block already checks if any active participant has HP > 0. Review what happens when all active participants have left — the `activeParticipants` list will be empty, and the `stillActive` check will naturally trigger defeat. But the enemies should reset to full HP (not remain damaged) and the defeat should say "evade" not "defeat".

Add a leash/evade check at the **beginning** of the combat_loop reducer, right after the `activeParticipants` filter (after line 1449, `const activeParticipants = refreshedParticipants.filter(...)`):

```typescript
// Leash check: if no active participants remain in combat, enemies evade and reset
if (activeParticipants.length === 0) {
  // Reset all enemies to full HP
  for (const enemyRow of enemies) {
    const tmpl = ctx.db.enemyTemplate.id.find(enemyRow.enemyTemplateId);
    if (tmpl) {
      ctx.db.combatEnemy.id.update({ ...enemyRow, currentHp: tmpl.maxHp });
    }
  }

  // Return enemies to spawn
  const spawnIds = new Set(enemies.map((e: any) => e.spawnId));
  for (const spawnId of spawnIds) {
    const spawn = ctx.db.enemySpawn.id.find(spawnId);
    if (spawn) {
      // Reconstruct spawn members from surviving enemies
      for (const member of ctx.db.enemySpawnMember.by_spawn.filter(spawnId)) {
        ctx.db.enemySpawnMember.id.delete(member.id);
      }
      let count = 0n;
      for (const enemyRow of enemies) {
        if (enemyRow.spawnId !== spawnId) continue;
        if (enemyRow.enemyRoleTemplateId) {
          ctx.db.enemySpawnMember.insert({
            id: 0n,
            spawnId: spawnId,
            enemyTemplateId: enemyRow.enemyTemplateId,
            roleTemplateId: enemyRow.enemyRoleTemplateId,
          });
          count += 1n;
        }
      }
      ctx.db.enemySpawn.id.update({
        ...spawn,
        state: 'available',
        lockedCombatId: undefined,
        groupCount: count > 0n ? count : spawn.groupCount,
      });
    }
  }

  // Log evade message to all participants (even dead ones)
  for (const p of participants) {
    const character = ctx.db.character.id.find(p.characterId);
    if (!character) continue;
    appendPrivateEvent(
      ctx,
      character.id,
      character.ownerUserId,
      'combat',
      `The enemies lose interest and return to their posts.`
    );
  }

  // Clean up combat
  clearCombatArtifacts(ctx, combat.id);
  ctx.db.combatEncounter.id.update({ ...combat, state: 'resolved' });
  return;
}
```

This leash check runs BEFORE enemy abilities, auto-attacks, or any other combat processing. If all participants are dead or fled, enemies evade — returning to spawn at full HP with their spawn state reset to 'available'.

**Note:** The existing `stillActive` check at the bottom (line 2252) handles the TPK case where participants die MID-tick. The new check handles the case where participants left BETWEEN ticks (via leave_combat or travel). Both are needed.
  </action>
  <verify>
Run `spacetime build --project-path spacetimedb` to verify compilation. Grep for `lose interest\|leash\|evade` in combat.ts to confirm the leash check is present. Grep for `activeParticipants.length === 0` to confirm the early-exit check exists.
  </verify>
  <done>
Enemies evade and reset to full HP when all players leave combat (flee or die between ticks). Spawn state is restored to 'available'. Log message "The enemies lose interest and return to their posts." is sent to all participants. Combat artifacts are cleaned up. No kiting exploit possible — enemies fully heal on reset.
  </done>
</task>

</tasks>

<verification>
1. `spacetime build --project-path spacetimedb` compiles without errors
2. Enemy healers score heal abilities at +100 when ally below 30% HP
3. Enemy buffers score buff abilities at +50 in first 10 seconds of combat
4. Enemy debuffers score debuff abilities at +25 when targeting highest-threat player
5. Leash check triggers when activeParticipants.length === 0 at start of combat_loop tick
6. Leashed enemies reset to full HP and spawn returns to 'available' state
7. Evade message logged to all combat participants
</verification>

<success_criteria>
Enemy AI makes contextually intelligent decisions: healers heal dying allies, buffers buff early, debuffers target tanks. Enemies cannot be kited — they evade and fully reset when all players leave combat. Both improvements apply to all existing enemy types without per-enemy configuration changes.
</success_criteria>

<output>
After completion, create `.planning/phases/03.1.3-enemy-ai-and-aggro-management/03.1.3-02-SUMMARY.md`
</output>
