# Phase 03.1.3: Enemy AI and aggro management - Research

**Researched:** 2026-02-13
**Domain:** MMO combat AI, threat/aggro systems, enemy decision-making
**Confidence:** HIGH

## Summary

This phase extends the combat balance foundation with intelligent enemy AI behavior and threat management. The codebase already has a functional aggro system (AggroEntry table with damage-based threat accumulation) and basic AI ability selection (weighted scoring with targetRule support). What's missing are: (1) threat modifiers for tanks/healers beyond raw damage, (2) smarter ability selection tied to combat state (low HP = heal priority), (3) social aggro mechanics (linked enemies assisting), and (4) leashing/reset behavior when players escape combat range.

The research reveals that modern MMOs use weighted utility scoring for AI decisions (already partially implemented) and damage + role-based threat tables. WoW-style systems generate threat from damage dealt (100% for DPS, 150-200% for tanks with high-threat abilities) and healing (50% split across all enemies). The existing `AggroEntry.value` tracks per-enemy threat per character/pet, and enemies auto-attack highest threat targets.

**Primary recommendation:** Extend the existing AI scoring system with combat-state awareness (heal when ally below 30% HP, buff when fresh, debuff priority targets), add threat modifiers for tank abilities and healing, implement social aggro (nearby allies join combat when triggered), and add leashing (enemies reset if pulled too far from spawn). No architectural changes needed — the foundation is solid.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SpacetimeDB | 1.11.x | Game state & reducers | Project foundation, handles all persistence |
| TypeScript | 5.x | Server module language | Required for SpacetimeDB backend |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| None | N/A | Pure game logic | AI is implemented directly in combat reducer |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Weighted scoring | Behavior trees | More complex; overkill for turn-based system |
| Damage-based threat | GOAP planning | Too heavyweight; threat is deterministic |

**Installation:**
No additional packages required. All logic implemented in existing SpacetimeDB module.

## Architecture Patterns

### Recommended Project Structure
Current structure is appropriate:
```
spacetimedb/src/
├── reducers/
│   └── combat.ts              # combat_loop reducer (AI lives here)
├── data/
│   ├── ability_catalog.ts     # ENEMY_ABILITIES with AI metadata
│   └── combat_scaling.ts      # Threat multipliers, AI constants
└── index.ts                   # AggroEntry table definition
```

### Pattern 1: Weighted Utility Scoring for AI Decisions
**What:** Assign numerical weights to each ability based on situation, sort by weight, apply chance roll to highest-weighted option.
**When to use:** Enemy ability selection in combat (already partially implemented).
**Example:**
```typescript
// From existing combat.ts (lines 1590-1612)
const baseWeight = meta?.aiWeight ?? DEFAULT_AI_WEIGHT;
let score = baseWeight;
if (ability.kind === 'dot') score += 30;
if (ability.targetRule === 'lowest_hp') score += 20;
if (ability.targetRule === 'aggro') score += 10;

// NEW: Add combat-state awareness
const target = ctx.db.character.id.find(targetId);
if (ability.kind === 'heal' && target && target.hp < target.maxHp * 0.3) {
  score += 100; // Healing becomes top priority when ally below 30% HP
}
if (ability.kind === 'buff' && nowMicros - combat.startedAt < 10_000_000n) {
  score += 50; // Buff priority in first 10 seconds of combat
}

candidates.push({ ability, targetId, score, castMicros, cooldownMicros, chance: baseChance });
const chosen = candidates.sort((a, b) => b.score - a.score)[0];
```

### Pattern 2: Damage + Role-Based Threat Table
**What:** Track threat (aggro value) per enemy per character. Damage generates threat at role-specific multipliers. Highest threat target is attacked.
**When to use:** Group combat with tank/healer/DPS roles (already implemented, needs extension).
**Example:**
```typescript
// Existing: AggroEntry table (index.ts lines 1012-1028)
const AggroEntry = table({
  name: 'aggro_entry',
  indexes: [
    { name: 'by_combat', algorithm: 'btree', columns: ['combatId'] },
    { name: 'by_enemy', algorithm: 'btree', columns: ['enemyId'] },
  ],
}, {
  id: t.u64().primaryKey().autoInc(),
  combatId: t.u64(),
  enemyId: t.u64(),
  characterId: t.u64(),
  petId: t.u64().optional(),
  value: t.u64(),  // Current threat value
});

// Current implementation (combat.ts lines 1708-1713)
// Damage adds threat 1:1
for (const entry of ctx.db.aggroEntry.by_combat.filter(combat.id)) {
  if (entry.characterId === character.id && entry.enemyId === currentEnemy.id) {
    ctx.db.aggroEntry.id.update({ ...entry, value: entry.value + finalDamage });
    break;
  }
}

// EXTEND: Add threat modifiers
// Tank abilities: damage * 2.0 (high-threat stance)
// DPS damage: damage * 1.0 (baseline)
// Healing: healing * 0.5 split across all enemies in combat
const threatMultiplier = getThreatMultiplier(character, abilityKey);
const threatGenerated = finalDamage * threatMultiplier;
```

### Pattern 3: Social Aggro (Linked Enemies)
**What:** When one enemy in a social group enters combat, nearby allies of the same social group join automatically.
**When to use:** Enemies with `socialGroup` and `socialRadius` fields (template already has these fields).
**Example:**
```typescript
// Existing fields in EnemyTemplate (index.ts lines 629-630)
socialGroup: t.string(),
socialRadius: t.u64(),

// NEW: Social aggro trigger in combat_loop
// When enemy takes damage, check for allies within socialRadius at same location
function triggerSocialAggro(ctx, enemy, combat) {
  const template = ctx.db.enemyTemplate.id.find(enemy.enemyTemplateId);
  if (!template || !template.socialGroup) return;

  const spawn = ctx.db.enemySpawn.id.find(enemy.spawnId);
  if (!spawn) return;

  // Find nearby spawns with same socialGroup
  const allies = [...ctx.db.enemySpawn.by_location.filter(spawn.locationId)]
    .filter(s => s.state === 'available')
    .filter(s => {
      const t = ctx.db.enemyTemplate.id.find(s.enemyTemplateId);
      return t && t.socialGroup === template.socialGroup;
    });

  // Add allies to combat
  for (const ally of allies) {
    addEnemyToCombat(ctx, combat.id, ally.id);
  }
}
```

### Pattern 4: Leashing and Combat Reset
**What:** If player moves too far from enemy spawn point, enemy breaks aggro, evades, and returns to spawn at full HP.
**When to use:** Prevent kiting exploits and define combat boundaries.
**Example:**
```typescript
// NEW: Leash check in combat_loop
const LEASH_DISTANCE = 100; // Units from spawn point

for (const enemy of enemies) {
  const spawn = ctx.db.enemySpawn.id.find(enemy.spawnId);
  if (!spawn) continue;

  // Calculate distance from spawn location
  const spawnLocation = ctx.db.location.id.find(spawn.locationId);
  const combatLocation = ctx.db.location.id.find(combat.locationId);

  // If combat moved too far from spawn, enemy leashes
  if (spawnLocation && combatLocation && spawnLocation.id !== combatLocation.id) {
    // Enemy evades and resets
    ctx.db.combatEnemy.id.update({
      ...enemy,
      currentHp: enemy.maxHp, // Full heal
    });
    // Remove from combat (return to spawn handled by combat end logic)
  }
}
```

### Anti-Patterns to Avoid
- **Random ability selection:** Don't use pure random rolls without weights — leads to nonsensical behavior (healer spamming damage when ally is dying).
- **Global threat table:** Don't make threat shared across all enemies — each enemy maintains its own threat list (already correctly implemented).
- **Instant social aggro:** Don't pull entire zone on first hit — respect `socialRadius` limits and `awareness` levels.
- **No leashing:** Don't allow infinite kiting — enemies must reset when pulled too far.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| AI decision trees | Custom behavior tree library | Weighted utility scoring | Turn-based combat doesn't need full BT overhead; weighted scoring is simpler and sufficient |
| Pathfinding for leashing | A* pathfinding | Distance check + instant teleport | Enemies evade and instantly reset to spawn; no need to path back |
| Threat prediction | ML-based threat forecasting | Simple role multipliers (tank 2x, healer 0.5x) | Deterministic threat is easier to balance and debug |

**Key insight:** Combat is turn-based (scheduled reducer fires every 200ms), not real-time action. AI only needs to pick "best ability right now" not "optimal 10-turn sequence". Weighted scoring with situational bonuses is the right tool.

## Common Pitfalls

### Pitfall 1: DoT/Debuff Spam
**What goes wrong:** Enemy reapplies DoT every turn even when already active, wasting turns.
**Why it happens:** No check for existing effects before adding to candidate pool.
**How to avoid:** Already implemented (combat.ts lines 1578-1588) — skip abilities if effect already present on target.
**Warning signs:** Combat logs show "Enemy casts Poison Bite" 5 turns in a row on same target.

### Pitfall 2: Healer Ignoring Dying Allies
**What goes wrong:** Healer uses damage abilities while ally is at 10% HP.
**Why it happens:** Static `aiWeight` doesn't adjust for combat state.
**How to avoid:** Add dynamic weight bonuses based on target HP percentage (healing gets +100 weight when ally below 30% HP).
**Warning signs:** Enemy healer never heals in playtesting; group wipes easily.

### Pitfall 3: Threat Reset on Death
**What goes wrong:** When character dies, their AggroEntry rows persist with stale threat values.
**Why it happens:** No cleanup of threat on character death.
**How to avoid:** Delete AggroEntry rows for dead characters in combat_loop.
**Warning signs:** Dead characters still show as "top threat" in debug logs.

### Pitfall 4: Social Aggro Infinite Loop
**What goes wrong:** Enemy A pulls enemy B, which triggers social aggro that pulls enemy C, which pulls D, etc., until entire zone is in one combat.
**Why it happens:** Social aggro check has no distance limit or already-in-combat check.
**How to avoid:** Check `spawn.state !== 'available'` before adding to combat, respect `socialRadius` distance limit.
**Warning signs:** Player pulls one enemy, 20 enemies appear in combat.

### Pitfall 5: Leash Exploitation
**What goes wrong:** Player runs away to reset enemy HP, returns, repeats until enemy is chipped down with zero risk.
**Why it happens:** No penalty for leashing or no threat memory after reset.
**How to avoid:** Option 1: Full combat reset (all participants return to spawn, combat deleted). Option 2: Leash grants enemy full HP but combat continues if any player is still in range.
**Warning signs:** Players exploit leashing in playtesting to kill bosses without engaging mechanics.

## Code Examples

Verified patterns from existing codebase:

### Aggro Initialization (Combat Start)
```typescript
// From combat.ts lines 98-106
for (const p of participants) {
  ctx.db.aggroEntry.insert({
    id: 0n,
    combatId: combat.id,
    enemyId: combatEnemy.id,
    characterId: p.characterId,
    petId: undefined,
    value: 0n, // Start at zero threat
  });
}
```

### Threat-Based Target Selection
```typescript
// From combat.ts lines 2070-2091
const activeIds = new Set(activeParticipants.map((p) => p.characterId));
for (const enemy of enemies) {
  let topAggro: typeof deps.AggroEntry.rowType | null = null;
  let topPet: typeof deps.CombatPet.rowType | null = null;
  for (const entry of ctx.db.aggroEntry.by_combat.filter(combat.id)) {
    if (entry.enemyId !== enemy.id) continue;
    if (entry.petId) {
      const pet = ctx.db.combatPet.id.find(entry.petId);
      if (!pet || pet.currentHp === 0n) continue;
      if (!topAggro || entry.value > topAggro.value) {
        topAggro = entry;
        topPet = pet;
      }
      continue;
    }
    if (!activeIds.has(entry.characterId)) continue;
    if (!topAggro || entry.value > topAggro.value) {
      topAggro = entry;
      topPet = null;
    }
  }
  // Enemy attacks topAggro target
}
```

### AI Ability Scoring
```typescript
// From combat.ts lines 1590-1612
const baseWeight = meta?.aiWeight ?? DEFAULT_AI_WEIGHT;
const baseChance = meta?.aiChance ?? DEFAULT_AI_CHANCE;
const randomness = meta?.aiRandomness ?? DEFAULT_AI_RANDOMNESS;
let score = baseWeight;
if (ability.kind === 'dot') score += 30;
if (ability.targetRule === 'lowest_hp') score += 20;
if (ability.targetRule === 'aggro') score += 10;

const hash = hashString(`${ability.abilityKey}:${combat.id}:${enemy.id}`);
const jitter = (hash % (randomness * 2)) - randomness;
score += jitter;
candidates.push({
  ability,
  targetId,
  score,
  castMicros,
  cooldownMicros,
  chance: baseChance,
});

// Pick highest score, apply chance roll
const chosen = candidates.sort((a, b) => b.score - a.score)[0];
const roll = Number((nowMicros + enemy.id + combat.id + BigInt(hashString(chosen.ability.abilityKey))) % 100n);
if (roll < chosen.chance) {
  // Cast ability
}
```

### Social Aggro During Pull
```typescript
// From combat.ts lines 766-786
const targetGroup = (template.socialGroup || template.creatureType || '').trim().toLowerCase();
const candidates = PULL_ALLOW_EXTERNAL_ADDS
  ? [...ctx.db.enemySpawn.by_location.filter(pull.locationId)]
    .filter((row) => row.id !== spawn.id && row.state === 'available')
    .map((row) => ({
      spawn: row,
      template: ctx.db.enemyTemplate.id.find(row.enemyTemplateId),
    }))
    .filter(
      (row) =>
        row.template &&
        (row.template.socialGroup || row.template.creatureType || '').trim().toLowerCase() === targetGroup
    )
  : [];

const targetRadius = Number(template.socialRadius ?? 0n);
const overlapPressure = targetRadius + candidates.length;
// Pull difficulty increases with social pressure
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Random ability selection | Weighted utility scoring | Industry standard since ~2010 | Enemies feel intelligent, not chaotic |
| Fixed threat on all actions | Role-based threat multipliers | WoW Classic (2004+) | Tank/healer/DPS roles function correctly |
| Single-target aggro only | Multi-target threat tables | EverQuest 2 (2004+) | Group combat works; tanks can manage multiple enemies |
| No leashing | Distance-based leash + reset | WoW Vanilla (2004+) | Prevents kiting exploits, defines combat zones |

**Deprecated/outdated:**
- **Pure damage-based threat:** Modern games add role multipliers (this project already has the table, just needs multipliers).
- **No social aggro:** Solo design; multiplayer MMOs need linked enemies to create tactical complexity.
- **Unlimited kiting:** Enemies must leash to prevent exploits.

## Open Questions

1. **Should taunt abilities exist in the player ability catalog?**
   - What we know: Tank classes exist (warrior, paladin), but no explicit "taunt" abilities defined in ABILITIES catalog.
   - What's unclear: Whether Phase 03.1.3 should add taunt mechanics or defer to future phase.
   - Recommendation: Start with passive threat multipliers (tank abilities generate 2x threat). Add explicit taunt reducer in follow-up phase if needed.

2. **How should threat decay over time (if at all)?**
   - What we know: WoW has no passive threat decay; Guild Wars 2 uses time-based decay.
   - What's unclear: Whether this project wants static threat tables or decay mechanics.
   - Recommendation: No decay for v1 (simpler, easier to debug). Combat ends when all enemies or all players are dead.

3. **Should social aggro trigger mid-combat or only during pull?**
   - What we know: Pull system already has social aggro for initial engagement.
   - What's unclear: Whether nearby enemies should join ongoing combat (e.g., if party AoEs and damages a nearby pack).
   - Recommendation: Pull-only for v1. Mid-combat social aggro adds complexity and can feel punishing.

4. **What should happen when all players in combat die?**
   - What we know: Combat system tracks participant status.
   - What's unclear: Respawn mechanics, corpse runs, death penalties (not in scope).
   - Recommendation: Combat ends, all AggroEntry rows deleted, enemies reset to spawn. Defer respawn to future phase.

## Sources

### Primary (HIGH confidence)
- Existing codebase: `spacetimedb/src/reducers/combat.ts` (AggroEntry usage, AI scoring, social aggro during pull)
- Existing codebase: `spacetimedb/src/index.ts` (AggroEntry table schema, EnemyTemplate fields)
- Existing codebase: `spacetimedb/src/data/ability_catalog.ts` (ENEMY_ABILITIES with AI metadata)

### Secondary (MEDIUM confidence)
- [Hate (video games) - Wikipedia](https://en.wikipedia.org/wiki/Hate_(video_games)) - MMO threat/aggro definitions
- [Threat and Aggro Management in WoW Classic - Wowhead](https://www.wowhead.com/classic/guide/threat-overview-classic-wow) - WoW threat mechanics
- [Taunt, threat, and the inevitability of a tanking disaster - Blizzard Watch](https://blizzardwatch.com/2018/09/25/taunt-threat-inevitability-disaster/) - Taunt ability design
- [Intelligence in turn based RPG combat - Game Developer](https://www.gamedeveloper.com/programming/intelligence-in-turn-based-rpg-combat) - AI ability selection patterns
- [Game AI Planning: GOAP, Utility, and Behavior Trees - Tono Game Consultants](https://tonogameconsultants.com/game-ai-planning/) - AI architecture overview
- [Leash - Wowpedia](https://wowpedia.fandom.com/wiki/Leash) - Leashing mechanics
- [Damager, Healer, Tank - TV Tropes](https://tvtropes.org/pmwiki/pmwiki.php/Main/DamagerHealerTank) - Holy Trinity roles

### Tertiary (LOW confidence)
- [RPG combat: Tanks, threat and aggro, oh my - Engadget](https://www.engadget.com/2012-09-12-tanks-threat-and-aggro-oh-my.html) - Threat system overview (2012, dated)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries needed, pure game logic in existing combat reducer
- Architecture: HIGH - Patterns verified against existing codebase, all examples from live code
- Pitfalls: MEDIUM - Based on MMO design knowledge and existing code review; needs playtesting to verify

**Research date:** 2026-02-13
**Valid until:** 60 days (stable domain; MMO combat patterns haven't changed significantly in 15+ years)
