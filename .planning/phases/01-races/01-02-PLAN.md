---
phase: 01-races
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/composables/useGameData.ts
  - src/composables/useCharacterCreation.ts
  - src/components/CharacterPanel.vue
  - src/App.vue
autonomous: false

must_haves:
  truths:
    - "Race picker dropdown shows 4 unlocked races in character creation form"
    - "Selecting a race shows its description and stat bonuses below the dropdown"
    - "Class dropdown filters to only classes allowed by the selected race"
    - "Selecting a race that invalidates the current class selection clears the class"
    - "Creating a character sends raceId (bigint) to the createCharacter reducer"
    - "Character list displays race name from the Character row"
  artifacts:
    - path: "src/composables/useGameData.ts"
      provides: "races reactive data from useTable(tables.race)"
      contains: "tables.race"
    - path: "src/composables/useCharacterCreation.ts"
      provides: "Updated newCharacter shape with raceId, class filtering logic"
      contains: "raceId"
    - path: "src/components/CharacterPanel.vue"
      provides: "Race picker dropdown, race info display, filtered class dropdown"
      contains: "selectedRace"
    - path: "src/App.vue"
      provides: "Passes races prop to CharacterPanel"
      contains: "races"
  key_links:
    - from: "src/composables/useGameData.ts"
      to: "src/module_bindings"
      via: "useTable(tables.race)"
      pattern: "useTable\\(tables\\.race\\)"
    - from: "src/composables/useCharacterCreation.ts"
      to: "reducers.createCharacter"
      via: "raceId: BigInt(newCharacter.value.raceId)"
      pattern: "raceId.*BigInt"
    - from: "src/components/CharacterPanel.vue"
      to: "src/composables/useGameData.ts"
      via: "races prop passed from App.vue"
      pattern: "races.*RaceRow"
    - from: "src/components/CharacterPanel.vue"
      to: "CLASS_OPTIONS filtering"
      via: "computed filteredClassOptions based on selectedRace.availableClasses"
      pattern: "filteredClass"
---

<objective>
Wire the Race table data into the Vue frontend: race picker dropdown in character creation, class filtering by race, and updated reducer call with raceId.

Purpose: Completes the user-facing race selection flow. Players see unlocked races, pick one, see only valid classes for that race, and create characters with racial stat bonuses applied server-side.

Output: Working race picker UI in CharacterPanel, filtered class dropdown, and updated createCharacter call sending raceId.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-races/01-RESEARCH.md
@.planning/phases/01-races/01-01-SUMMARY.md
@src/composables/useGameData.ts
@src/composables/useCharacterCreation.ts
@src/components/CharacterPanel.vue
@src/App.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add races to useGameData and update useCharacterCreation</name>
  <files>src/composables/useGameData.ts, src/composables/useCharacterCreation.ts</files>
  <action>
**Modify `src/composables/useGameData.ts`:**

1. Add race subscription — After the existing `useTable` calls (e.g., after line 54 `const [worldState] = useTable(tables.worldState);`), add:
   ```typescript
   const [races] = useTable(tables.race);
   ```
   Note: `useTable` returns a tuple `[rows, isLoading]` — we only need the rows.

2. Add `races` to the returned object — In the return statement (line 58), add `races,` alongside the other data.

**Modify `src/composables/useCharacterCreation.ts`:**

1. **Add races to the args type** — At line 6-12, add `races: Ref<RaceRow[]>` to the `UseCharacterCreationArgs` type. Import `RaceRow` from `'../module_bindings'` (it will be available in the generated bindings as the Row type for the race table — check the actual generated type name; it may be `RaceRow` or similar).

2. **Change newCharacter shape** — At line 23, change:
   ```typescript
   const newCharacter = ref({ name: '', race: '', className: '' });
   ```
   to:
   ```typescript
   const newCharacter = ref({ name: '', raceId: '', className: '' });
   ```

3. **Update isCharacterFormValid** — At line 28-34, change `newCharacter.value.race.trim()` to `newCharacter.value.raceId` (raceId is a string representation of the bigint ID, so check it's non-empty):
   ```typescript
   const isCharacterFormValid = computed(() =>
     Boolean(
       newCharacter.value.name.trim() &&
         newCharacter.value.raceId &&
         newCharacter.value.className.trim()
     )
   );
   ```

4. **Update createCharacter function** — At line 52-56, change the reducer call from:
   ```typescript
   createCharacterReducer({
     name: newCharacter.value.name.trim(),
     race: newCharacter.value.race.trim(),
     className: newCharacter.value.className.trim(),
   });
   ```
   to:
   ```typescript
   createCharacterReducer({
     name: newCharacter.value.name.trim(),
     raceId: BigInt(newCharacter.value.raceId),
     className: newCharacter.value.className.trim(),
   });
   ```

5. **Update reset after create** — At line 57, change:
   ```typescript
   newCharacter.value = { name: '', race: '', className: '' };
   ```
   to:
   ```typescript
   newCharacter.value = { name: '', raceId: '', className: '' };
   ```

6. **Fix the error reset line too** — At line 47 and 62, anywhere `newCharacter.value` is spread-reset, ensure `raceId` is used instead of `race`.

7. **Add a `selectedRaceRow` computed** — This is useful for the component:
   ```typescript
   const selectedRaceRow = computed(() => {
     if (!newCharacter.value.raceId) return null;
     const id = BigInt(newCharacter.value.raceId);
     return races.value.find((r: any) => r.id === id) ?? null;
   });
   ```

8. **Add a `filteredClassOptions` computed** — Returns class names allowed by the selected race. **CRITICAL:** The sentinel for "all classes allowed" is empty string `''`, NOT `'all'`. The backend `isClassAllowed()` function uses `if (!allowedClasses || allowedClasses.trim().length === 0) return true;` — the client MUST match this logic:
   ```typescript
   const filteredClassOptions = computed(() => {
     const race = selectedRaceRow.value;
     if (!race) return [];
     const allowed = race.availableClasses;
     if (!allowed || allowed.trim() === '') {
       return null; // null means all classes allowed (Human race uses empty string)
     }
     const list = allowed.split(',').map((c: string) => c.trim().toLowerCase()).filter(Boolean);
     return list;
   });
   ```
   Do NOT check for `allowed.trim().toLowerCase() === 'all'` — the backend never uses `'all'` as a sentinel. Empty string is the correct "allow all" indicator.

9. **Return new computed properties** — Add `selectedRaceRow` and `filteredClassOptions` to the return object.
  </action>
  <verify>
Check useGameData.ts:
- Contains `const [races] = useTable(tables.race);`
- `races` is in the return object

Check useCharacterCreation.ts:
- `newCharacter` ref uses `raceId` not `race`
- `createCharacterReducer` call includes `raceId: BigInt(...)`
- `selectedRaceRow` computed exists
- `filteredClassOptions` computed exists
- `filteredClassOptions` checks `!allowed || allowed.trim() === ''` for "all classes" (NOT `=== 'all'`)
- Both are in the return object

Run `npx tsc --noEmit` (or check if Vite dev server shows no errors).
  </verify>
  <done>
useGameData returns `races` from `useTable(tables.race)`. useCharacterCreation uses `raceId` instead of `race`, sends `BigInt(raceId)` to the reducer, exposes `selectedRaceRow` and `filteredClassOptions` computeds. The "all classes" sentinel correctly checks for empty string, matching the backend's `isClassAllowed()` function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace race text input with race picker and add class filtering to CharacterPanel</name>
  <files>src/components/CharacterPanel.vue, src/App.vue</files>
  <action>
**Modify `src/App.vue`:**

1. **Destructure races from useGameData** — Find where `useGameData()` is destructured (around line 700-710) and add `races` to the destructured list. The `races` data comes from `useGameData()` which already returns it after Task 1.

2. **Destructure selectedRaceRow and filteredClassOptions from useCharacterCreation** — Find where `useCharacterCreation(...)` return value is destructured (around line 738) and add `selectedRaceRow` and `filteredClassOptions` to the destructured list.

3. **CRITICAL: Pass `races` to the `useCharacterCreation()` call** — The `useCharacterCreation()` call at approximately line 743 currently passes an object like `{ characters, conn, createCharacterReducer, deleteCharacterReducer, activeCharId }`. You MUST add `races` to this argument object so the composable can use it for `selectedRaceRow` and `filteredClassOptions` computeds:
   ```typescript
   const { ..., selectedRaceRow, filteredClassOptions } = useCharacterCreation({
     characters,
     conn,
     createCharacterReducer,
     deleteCharacterReducer,
     activeCharId,
     races,  // <-- ADD THIS
   });
   ```
   Without this, the `races` ref inside useCharacterCreation will be undefined, breaking class filtering entirely.

4. **Pass races, selectedRaceRow, filteredClassOptions to CharacterPanel** — Find the `<CharacterPanel>` usage at line 125-141. Add the new props:
   ```html
   <CharacterPanel
     ...existing props...
     :races="races"
     :selected-race-row="selectedRaceRow"
     :filtered-class-options="filteredClassOptions"
   />
   ```

5. **Update the update:newCharacter event handler** — At line 134, the current handler is:
   ```html
   @update:newCharacter="newCharacter = $event"
   ```
   This should still work since `newCharacter` is a ref — the shape just changed from `{name, race, className}` to `{name, raceId, className}`.

**Modify `src/components/CharacterPanel.vue`:**

1. **Update props type** — At line 83-91, change the props interface:
   - Change `newCharacter: { name: string; race: string; className: string }` to `newCharacter: { name: string; raceId: string; className: string }`
   - Add `races: any[]` (the RaceRow type from generated bindings — use `any[]` or import `RaceRow` from `'../module_bindings'`)
   - Add `selectedRaceRow: any | null`
   - Add `filteredClassOptions: string[] | null` (null = all classes allowed)

2. **Update emit type** — At line 93-98, change the `update:newCharacter` emit type to match the new shape: `{ name: string; raceId: string; className: string }`.

3. **Replace the race text input** — At lines 14-21, replace the `<input type="text" placeholder="Race">` with a `<select>` dropdown:
   ```html
   <select
     :value="newCharacter.raceId"
     :disabled="!connActive"
     :style="styles.input"
     @change="onRaceChange"
   >
     <option value="">Select Race</option>
     <option
       v-for="race in unlockedRaces"
       :key="race.id.toString()"
       :value="race.id.toString()"
     >
       {{ race.name }}
     </option>
   </select>
   ```

4. **Add race info display** — Below the race dropdown, add a div showing the selected race's description and stat bonuses:
   ```html
   <div v-if="selectedRaceRow" :style="styles.roster">
     <div>{{ selectedRaceRow.description }}</div>
     <div :style="styles.subtle">
       <span v-if="selectedRaceRow.strBonus > 0n">STR +{{ selectedRaceRow.strBonus }} </span>
       <span v-if="selectedRaceRow.dexBonus > 0n">DEX +{{ selectedRaceRow.dexBonus }} </span>
       <span v-if="selectedRaceRow.chaBonus > 0n">CHA +{{ selectedRaceRow.chaBonus }} </span>
       <span v-if="selectedRaceRow.wisBonus > 0n">WIS +{{ selectedRaceRow.wisBonus }} </span>
       <span v-if="selectedRaceRow.intBonus > 0n">INT +{{ selectedRaceRow.intBonus }} </span>
     </div>
     <div v-if="selectedRaceRow.availableClasses && selectedRaceRow.availableClasses.trim() !== ''" :style="styles.subtle">
       Classes: {{ selectedRaceRow.availableClasses }}
     </div>
   </div>
   ```
   Note: The "Classes:" line should display when `availableClasses` is a non-empty string (meaning restricted classes). When it's empty string (Human), it means all classes are allowed, so we hide that line.

5. **Filter class options** — At line 29 in the class `<select>`, change `CLASS_OPTIONS` to `displayedClassOptions`:
   ```html
   <option v-for="option in displayedClassOptions" :key="option.name" :value="option.name">
     {{ option.name }}
   </option>
   ```

6. **Add computed properties in script** — In the `<script setup>` section:

   a. `unlockedRaces` computed — filters to only unlocked races:
   ```typescript
   const unlockedRaces = computed(() =>
     props.races.filter((r: any) => r.unlocked)
   );
   ```

   b. `displayedClassOptions` computed — filters CLASS_OPTIONS based on `filteredClassOptions` prop:
   ```typescript
   const displayedClassOptions = computed(() => {
     if (!props.filteredClassOptions) return CLASS_OPTIONS; // null = all allowed
     return CLASS_OPTIONS.filter((opt) =>
       props.filteredClassOptions!.includes(opt.name.toLowerCase())
     );
   });
   ```

7. **Replace `onRaceInput` with `onRaceChange`** — At line 105-108, replace the handler:
   ```typescript
   const onRaceChange = (event: Event) => {
     const value = (event.target as HTMLSelectElement).value;
     const updated = { ...props.newCharacter, raceId: value };
     // If the currently selected class is no longer valid for the new race, clear it
     if (updated.className && props.filteredClassOptions) {
       // We need to check against the NEW race's allowed classes
       // The parent will recompute filteredClassOptions after we emit, but we can
       // do a quick check here using the races prop
       const newRace = props.races.find((r: any) => r.id.toString() === value);
       if (newRace) {
         const allowed = newRace.availableClasses;
         if (allowed && allowed.trim() !== '') {
           const list = allowed.split(',').map((c: string) => c.trim().toLowerCase());
           if (!list.includes(updated.className.toLowerCase())) {
             updated.className = '';
           }
         }
       }
     }
     emit('update:newCharacter', updated);
   };
   ```
   Note: The check for "all classes allowed" uses `allowed && allowed.trim() !== ''` — if `availableClasses` is empty string, the class is always valid and we skip the clearing logic.

8. **Clean up** — Remove the old `onRaceInput` function. The character list display at line 63 already uses `character.race` which is still a string on the Character row — no change needed there.

IMPORTANT: The `selectedClass` computed (line 231) still works because it references `props.newCharacter.className` which hasn't changed.

IMPORTANT: The `styles.roster` and `styles.subtle` style objects are already used in the component (lines 33-37) — reuse them for the race info display.
  </action>
  <verify>
1. Open the dev server (`npm run dev` or `pnpm dev`)
2. Navigate to the character creation panel
3. Verify the race dropdown appears with 4 options: Human, Eldrin, Ironclad, Wyldfang
4. Select "Eldrin" — verify class dropdown shows only: Bard, Cleric, Druid, Enchanter, Necromancer, Paladin, Ranger, Reaver, Shaman, Spellblade, Summoner, Wizard
5. Select "Human" — verify ALL classes appear
6. Select "Wyldfang" then select a class not in its list (shouldn't be possible since dropdown is filtered), then switch to "Ironclad" — verify class clears if it was invalid
7. Create a character — verify no errors, character appears in list with race name
8. `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
CharacterPanel shows a race dropdown with unlocked races. Selecting a race displays description and stat bonuses. Class dropdown filters to only classes allowed by the selected race. Changing race clears invalid class selection. Creating a character sends raceId to the backend. Character list still displays race name correctly. App.vue correctly passes `races` to both `useCharacterCreation()` and `CharacterPanel`.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete race selection flow end-to-end</name>
  <files>n/a</files>
  <action>
Human verifies the complete race selection flow works end-to-end. Everything was built in Tasks 1-2 — this checkpoint confirms it works visually and functionally.

Steps to verify:
1. Open the app in browser (dev server should be running)
2. Go to Character panel (character creation)
3. Race picker: Verify dropdown shows Human, Eldrin, Ironclad, Wyldfang
4. Race info: Select Eldrin — should show description and "WIS +1 INT +2"
5. Class filtering: With Eldrin selected, verify only magic/hybrid classes appear (no Warrior, Rogue, Monk, Beastmaster)
6. Human = all: Select Human — verify ALL classes appear
7. Class clear on race change: Select Wyldfang, pick Rogue, then switch to Ironclad — Rogue should clear (not available to Ironclad)
8. Create character: Select Ironclad + Warrior, enter a name, click Create — character should appear in list as "[Name] (Lv 1) - Ironclad Warrior"
9. Stat bonuses: Switch to Stats panel — verify the character's base STR stat (not equipment bonus) is higher than a normal Warrior would have. Ironclad gives +2 STR baked into the base stats at creation time, so the STR value should be 2 higher than the class baseline.
10. Invalid combo rejection: If possible, manually call the reducer with an invalid race-class combo via browser console — should get SenderError

Expected state after verification:
- 4 races visible in dropdown
- Class filtering works for each race
- Characters created with racial stat bonuses
- Invalid combos impossible via UI (and rejected by server)
  </action>
  <verify>Human confirms all 10 verification steps pass.</verify>
  <done>Race selection flow works end-to-end: picker, filtering, creation, and stat bonuses all verified by human.</done>
</task>

</tasks>

<verification>
1. Race dropdown shows exactly 4 unlocked races
2. Selecting a race shows description and non-zero stat bonuses
3. Class dropdown filters to allowed classes per race
4. Changing race clears invalid class selection
5. Creating a character sends raceId (not race string) to reducer
6. New character appears in list with correct race name
7. Character base stats include racial bonuses
8. No TypeScript errors in the project
</verification>

<success_criteria>
- Race picker dropdown renders with 4 races from the Race table subscription
- Class filtering works correctly for all 4 races (Human=all, others=restricted)
- Character creation sends raceId to backend and stores race display name
- Racial stat bonuses visible in character stats (STR +2 for Ironclad, INT +2 for Eldrin, etc.)
- Human-verified end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/01-races/01-02-SUMMARY.md`
</output>
