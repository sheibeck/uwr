# Phase 21.1.1: Hit/Dodge/Parry Active Stats - Research

**Researched:** 2026-02-21
**Domain:** SpacetimeDB TypeScript combat system — stat-derived avoidance rolls
**Confidence:** HIGH (all findings from direct codebase reading)

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Stat source: DEX drives both dodge and parry chance. Read pre-computed values directly from
  character table: `character.dodgeChance`, `character.parryChance`, `character.hitChance`.
  Do NOT recompute from raw DEX inside `rollAttackOutcome`.
- Keep `canDodge` and `canParry` boolean parameters in `rollAttackOutcome`. Caller controls
  eligibility (stunned target, ranged attack vs. parry restriction, etc.).
- Parry only applies against melee attacks — enforced by caller passing `canParry: false`
  for ranged. No parry against ranged auto-attacks or ranged abilities.
- Stat values replace the hardcoded `50n` threshold — boolean gating logic stays.
- This phase does NOT redesign the stat formulas in `recomputeCharacterDerived`.

### Claude's Discretion
- Opposed roll formula: pick the cleanest approach that fits the existing cursor-based structure
  (e.g., subtract hit bonus from dodge/parry thresholds, or use raw stat values directly).
- Evasion caps: set reasonable max dodge/parry to prevent untouchable builds — document the
  cap in the plan.
- Miss as outcome: decide whether low hit chance creates a visible "miss" outcome or only
  modifies the dodge/parry windows.

### Deferred Ideas (OUT OF SCOPE)
- Redesigning `recomputeCharacterDerived` stat formulas.
- Applying hit/dodge/parry to ability damage (abilities bypass `rollAttackOutcome` entirely).
</user_constraints>

---

## Summary

The hit/dodge/parry stats are fully computed and stored in the character table but are never
read inside `rollAttackOutcome`. The function currently adds a flat `50n` (5% on 1000-scale)
to the cursor for dodge and parry unconditionally whenever the boolean gates are true. The
phase simply threads the pre-computed stat values through from the call sites into the function.

At DEX=10 (base), the stat-derived values are hitChance=150, dodgeChance=120, parryChance=100
— all on the same 0-1000 scale as block chance and crit chance. This means the change will
significantly increase average avoidance rates compared to the hardcoded 5%. Cap enforcement
is therefore critical to prevent degenerate high-DEX builds.

The "opposed roll" design decision matters most: should the attacker's hitChance subtract from
the defender's dodge/parry window? This is the cleanest approach and matches the block system's
existing pattern (blockChanceBasis is already passed as a stat-derived value on 1000-scale).

**Primary recommendation:** Add `dodgeChance`, `parryChance`, and `hitChance` optional fields
to `rollAttackOutcome`'s opts, cap them server-side, implement net-after-hit-bonus arithmetic,
and pass attacker/defender stat values at each call site. Add ranged weapon detection at the
two player-attack call sites to enforce `canParry: false` for bows.

---

## Codebase Facts

### Stat Scale (HIGH confidence — read from source)

All avoidance stats are on the **0-1000 scale** (same as block chance and crit chance):
- 1000 = 100%, 100 = 10%, 50 = 5%
- The existing hardcoded `cursor += 50n` means 5% dodge and 5% parry at ALL DEX levels.

**Derived stat formulas** (from `helpers/character.ts` lines 94-96):
```typescript
const hitChance   = totalStats.dex * 15n + racialHitBonus;   // DEX 10 → 150 (15%)
const dodgeChance = totalStats.dex * 12n + racialDodgeBonus; // DEX 10 → 120 (12%)
const parryChance = totalStats.dex * 10n + racialParryBonus; // DEX 10 → 100 (10%)
```

These values grow linearly with DEX. At DEX=20: hitChance=300 (30%), dodge=240 (24%),
parry=200 (20%). Without a cap these become extreme at high DEX.

### `rollAttackOutcome` — Current Implementation (HIGH confidence)

File: `spacetimedb/src/helpers/combat.ts` lines 145-188.

```typescript
export function rollAttackOutcome(
  seed: bigint,
  opts: {
    canBlock: boolean;
    blockChanceBasis?: bigint;        // on 1000-scale; default 50n (5%)
    blockMitigationPercent?: bigint;  // on 100n-scale; default 50n (50%)
    canParry: boolean;
    canDodge: boolean;
    characterDex?: bigint;            // currently used ONLY for crit chance
    weaponName?: string;
    weaponType?: string;
  }
) {
  const roll = seed % 1000n;
  let cursor = 0n;
  if (opts.canDodge) {
    cursor += 50n;                    // HARDCODED — replaces with dodgeChance
    if (roll < cursor) return { outcome: 'dodge', multiplier: 0n };
  }
  if (opts.canParry) {
    cursor += 50n;                    // HARDCODED — replaces with parryChance
    if (roll < cursor) return { outcome: 'parry', multiplier: 0n };
  }
  if (opts.canBlock) {
    const blockChance = opts.blockChanceBasis ?? 50n;   // ALREADY stat-derived
    ...
  }
  // Critical strike check — characterDex IS used here
  if (opts.characterDex !== undefined) {
    const critChance = calculateCritChance(opts.characterDex);
    if (roll < cursor + critChance) { ... }
  }
  return { outcome: 'hit', multiplier: 100n };
}
```

**Key insight:** `characterDex` is currently ONLY used for crit calculation. It is NOT used
for dodge or parry at all. The block system already follows the correct pattern:
`blockChanceBasis` is an optional stat-derived value on 1000-scale with a `?? 50n` default.
Dodge and parry should follow the identical pattern.

### Call Sites for `resolveAttack` (HIGH confidence)

`resolveAttack` is a local function in `reducers/combat.ts` that wraps `rollAttackOutcome`.
There are four call sites, each requiring different handling:

**1. Player auto-attacks enemy** (line 2168):
```typescript
resolveAttack(ctx, {
  canDodge: true,
  canParry: canParry(character.className),     // class whitelist
  characterDex: character.dex,                 // ATTACKER's DEX (for crit only now)
  weaponName: weapon.name,
  weaponType: weapon.weaponType,               // 'bow', 'sword', etc.
  ...
})
```
- Target is an enemy (`combatEnemy`) — enemies have `armorClass` but NO `dodgeChance`/`hitChance` columns.
- `characterDex` here is the ATTACKER's stat, not the defender's.
- **For this phase:** enemies retain hardcoded 0 dodge (they have no dodge stat table). The
  player's `hitChance` does NOT apply against enemy dodge — enemy dodge/parry windows stay at
  their current hardcoded values or 0 (enemies can already parry player attacks in the current
  code — `canParry: canParry(character.className)` means the CHARACTER can parry, but this
  is passed as the defender's gate — see below).

  **WAIT — re-reading:** `canParry: canParry(character.className)` at line 2173 is the
  PLAYER attacking the ENEMY. This means: can the ENEMY parry the player's attack? The
  `canParry` boolean is the DEFENDER's parry eligibility. So `canParry(character.className)`
  here passes the PLAYER's class as determining whether the ENEMY can parry — this appears to
  be a logic bug or intentional design where only certain-class players' attacks can be parried.

  On re-reading more carefully: line 2173 is inside the "player attacks enemy" block. The
  target is the enemy. So `canParry: canParry(character.className)` is saying: "can the enemy
  parry this?" using the attacking character's class as the gate. This seems inverted — it
  should be the DEFENDER's ability to parry. This is existing behavior; do not change it in
  this phase.

**2. Pet auto-attacks enemy** (line 2292):
```typescript
resolveAttack(ctx, {
  canDodge: true,
  canParry: false,      // pets can't be parried (or target can't parry pet)
  canBlock: false,
  ...
  // No characterDex — no crit for pets
})
```
- Target is an enemy. No character stats involved.
- **For this phase:** No change needed. Enemies don't have stat-derived avoidance.

**3. Enemy auto-attacks player** (line 2933):
```typescript
resolveAttack(ctx, {
  canBlock: hasShieldEquipped(ctx, targetCharacter.id),
  blockChanceBasis,      // ALREADY stat-derived from targetCharacter.dex
  blockMitigationPercent, // ALREADY stat-derived from targetCharacter.str
  canParry: canParry(targetCharacter.className),   // defender's class
  canDodge: true,
  currentHp: targetCharacter.hp,
  // No characterDex, weaponName, weaponType — no crit for enemy attacks
  ...
})
```
- Target is a player character. This is the main path for this phase.
- `blockChanceBasis` is ALREADY stat-derived (good pattern to follow).
- `canParry` correctly uses the DEFENDER (targetCharacter) class.
- **For this phase:** Add `dodgeChanceBasis` and `parryChanceBasis` from `targetCharacter`
  stats. No hitChance for enemy (enemies don't have hitChance columns).

**4. Enemy auto-attacks pet** (line 2871):
```typescript
resolveAttack(ctx, {
  canBlock: false,
  canParry: false,
  canDodge: true,
  ...
  // No character stats — pets have no DEX
})
```
- Target is a pet. No character stats.
- **For this phase:** No change needed. Pets don't have stat-derived avoidance.

### `canParry` Class Whitelist (HIGH confidence)

From `data/class_stats.ts` lines 36-45:
```typescript
export const PARRY_CLASSES = new Set([
  'warrior',
  'paladin',
  'reaver',
  'rogue',
  'ranger',
  // (confirmed — bard, cleric, wizard, etc. are NOT in the set)
]);

export function canParry(className: string) {
  return PARRY_CLASSES.has(normalizeClassName(className));
}
```

**Important:** Ranger is in `PARRY_CLASSES`. Rangers use bows. The parry restriction for
ranged weapons (from CONTEXT.md) means that even though rangers CAN parry in melee, when
attacking with a bow they cannot be parried. The caller must detect bow attacks and pass
`canParry: false` for ranged.

### Weapon Type Values (HIGH confidence)

From `data/item_defs.ts`:
- Melee: `'sword'`, `'mace'`, `'axe'`, `'dagger'`, `'rapier'`, `'blade'`, `'staff'`
- Ranged: `'bow'` (the ONLY ranged weapon type in the game)

The ranged detection is: `weaponType === 'bow'`. This is straightforward.

### Attacker hitChance — Current State (HIGH confidence)

`character.hitChance` is computed by `recomputeCharacterDerived` and stored in the character
table. It is NEVER read in any combat call site. The attacker's `hitChance` must be added
as a new parameter to the `resolveAttack` and `rollAttackOutcome` call chains.

At the enemy-attacks-player call site, the enemy has no `hitChance` column. Enemy hit chance
against player dodge/parry is either:
- Treated as 0 (enemies always have full effectiveness of the player's dodge/parry), or
- Given a fixed baseline that represents "average" enemy accuracy.

This is a discretion area (per CONTEXT.md). Recommendation: treat enemy hitChance as 0 on
the opposed roll (no attacker hit bonus), which means player avoidance values are applied at
full value when defending against enemies.

### The Block Pattern (HIGH confidence — reference implementation)

Block already follows the correct stat-derived pattern as of a prior phase:

At the call site (enemy attacks player, lines 2920-2931):
```typescript
const blockChanceBasis: bigint = (() => {
  const offset = statOffset(targetCharacter.dex, BLOCK_CHANCE_DEX_PER_POINT);
  const raw = BLOCK_CHANCE_BASE + offset;
  // Clamp to [10n, 200n] on 1000-scale (1% min, 20% max)
  return raw < 10n ? 10n : raw > 200n ? 200n : raw;
})();
```

Then passed as `blockChanceBasis` to `resolveAttack`, which passes it to `rollAttackOutcome`.
Inside `rollAttackOutcome`, the block section uses `opts.blockChanceBasis ?? 50n`.

**Dodge and parry should follow this IDENTICAL pattern.** The values are pre-computed on the
character table, so no `statOffset` computation is needed at the call site — just read
`targetCharacter.dodgeChance` and `targetCharacter.parryChance` directly, clamp them, and
pass them as `dodgeChanceBasis` and `parryChanceBasis`.

---

## Architecture Patterns

### Pattern 1: Add Optional Chance Params to `rollAttackOutcome`

Follow the block pattern exactly:

```typescript
// In rollAttackOutcome opts:
dodgeChanceBasis?: bigint;   // on 1000-scale; default 50n (5%)
parryChanceBasis?: bigint;   // on 1000-scale; default 50n (5%)
attackerHitBonus?: bigint;   // on 1000-scale; default 0n (no hit bonus)

// In the function body:
if (opts.canDodge) {
  const dodgeChance = opts.dodgeChanceBasis ?? 50n;
  const hitBonus = opts.attackerHitBonus ?? 0n;
  const netDodge = dodgeChance > hitBonus ? dodgeChance - hitBonus : 0n;
  cursor += netDodge;
  if (roll < cursor) return { outcome: 'dodge', multiplier: 0n };
}
if (opts.canParry) {
  const parryChance = opts.parryChanceBasis ?? 50n;
  const hitBonus = opts.attackerHitBonus ?? 0n;
  const netParry = parryChance > hitBonus ? parryChance - hitBonus : 0n;
  cursor += netParry;
  if (roll < cursor) return { outcome: 'parry', multiplier: 0n };
}
```

**Why this approach:** It is backward-compatible (callers that don't pass the new params get
the current 5% behavior), matches the existing `blockChanceBasis ?? 50n` pattern, and keeps
the opposed-roll logic inside the function rather than at every call site.

### Pattern 2: Clamping at the Call Site

Clamping must happen BEFORE passing to `rollAttackOutcome`, at the `resolveAttack` call site
in `reducers/combat.ts`. Follow the block clamping pattern:

```typescript
// Enemy attacks player — at line ~2920
const dodgeChanceBasis: bigint = (() => {
  const raw = targetCharacter.dodgeChance;
  // Clamp to [0n, 250n] on 1000-scale (0% min, 25% max)
  return raw < 0n ? 0n : raw > 250n ? 250n : raw;
})();
const parryChanceBasis: bigint = (() => {
  const raw = targetCharacter.parryChance;
  // Clamp to [0n, 200n] on 1000-scale (0% min, 20% max)
  return raw < 0n ? 0n : raw > 200n ? 200n : raw;
})();
```

### Pattern 3: Ranged Parry Enforcement

At player auto-attack call site (enemy is the DEFENDER — note: canParry here already uses
player's class per existing logic). The `weaponType` is already being passed. The ranged
parry restriction should be applied at the call site:

```typescript
// Player attacks enemy — at line ~2168
canParry: canParry(character.className) && weapon.weaponType !== 'bow',
// OR equivalently:
canParry: canParry(character.className) && !isRangedWeapon(weapon.weaponType),
```

**No separate `isRangedWeapon` helper needed** — `weaponType === 'bow'` is the only case.

### Pattern 4: Pass attacker hitChance at enemy-attacks-player call site

Enemies have no `hitChance` column. Pass `attackerHitBonus: 0n` (or simply omit it, since
the default is 0n). This means player avoidance is fully effective against enemies.

For player-attacks-enemy, the player's `hitChance` should be passed. But enemies have no
dodge/parry stats in this phase (they use `canDodge: true` with hardcoded behavior). If
enemy dodge stays at 0 (or continues using existing hardcoded value), passing player hitChance
doesn't reduce enemy avoidance. The cleanest decision: only use `attackerHitBonus` in the
enemy-attacks-player path where the defender has real stat-derived values.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead |
|---------|-------------|-------------|
| Scaling stat to 0-1000 range | Custom conversion math | Read `character.dodgeChance` directly — already on 1000-scale |
| Clamping avoidance values | Recursive clamp helpers | Inline ternary, same as `blockChanceBasis` clamping at line 2924-2925 |
| Ranged detection | Weapon type registry | `weapon.weaponType === 'bow'` — only one ranged type |
| Class parry eligibility | New logic | Existing `canParry(className)` from `class_stats.ts` |

---

## Common Pitfalls

### Pitfall 1: Confusing Attacker vs. Defender in Call Sites

**What goes wrong:** The player-attacks-enemy call site (line 2168-2202) passes
`characterDex: character.dex` where `character` is the ATTACKER. The `canParry` and
`canDodge` booleans there represent the ENEMY's ability to avoid, not the player's.
This is confusing naming.

**How to avoid:** When adding `dodgeChanceBasis` and `parryChanceBasis`, these should be
the DEFENDER's stats. For the player-attacks-enemy path, the defender is the ENEMY, which
has no stat-derived avoidance — do not pass enemy dodge values (enemies have no such column).
Only pass dodge/parry chance basis at call sites where the DEFENDER is a character.

### Pitfall 2: Scale Mismatch — Raw vs. Clamped Values

**What goes wrong:** `character.dodgeChance` at DEX=20 is `240n`. Without a cap this is
24% dodge. With attacker hitBonus subtracted, `240n - 150n = 90n` (9% net dodge). Both
uncapped values would produce acceptable behavior at normal DEX ranges but become extreme
at very high DEX (DEX=30 → dodge=360, hit=450 → net = capped to max).

**How to avoid:** Clamp dodgeChance and parryChance BEFORE subtraction, not after. Clamping
after subtraction (the net value) would hide extreme raw stats from future inspection.

### Pitfall 3: The `resolveAttack` Signature Also Needs Updating

**What goes wrong:** `rollAttackOutcome` in `helpers/combat.ts` and the `resolveAttack`
local function in `reducers/combat.ts` both need the new optional params. Updating only
one will cause TypeScript errors or silent failures.

**How to avoid:** Update both signatures in the same edit. `resolveAttack` just passes
through to `rollAttackOutcome` — follow the same passthrough pattern as `blockChanceBasis`.

### Pitfall 4: Enemy Parry vs. Player Parry Confusion

**What goes wrong:** In player-attacks-enemy (line 2173), `canParry: canParry(character.className)`
uses the ATTACKING player's class. This means the enemy can parry the player IF the player's
class is in PARRY_CLASSES. This seems inverted but it's existing behavior. The CONTEXT.md
constraint says "no parry against ranged" — this means when THE DEFENDER (enemy) would be
checking parry against a ranged attacker. The `weaponType === 'bow'` gate must be ANDed with
the existing expression.

**How to avoid:** Do not change the semantics of `canParry` usage at the player-attacks-enemy
site — only add `&& weapon.weaponType !== 'bow'` to it.

---

## Cap Recommendations (Claude's Discretion)

Based on the stat scale analysis:

| Stat | Current | At DEX=10 | At DEX=20 | Recommended Cap |
|------|---------|-----------|-----------|----------------|
| dodgeChance | 50n (5%) | 120n (12%) | 240n (24%) | 250n (25%) |
| parryChance | 50n (5%) | 100n (10%) | 200n (20%) | 200n (20%) |
| hitChance | 0n | 150n (15%) | 300n (30%) | 300n (30%) |

**Rationale for caps:**
- 25% dodge cap: meaningful avoidance without making high-DEX characters untouchable.
  Even capped at 25% dodge + 20% parry = 45% combined avoidance, still allows solid
  offensive performance.
- 20% parry cap: parry is narrower (melee only) so a slightly lower cap is appropriate.
- hitChance cap: 30% hit bonus prevents attackers from completely neutralizing defender
  avoidance even at extreme DEX.

**Net floor:** After subtracting attacker hitBonus, use `max(0n, ...)` so net avoidance
never goes negative (which would silently subtract from the cursor and produce wrong results).

**Miss outcome:** The cleanest approach is NO separate "miss" outcome. Low hitChance simply
reduces dodge/parry windows rather than creating a new outcome category. The existing `miss`
message template in `resolveAttack` messages is used for a future use case and can remain
unused for now.

---

## Code Examples

### New `rollAttackOutcome` Signature

```typescript
// Source: direct codebase analysis of helpers/combat.ts
export function rollAttackOutcome(
  seed: bigint,
  opts: {
    canBlock: boolean;
    blockChanceBasis?: bigint;        // on 1000-scale; default 50n (5%)
    blockMitigationPercent?: bigint;  // on 100n-scale; default 50n (50%)
    canParry: boolean;
    parryChanceBasis?: bigint;        // NEW: on 1000-scale; default 50n (5%)
    canDodge: boolean;
    dodgeChanceBasis?: bigint;        // NEW: on 1000-scale; default 50n (5%)
    attackerHitBonus?: bigint;        // NEW: on 1000-scale; default 0n
    characterDex?: bigint;            // existing: attacker DEX for crit
    weaponName?: string;
    weaponType?: string;
  }
)
```

### Updated Dodge/Parry Logic Inside `rollAttackOutcome`

```typescript
// Source: derived from existing block pattern in helpers/combat.ts
const hitBonus = opts.attackerHitBonus ?? 0n;

if (opts.canDodge) {
  const raw = opts.dodgeChanceBasis ?? 50n;
  const net = raw > hitBonus ? raw - hitBonus : 0n;
  cursor += net;
  if (roll < cursor) return { outcome: 'dodge', multiplier: 0n };
}
if (opts.canParry) {
  const raw = opts.parryChanceBasis ?? 50n;
  const net = raw > hitBonus ? raw - hitBonus : 0n;
  cursor += net;
  if (roll < cursor) return { outcome: 'parry', multiplier: 0n };
}
```

### Enemy-Attacks-Player Call Site Update

```typescript
// Source: reducers/combat.ts around line 2920-2965
const dodgeChanceBasis: bigint = (() => {
  const raw = targetCharacter.dodgeChance;
  // Clamp to [0n, 250n] on 1000-scale (0% min, 25% max)
  return raw < 0n ? 0n : raw > 250n ? 250n : raw;
})();
const parryChanceBasis: bigint = (() => {
  const raw = targetCharacter.parryChance;
  // Clamp to [0n, 200n] on 1000-scale (0% min, 20% max)
  return raw < 0n ? 0n : raw > 200n ? 200n : raw;
})();

resolveAttack(ctx, {
  ...
  canParry: canParry(targetCharacter.className),
  parryChanceBasis,   // NEW
  canDodge: true,
  dodgeChanceBasis,   // NEW
  // attackerHitBonus omitted (default 0n — enemies have no hitChance column)
  ...
})
```

### Player-Attacks-Enemy Call Site Update

```typescript
// Source: reducers/combat.ts around line 2168
// Read attacker's hitChance (pre-computed on character table)
const attackerHitBonus: bigint = (() => {
  const raw = character.hitChance;
  // Clamp to [0n, 300n] on 1000-scale
  return raw < 0n ? 0n : raw > 300n ? 300n : raw;
})();

resolveAttack(ctx, {
  ...
  canParry: canParry(character.className) && weapon.weaponType !== 'bow',  // ranged gate
  canDodge: true,
  // No dodgeChanceBasis/parryChanceBasis — enemies have no dodge columns (stays at ?? 50n default)
  attackerHitBonus,   // NEW: reduces enemy's default 50n dodge window
  characterDex: character.dex,
  weaponName: weapon.name,
  weaponType: weapon.weaponType,
  ...
})
```

**Note on enemy dodge:** Enemy dodge stays at `?? 50n` default (5%). With a DEX=10 player
attackerHitBonus=150, enemy net dodge = max(0, 50-150) = 0. So enemies effectively never
dodge when the player has average or better hit chance. This is reasonable — enemies rely on
armor mitigation, not avoidance.

---

## Files to Change

| File | Change |
|------|--------|
| `spacetimedb/src/helpers/combat.ts` | Add `dodgeChanceBasis?`, `parryChanceBasis?`, `attackerHitBonus?` to `rollAttackOutcome` opts; update dodge/parry cursor logic |
| `spacetimedb/src/reducers/combat.ts` | Add same params to `resolveAttack`'s inner type; update enemy-attacks-player call site; update player-attacks-enemy call site (ranged gate + attackerHitBonus); no changes to pet or enemy-attacks-pet call sites |

No schema changes needed — `hitChance`, `dodgeChance`, `parryChance` columns already exist.
No new imports needed.

---

## Open Questions

1. **Enemy dodge at high player hitChance**
   - What we know: Enemy default dodge is 50n (5%), player hitChance at DEX=10 is 150n.
     Net = max(0, 50-150) = 0 — enemies effectively never dodge vs. average players.
   - What's unclear: Is 0% enemy dodge desirable? Or should enemies have a minimum floor?
   - Recommendation: 0% is fine for this phase. Enemy avoidance comes from armor, not dodge.
     Can always add enemy dodge stats in a future phase.

2. **Player-attacks-enemy hitChance application**
   - What we know: Current `canDodge: true` with 5% enemy dodge. Player hitChance would
     reduce this to 0% at normal DEX. The enemy parry logic is semantically inverted
     (uses attacker class, not defender class).
   - What's unclear: Should player hitChance reduce enemy dodge at all? Or only apply when
     defender has real stat-derived avoidance?
   - Recommendation: Apply hitChance at the player-attacks-enemy site as `attackerHitBonus`.
     This is consistent and makes hitChance meaningful in both directions.

---

## Sources

### Primary (HIGH confidence)
- Direct read: `spacetimedb/src/helpers/combat.ts` (full `rollAttackOutcome` function)
- Direct read: `spacetimedb/src/helpers/character.ts` (full `recomputeCharacterDerived` function)
- Direct read: `spacetimedb/src/reducers/combat.ts` lines 446-572 (`resolveAttack` function)
- Direct read: `spacetimedb/src/reducers/combat.ts` lines 2136-2202 (player auto-attack)
- Direct read: `spacetimedb/src/reducers/combat.ts` lines 2908-2965 (enemy auto-attack player)
- Direct read: `spacetimedb/src/reducers/combat.ts` lines 2292-2314 (pet attacks enemy)
- Direct read: `spacetimedb/src/reducers/combat.ts` lines 2868-2906 (enemy attacks pet)
- Direct read: `spacetimedb/src/data/class_stats.ts` (`PARRY_CLASSES`, `canParry`)
- Direct read: `spacetimedb/src/data/combat_scaling.ts` (`calculateCritChance`, `statOffset`, `BLOCK_CHANCE_BASE`, `BLOCK_CHANCE_DEX_PER_POINT`, `STAT_BASE`)
- Direct read: `spacetimedb/src/data/item_defs.ts` (weapon types confirmed)

---

## Metadata

**Confidence breakdown:**
- Stat formulas and scale: HIGH — read directly from source
- Call site analysis: HIGH — read directly from source
- Recommended caps: MEDIUM — design decision, no prior cap in codebase for dodge/parry
- Opposed roll formula: MEDIUM — design decision; block pattern gives clear precedent

**Research date:** 2026-02-21
**Valid until:** Stable — no external dependencies; valid until combat.ts is modified
