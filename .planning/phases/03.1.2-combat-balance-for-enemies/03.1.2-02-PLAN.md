---
phase: 03.1.2-combat-balance-for-enemies
plan: 02
type: execute
wave: 2
depends_on: ["03.1.2-01"]
files_modified:
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Enemy ability damage scales with enemy level (not fixed magnitude)"
    - "Enemy DoT abilities deal reduced direct damage proportional to dotPowerSplit"
    - "Enemy debuff abilities deal reduced direct damage proportional to debuffPowerCost"
    - "Enemy healer enemies can heal the lowest-HP ally with direct heal + HoT"
    - "Enemy AoE abilities hit all players in combat at 65% damage per target"
    - "Enemy AoE abilities deal direct damage only (no DoTs applied)"
    - "Enemy buff abilities apply effects to all living enemy allies"
    - "Physical enemy abilities are mitigated by player armor; magic abilities bypass armor"
    - "New heal/AoE/buff enemies are seeded in ensureEnemyAbilities"
  artifacts:
    - path: "spacetimedb/src/index.ts"
      provides: "Rewritten executeEnemyAbility with power scaling, budget splits, damage routing, and new kinds"
      contains: "ENEMY_BASE_POWER"
  key_links:
    - from: "spacetimedb/src/index.ts (executeEnemyAbility)"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "imports ENEMY_BASE_POWER, ENEMY_LEVEL_POWER_SCALING, AOE_DAMAGE_MULTIPLIER"
      pattern: "ENEMY_BASE_POWER|ENEMY_LEVEL_POWER_SCALING"
    - from: "spacetimedb/src/index.ts (executeEnemyAbility)"
      to: "spacetimedb/src/data/ability_catalog.ts"
      via: "reads ENEMY_ABILITIES metadata (power, dotPowerSplit, damageType, etc.)"
      pattern: "ENEMY_ABILITIES\\["
    - from: "spacetimedb/src/index.ts (executeEnemyAbility heal)"
      to: "spacetimedb/src/index.ts (addEnemyEffect)"
      via: "creates HoT effects on enemy allies"
      pattern: "addEnemyEffect.*regen"
    - from: "spacetimedb/src/index.ts (executeEnemyAbility dot)"
      to: "spacetimedb/src/index.ts (addCharacterEffect)"
      via: "creates DoT effects on player characters"
      pattern: "addCharacterEffect.*dot"
---

<objective>
Rewrite executeEnemyAbility to implement level-based power scaling, power budget splits for DoT/debuff, damage type routing (physical vs magic), and new ability kind handlers (heal, aoe_damage, buff). Seed new enemy abilities for healer, AoE, and buff enemies. Publish module and regenerate client bindings.

Purpose: This is the core implementation that makes enemy combat balanced and consistent with the player system. Enemies gain level-appropriate damage scaling, tactical variety (healers, AoE, buffers), and the same power budget tradeoffs players have.

Output: Working executeEnemyAbility with all 6 ability kinds (dot, debuff, heal, aoe_damage, buff, and direct), seeded enemy abilities for new types, published module.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1.2-combat-balance-for-enemies/03.1.2-RESEARCH.md
@.planning/phases/03.1.2-combat-balance-for-enemies/03.1.2-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite executeEnemyAbility with power scaling and all ability kinds</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
Rewrite the `executeEnemyAbility` function (currently at ~lines 3071-3109) to implement full power scaling and all ability kinds. This is the core implementation task.

**Step 1: Add imports**

At the top of index.ts, ensure these are imported from combat_scaling:
- `ENEMY_BASE_POWER`
- `ENEMY_LEVEL_POWER_SCALING`
- `AOE_DAMAGE_MULTIPLIER` (already imported if used elsewhere, verify)

**Step 2: Rewrite executeEnemyAbility**

Replace the existing function body. The new implementation should:

**A) Power calculation (all ability kinds):**
```typescript
const enemyLevel = enemyTemplate?.level ?? 1n;
const abilityPower = (ability as any).power ?? 3n;
const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
const totalPower = enemyPower + abilityPower * 5n; // Scale ability power like player system
```

Note: `abilityPower * 5n` mirrors the player ability power multiplier (ABILITY_POWER_BASE_MULTIPLIER = 5n from Phase 3.1, decision #35).

**B) Damage type routing helper (inline or local function):**
```typescript
function applyEnemyAbilityDamage(
  ctx: any, target: any, rawDamage: bigint, damageType: string,
  enemyName: string, abilityName: string
): bigint {
  let finalDamage = rawDamage;
  if (damageType === 'physical') {
    const effectiveArmor = target.armorClass + sumCharacterEffect(ctx, target.id, 'ac_bonus');
    finalDamage = applyArmorMitigation(rawDamage, effectiveArmor > 0n ? effectiveArmor : 0n);
  } else if (damageType === 'magic') {
    const magicResist = sumCharacterEffect(ctx, target.id, 'magic_resist');
    finalDamage = applyMagicResistMitigation(rawDamage, magicResist);
  }
  if (finalDamage < 1n) finalDamage = 1n;
  const nextHp = target.hp > finalDamage ? target.hp - finalDamage : 0n;
  ctx.db.character.id.update({ ...target, hp: nextHp });
  return finalDamage;
}
```

Define this helper function near executeEnemyAbility (before it) so it can be used by all ability kinds.

**C) DoT kind handler (replaces old fixed-magnitude handler):**
```typescript
if (ability.kind === 'dot') {
  const damageType = (ability as any).damageType ?? 'physical';
  const dotPowerSplit = (ability as any).dotPowerSplit ?? 0.5;

  // Direct damage portion
  const directFraction = 1.0 - dotPowerSplit;
  const directDamage = (totalPower * BigInt(Math.floor(directFraction * 100))) / 100n;

  // DoT portion
  const dotFraction = dotPowerSplit;
  const dotTotalDamage = (totalPower * BigInt(Math.floor(dotFraction * 100))) / 100n;
  const dotPerTick = ability.rounds > 0n ? dotTotalDamage / ability.rounds : dotTotalDamage;

  // Apply direct damage with armor/magic resist routing
  let actualDamage = 0n;
  if (directDamage > 0n) {
    actualDamage = applyEnemyAbilityDamage(ctx, target, directDamage, damageType, enemyName, ability.name);
  }

  // Apply DoT via existing CharacterEffect system (same tick_hot reducer handles it)
  if (dotPerTick > 0n) {
    addCharacterEffect(ctx, target.id, 'dot', dotPerTick, ability.rounds, ability.name);
  }

  // Log messages
  const dmgMsg = actualDamage > 0n ? ` for ${actualDamage}` : '';
  const privateMessage = `${enemyName} uses ${ability.name} on you${dmgMsg}.`;
  const groupMessage = `${enemyName} uses ${ability.name} on ${target.name}${dmgMsg}.`;
  appendPrivateEvent(ctx, target.id, target.ownerUserId, 'damage', privateMessage);
  if (target.groupId) {
    appendGroupEvent(ctx, target.groupId, target.id, 'damage', groupMessage);
  }
}
```

**D) Debuff kind handler (replaces old fixed handler):**
```typescript
else if (ability.kind === 'debuff') {
  const damageType = (ability as any).damageType ?? 'physical';
  const debuffPowerCost = (ability as any).debuffPowerCost ?? 0.25;

  // Direct damage reduced by debuff cost
  const damageFraction = 1.0 - debuffPowerCost;
  const directDamage = (totalPower * BigInt(Math.floor(damageFraction * 100))) / 100n;

  // Apply direct damage with damage type routing
  let actualDamage = 0n;
  if (directDamage > 0n) {
    actualDamage = applyEnemyAbilityDamage(ctx, target, directDamage, damageType, enemyName, ability.name);
  }

  // Apply debuff effect (fixed magnitude from metadata, not scaled)
  const effectType = (ability as any).effectType ?? 'ac_bonus';
  addCharacterEffect(ctx, target.id, effectType, ability.magnitude, ability.rounds, ability.name);

  // Log messages
  const dmgMsg = actualDamage > 0n ? ` for ${actualDamage} and` : '';
  const privateMessage = `${enemyName} uses ${ability.name}${dmgMsg} afflicts you.`;
  const groupMessage = `${enemyName} uses ${ability.name}${dmgMsg} afflicts ${target.name}.`;
  appendPrivateEvent(ctx, target.id, target.ownerUserId, 'ability', privateMessage);
  if (target.groupId) {
    appendGroupEvent(ctx, target.groupId, target.id, 'ability', groupMessage);
  }
}
```

**E) Heal kind handler (NEW):**
```typescript
else if (ability.kind === 'heal') {
  // Find lowest HP living ally enemy in this combat
  const allies = [...ctx.db.combatEnemy.by_combat.filter(combatId)]
    .filter((e: any) => e.currentHp > 0n);

  // Sort by HP ascending to find lowest
  let healTarget = allies[0];
  for (const ally of allies) {
    if (ally.currentHp < healTarget.currentHp) {
      healTarget = ally;
    }
  }

  if (!healTarget) return;

  const healPowerSplit = (ability as any).healPowerSplit ?? 1.0;
  const directHealFraction = healPowerSplit;
  const directHeal = (totalPower * BigInt(Math.floor(directHealFraction * 100))) / 100n;

  // Cap at maxHp
  const healTargetTemplate = ctx.db.enemyTemplate.id.find(healTarget.enemyTemplateId);
  const maxHp = healTargetTemplate?.maxHp ?? healTarget.currentHp + directHeal;
  const nextHp = healTarget.currentHp + directHeal > maxHp ? maxHp : healTarget.currentHp + directHeal;
  ctx.db.combatEnemy.id.update({ ...healTarget, currentHp: nextHp });

  // Apply HoT if split specified
  const hotDuration = (ability as any).hotDuration;
  if (hotDuration && healPowerSplit < 1.0) {
    const hotFraction = 1.0 - healPowerSplit;
    const hotTotal = (totalPower * BigInt(Math.floor(hotFraction * 100))) / 100n;
    const hotPerTick = hotDuration > 0n ? hotTotal / hotDuration : hotTotal;
    if (hotPerTick > 0n) {
      addEnemyEffect(ctx, combatId, healTarget.id, 'regen', hotPerTick, hotDuration, ability.name);
    }
  }

  // Log healing event
  const healTargetName = healTarget.displayName ?? healTargetTemplate?.name ?? 'an ally';
  const healAmount = nextHp - (healTarget.currentHp - directHeal + (nextHp - healTarget.currentHp - directHeal > 0n ? 0n : directHeal)); // Simplify: just use directHeal for log

  // Actually simplify the log: show actual heal amount
  const actualHeal = nextHp - (healTarget.currentHp); // This was before the update, but we already updated. Use directHeal capped.
  // Better approach: log directHeal since we already updated
  const firstActive = [...ctx.db.combatParticipant.by_combat.filter(combatId)]
    .find((p: any) => p.status === 'active');
  if (firstActive) {
    const logCharacter = ctx.db.character.id.find(firstActive.characterId);
    if (logCharacter) {
      appendPrivateEvent(ctx, logCharacter.id, logCharacter.ownerUserId, 'combat',
        `${enemyName} heals ${healTargetName} for ${directHeal}.`);
      if (logCharacter.groupId) {
        appendGroupEvent(ctx, logCharacter.groupId, logCharacter.id, 'combat',
          `${enemyName} heals ${healTargetName} for ${directHeal}.`);
      }
    }
  }
}
```

IMPORTANT: The heal log message approach above is overly complex. Simplify it. Here is the cleaner version to use instead:

```typescript
else if (ability.kind === 'heal') {
  const allies = [...ctx.db.combatEnemy.by_combat.filter(combatId)]
    .filter((e: any) => e.currentHp > 0n);
  if (allies.length === 0) return;

  // Find lowest HP ally
  let healTarget = allies[0];
  for (const ally of allies) {
    if (ally.currentHp < healTarget.currentHp) healTarget = ally;
  }

  const healPowerSplit = (ability as any).healPowerSplit ?? 1.0;
  const directHeal = (totalPower * BigInt(Math.floor(healPowerSplit * 100))) / 100n;

  // Cap at maxHp
  const healTargetTemplate = ctx.db.enemyTemplate.id.find(healTarget.enemyTemplateId);
  const maxHp = healTargetTemplate?.maxHp ?? 100n;
  const nextHp = healTarget.currentHp + directHeal > maxHp ? maxHp : healTarget.currentHp + directHeal;
  ctx.db.combatEnemy.id.update({ ...healTarget, currentHp: nextHp });

  // Apply HoT if split specified
  const hotDuration = (ability as any).hotDuration;
  if (hotDuration && healPowerSplit < 1.0) {
    const hotFraction = 1.0 - healPowerSplit;
    const hotTotal = (totalPower * BigInt(Math.floor(hotFraction * 100))) / 100n;
    const hotPerTick = hotDuration > 0n ? hotTotal / hotDuration : hotTotal;
    if (hotPerTick > 0n) {
      addEnemyEffect(ctx, combatId, healTarget.id, 'regen', hotPerTick, hotDuration, ability.name);
    }
  }

  // Log heal event to all active participants
  const healTargetName = healTarget.displayName ?? healTargetTemplate?.name ?? 'an ally';
  for (const participant of ctx.db.combatParticipant.by_combat.filter(combatId)) {
    if (participant.status !== 'active') continue;
    const pc = ctx.db.character.id.find(participant.characterId);
    if (!pc) continue;
    appendPrivateEvent(ctx, pc.id, pc.ownerUserId, 'combat',
      `${enemyName} heals ${healTargetName} for ${directHeal}.`);
  }
  const firstActive = [...ctx.db.combatParticipant.by_combat.filter(combatId)]
    .find((p: any) => p.status === 'active');
  if (firstActive) {
    const pc = ctx.db.character.id.find(firstActive.characterId);
    if (pc?.groupId) {
      appendGroupEvent(ctx, pc.groupId, pc.id, 'combat',
        `${enemyName} heals ${healTargetName} for ${directHeal}.`);
    }
  }
}
```

**F) AoE damage kind handler (NEW):**
Per user decision: enemy AoE hits all players, 65% damage per target, NO DoTs.
```typescript
else if (ability.kind === 'aoe_damage') {
  const damageType = (ability as any).damageType ?? 'magic';
  const perTargetDamage = (totalPower * AOE_DAMAGE_MULTIPLIER) / 100n;

  // Hit all active participants
  for (const participant of ctx.db.combatParticipant.by_combat.filter(combatId)) {
    if (participant.status !== 'active') continue;
    const pc = ctx.db.character.id.find(participant.characterId);
    if (!pc || pc.hp === 0n) continue;

    const actualDamage = applyEnemyAbilityDamage(ctx, pc, perTargetDamage, damageType, enemyName, ability.name);

    appendPrivateEvent(ctx, pc.id, pc.ownerUserId, 'damage',
      `${enemyName} hits you with ${ability.name} for ${actualDamage}.`);
    if (pc.groupId) {
      appendGroupEvent(ctx, pc.groupId, pc.id, 'damage',
        `${enemyName} hits ${pc.name} with ${ability.name} for ${actualDamage}.`);
    }
  }
}
```

**G) Buff kind handler (NEW):**
```typescript
else if (ability.kind === 'buff') {
  const effectType = (ability as any).effectType ?? 'damage_bonus';
  const magnitude = ability.magnitude ?? 3n;
  const rounds = ability.rounds ?? 3n;

  // Buff all living enemy allies
  for (const ally of ctx.db.combatEnemy.by_combat.filter(combatId)) {
    if (ally.currentHp <= 0n) continue;
    addEnemyEffect(ctx, combatId, ally.id, effectType, magnitude, rounds, ability.name);
  }

  // Log buff event
  for (const participant of ctx.db.combatParticipant.by_combat.filter(combatId)) {
    if (participant.status !== 'active') continue;
    const pc = ctx.db.character.id.find(participant.characterId);
    if (!pc) continue;
    appendPrivateEvent(ctx, pc.id, pc.ownerUserId, 'combat',
      `${enemyName} rallies allies with ${ability.name}!`);
  }
  const firstActive = [...ctx.db.combatParticipant.by_combat.filter(combatId)]
    .find((p: any) => p.status === 'active');
  if (firstActive) {
    const pc = ctx.db.character.id.find(firstActive.characterId);
    if (pc?.groupId) {
      appendGroupEvent(ctx, pc.groupId, pc.id, 'combat',
        `${enemyName} rallies allies with ${ability.name}!`);
    }
  }
}
```

**Important implementation notes:**
1. Keep the existing function signature: `executeEnemyAbility(ctx, combatId, enemyId, abilityKey, targetCharacterId?)`
2. The first ~20 lines of setup (finding combat, ability, enemy, target) remain the same
3. For 'heal' and 'buff' kinds, the `target` variable (player character) is still resolved but may not be used -- heal targets enemy allies, buff targets enemy allies
4. DO NOT scale enemy damage with group size (user decision: no group size scaling)
5. DO NOT apply DoTs on AoE abilities (user decision: enemy AoE direct damage only)
6. Use `as any` casts for accessing metadata fields that don't exist on the base type (dotPowerSplit, damageType, etc.) since ENEMY_ABILITIES is a plain object
  </action>
  <verify>
Run: `grep -c "ENEMY_BASE_POWER\|ENEMY_LEVEL_POWER_SCALING" spacetimedb/src/index.ts`
Expected: at least 2 (imported + used)

Run: `grep -c "aoe_damage\|kind === 'heal'\|kind === 'buff'" spacetimedb/src/index.ts`
Expected: at least 3 (one check per new kind)

Run: `grep -c "AOE_DAMAGE_MULTIPLIER" spacetimedb/src/index.ts`
Expected: at least 2 (player AoE + enemy AoE)
  </verify>
  <done>executeEnemyAbility fully rewritten with level-based power scaling (ENEMY_BASE_POWER + level * ENEMY_LEVEL_POWER_SCALING), power budget splits for DoT/debuff, damage type routing (physical through armor, magic through resist), and three new ability kinds (heal, aoe_damage, buff)</done>
</task>

<task type="auto">
  <name>Task 2: Seed new enemy abilities and publish module</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
**Part A: Add new enemy ability seedings**

In the `ensureEnemyAbilities` function (currently lines ~5242-5309), add seeding calls for the new heal, AoE, and buff abilities. Assign them to appropriate enemy templates:

Heal abilities (enemy healer types -- pick enemies with mystical/spiritual names):
```typescript
upsertEnemyAbility('Fen Witch', 'shaman_heal', 'Shaman Heal', 'heal', 2n, 15n, 'lowest_hp');
upsertEnemyAbility('Grave Acolyte', 'dark_mend', 'Dark Mend', 'heal', 3n, 20n, 'lowest_hp');
```

AoE abilities (elite/dangerous enemy types):
```typescript
upsertEnemyAbility('Cinder Sentinel', 'flame_burst', 'Flame Burst', 'aoe_damage', 2n, 20n, 'all_players');
upsertEnemyAbility('Basalt Brute', 'quake_wave', 'Quake Wave', 'aoe_damage', 3n, 25n, 'all_players');
```

Buff abilities (support/leader enemy types):
```typescript
upsertEnemyAbility('Hexbinder', 'warchief_rally', 'Warchief Rally', 'buff', 2n, 30n, 'all_allies');
upsertEnemyAbility('Sootbound Mystic', 'bolster_defenses', 'Bolster Defenses', 'buff', 2n, 25n, 'all_allies');
```

This gives us:
- Fen Witch: existing mire_curse (debuff) + new shaman_heal (healer)
- Grave Acolyte: existing sapping_chant (debuff) + new dark_mend (healer)
- Cinder Sentinel: existing ember_slam (debuff) + new flame_burst (AoE)
- Basalt Brute: existing quake_stomp (debuff) + new quake_wave (AoE)
- Hexbinder: existing withering_hex (debuff) + new warchief_rally (buff)
- Sootbound Mystic: existing soot_hex (debuff) + new bolster_defenses (buff)

**Part B: Publish module and regenerate bindings**

After implementation, publish the module and regenerate client bindings:
```bash
spacetime publish uwr --project-path spacetimedb --clear-database -y
spacetime generate --lang typescript --out-dir client/src/module_bindings --project-path spacetimedb
```

Use `--clear-database` because the enemy ability seeding data has changed (new rows). The EnemyAbility table schema itself hasn't changed (kind is already a string field), so this is safe.

NOTE: Check if `--clear-database` is actually needed. If the ensureEnemyAbilities function already handles upserts (it does -- it checks for existing rows by abilityKey), then you may NOT need --clear-database. Try without first. Only use --clear-database if the publish fails or the new abilities don't appear.
  </action>
  <verify>
Run: `spacetime logs uwr 2>&1 | tail -20` to check for startup errors

Run: `grep -c "shaman_heal\|dark_mend\|flame_burst\|quake_wave\|warchief_rally\|bolster_defenses" spacetimedb/src/index.ts`
Expected: at least 12 (6 in ENEMY_ABILITIES import usage + 6 in ensureEnemyAbilities seeding)

Verify module publishes without errors.
  </verify>
  <done>Six new enemy abilities seeded to appropriate enemy types (2 healers, 2 AoE, 2 buffers). Module published and client bindings regenerated successfully.</done>
</task>

</tasks>

<verification>
- Module publishes without TypeScript compilation errors
- `spacetime logs uwr` shows no runtime errors on startup
- executeEnemyAbility contains handlers for all 6 kinds: dot, debuff, heal, aoe_damage, buff
- Level-based power scaling uses ENEMY_BASE_POWER + enemyLevel * ENEMY_LEVEL_POWER_SCALING
- DoT abilities split power between direct and periodic damage
- Debuff abilities reduce direct damage by debuffPowerCost fraction
- Heal abilities target lowest HP enemy ally with direct + HoT
- AoE abilities enumerate all active combat participants at 65% damage
- AoE abilities DO NOT apply DoTs (direct damage only)
- Buff abilities apply effects to all living enemy allies
- Physical damage routes through applyArmorMitigation
- Magic damage routes through applyMagicResistMitigation
- New enemy abilities seeded: Fen Witch + Grave Acolyte (heal), Cinder Sentinel + Basalt Brute (AoE), Hexbinder + Sootbound Mystic (buff)
</verification>

<success_criteria>
- Module publishes and starts without errors
- Enemy DoT abilities deal level-scaled direct damage plus periodic DoT ticks
- Enemy debuff abilities deal reduced direct damage plus apply debuff effect
- Enemy healer enemies heal lowest-HP ally with direct heal + HoT
- Enemy AoE enemies hit all players at 65% damage, no DoTs
- Enemy buffer enemies apply buff effects to all living allies
- Physical damage mitigated by armor, magic damage bypasses armor
- All damage scales with enemy level via ENEMY_BASE_POWER + level * ENEMY_LEVEL_POWER_SCALING
</success_criteria>

<output>
After completion, create `.planning/phases/03.1.2-combat-balance-for-enemies/03.1.2-02-SUMMARY.md`
</output>
