# Phase 03.1.2: Combat Balance for Enemies - Research

**Researched:** 2026-02-12
**Domain:** Enemy ability power scaling, DoT/debuff/healing/AoE mechanics for enemies
**Confidence:** HIGH

## Summary

Phase 03.1.2 extends the player combat balance system (Phases 3.1 and 3.1.1) to enemy abilities. The current system already has basic enemy DoT/debuff abilities (`executeEnemyAbility` in index.ts:3071-3109) but uses fixed magnitude values without power scaling, stat scaling, or advanced mechanics (healing, AoE, power budget splits).

**Current state analysis:**
- **Enemy abilities exist:** `ENEMY_ABILITIES` in ability_catalog.ts:854-1149 defines 30+ enemy abilities (poison_bite, ember_burn, sapping_chant, etc.)
- **Basic execution exists:** `executeEnemyAbility()` (index.ts:3071-3109) applies DoTs and debuffs to players
- **Fixed magnitude:** Enemy abilities use `ability.magnitude` directly (e.g., poison_bite: 2n damage per tick) without level scaling or power budgets
- **No enemy healing/AoE:** Current abilities are DoT or debuff only — no healing allies, no multi-target abilities
- **No power budget split:** Enemy DoTs apply full magnitude without reducing direct damage (enemies can auto-attack AND apply full-power DoTs)

**Primary recommendation:** Extend enemy ability system to use level-based power scaling (no stats), implement power budget splits for DoT/debuff abilities, add enemy healing and AoE ability types, and apply same mechanical rules (tick rate, stacking, effect tracking) as player abilities for consistency.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Enemy Power Scaling:**
- Enemy ability damage scales by **enemy level only** (fixed formulas, not scaling with player stats or group size)
- Enemies use the **same power budget system** as players (power rating split between direct damage and DoT/debuff)
- Enemies do **NOT** have stats (no STR/DEX/INT/WIS affecting their abilities) — damage is purely level + power rating
- **No group size scaling** — enemy damage is the same whether fighting 1 player or 5 players

**Enemy DoT/Debuff Mechanics:**
- Enemies **can apply DoTs** (damage over time) to players
- Enemies **can apply all debuff types** (armor reduction, slow, damage amp, etc.)
- Enemy DoTs/debuffs follow the **same rules as player effects**:
  - 3-second tick rate (same tick_hot scheduled reducer)
  - Same stacking/refresh logic (same ability refreshes, different abilities stack)
  - Same effect tracking via CharacterEffect table
- Enemy abilities with DoTs/debuffs **use power budget split** (reduced direct damage, just like player abilities)

**Enemy Healing and Support:**
- **Enemy healers exist** — some enemy types (shamans, clerics) can heal allies
- Enemy healing uses the **same power budget split** as player healing (direct heal + HoT)
- **Enemy buffs exist** — some enemies can buff allies (damage up, armor up, etc.)
- Enemy buffs **cost power budget** like player buffs (buffs reduce direct damage)

**Multi-Target Enemy Abilities:**
- **Enemy AoE abilities exist** — some enemies can hit multiple players with one ability
- Enemy AoE uses **65% damage per target** (same AOE_DAMAGE_MULTIPLIER as player AoE)
- **No target cap** — enemy AoE hits all players in the group (consistent with player AoE)
- **Enemy AoE cannot apply DoTs** — AoE abilities deal direct damage only, no periodic effects (different from players, prevents overwhelming group pressure)

### Claude's Discretion

- Specific enemy ability design (which enemies get DoTs, heals, AoE, etc.)
- Exact power budget split percentages per enemy ability
- Enemy ability variety and combat patterns per enemy type
- How many abilities each enemy type has

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed focused on extending Phase 3.1/3.1.1 combat balance to enemies.
</user_constraints>

---

## Standard Stack

### Core Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SpacetimeDB | 1.11.x | Database/backend | Already in use, no new dependencies needed |
| BigInt arithmetic | Native | Enemy damage calculations | SpacetimeDB uses bigint for all numeric values |

### Supporting

No additional libraries needed. This phase extends existing combat reducer logic (`index.ts`, `combat.ts`) and enemy ability catalog (`ability_catalog.ts`).

### Installation

No new packages required. All work is in existing `spacetimedb/src/` TypeScript files.

---

## Architecture Patterns

### Recommended Code Structure

```
spacetimedb/src/
├── data/ability_catalog.ts           # EXTEND - add power, damageType, power budget metadata to ENEMY_ABILITIES
│   └── ENEMY_ABILITIES object        # Add: power: bigint, damageType, dotPowerSplit?, directPowerFraction?, aoeTargets?
├── data/combat_scaling.ts            # EXISTING - already has AOE_DAMAGE_MULTIPLIER, DOT_SCALING_RATE_MODIFIER
│   └── Add enemy-specific constants  # ENEMY_LEVEL_POWER_SCALING (power per level), ENEMY_BASE_POWER
├── index.ts                          # EXTEND - executeEnemyAbility needs power scaling and budget logic
│   ├── executeEnemyAbility()         # EXTEND - apply level-based power scaling, power budget splits, AoE enumeration
│   ├── addCharacterEffect()          # EXISTING - already handles DoT/debuff to players (line 1767-1785)
│   ├── addEnemyEffect()              # EXISTING - already handles DoT/debuff to enemies (line 1787-1815)
│   └── sumCharacterEffect()          # EXISTING - already sums effect bonuses (line 1846-1852)
├── reducers/combat.ts                # EXISTING - tick reducers already process effects
│   ├── tick_hot (3s interval)        # EXISTING - processes 'regen' and 'dot' for players (line 1240+)
│   └── tick_effects (10s interval)   # EXISTING - processes buffs/debuffs (line 1141+)
└── views/effects.ts                  # EXISTING - client views for effects
```

**Key insight:** Infrastructure for enemy abilities already exists. This phase adds:
1. Power scaling formulas (level-based, no stats)
2. Power budget splits (DoT/debuff reduce direct damage)
3. New ability types (healing, AoE)
4. Damage type routing (physical vs magic)

---

### Pattern 1: Enemy Level-Based Power Scaling

**What:** Enemy ability damage scales with enemy level only, using fixed formula without stats.

**When to use:** All enemy abilities (damage, healing, debuff magnitude).

**Constants (add to data/combat_scaling.ts):**
```typescript
/**
 * Enemy ability power per level (5n per level)
 * Enemies gain consistent power scaling without stats
 */
export const ENEMY_LEVEL_POWER_SCALING = 5n;  // Per level

/**
 * Enemy base ability power (level 1 baseline)
 * Starting power for level 1 enemies
 */
export const ENEMY_BASE_POWER = 10n;  // Flat base at level 1
```

**Implementation:**
```typescript
// In executeEnemyAbility (index.ts:3071+)
const enemyTemplate = ctx.db.enemyTemplate.id.find(enemy.enemyTemplateId);
const enemyLevel = enemyTemplate?.level ?? 1n;

// Power formula: BASE + (LEVEL * SCALING)
const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);

// Example: Level 1 = 10 + (1 * 5) = 15 power
//          Level 5 = 10 + (5 * 5) = 35 power
//          Level 10 = 10 + (10 * 5) = 60 power
```

**Why this pattern:**
- User decision: "Enemy ability damage scales by enemy level only"
- User decision: "Enemies do NOT have stats (no STR/DEX/INT/WIS affecting their abilities)"
- Simpler than player system (no stat scaling complexity)
- Predictable progression for game balance

**Source:** User decision + existing enemy auto-attack level scaling pattern (combat.ts:2176-2179)

---

### Pattern 2: Enemy Power Budget Split (DoT/Debuff)

**What:** Enemies with DoT or debuff abilities deal reduced direct damage, just like players.

**When to use:** All enemy abilities that apply DoTs or debuffs.

**Metadata extension (in data/ability_catalog.ts):**
```typescript
export const ENEMY_ABILITIES = {
  poison_bite: {
    name: 'Poison Bite',
    castSeconds: 3n,
    cooldownSeconds: 20n,
    kind: 'dot',
    magnitude: 2n,
    rounds: 3n,
    // NEW: Power budget metadata
    power: 4n,                    // Total power budget for this ability
    dotPowerSplit: 0.5,           // 50% of power goes to DoT (vs 50% direct damage)
    damageType: 'physical' as DamageType,
    aiChance: 50,
    aiWeight: 70,
    aiRandomness: 15,
  },
  sapping_chant: {
    name: 'Sapping Chant',
    castSeconds: 2n,
    cooldownSeconds: 20n,
    kind: 'debuff',
    effectType: 'ac_bonus',
    magnitude: -2n,
    rounds: 3n,
    // NEW: Power budget metadata
    power: 3n,                    // Total power budget
    debuffPowerCost: 0.3,         // 30% of power consumed by debuff
    damageType: 'physical' as DamageType,
    aiChance: 45,
    aiWeight: 60,
    aiRandomness: 20,
  },
};
```

**Implementation (in executeEnemyAbility):**
```typescript
// Calculate scaled power from level
const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
const abilityPower = ability.power ?? 3n;  // Ability-specific power rating
const totalPower = enemyPower + abilityPower;

// Apply power budget split for DoT abilities
if (ability.kind === 'dot' && ability.dotPowerSplit) {
  const directFraction = 1.0 - ability.dotPowerSplit;
  const directDamage = (totalPower * BigInt(Math.floor(directFraction * 100))) / 100n;

  const dotFraction = ability.dotPowerSplit;
  const dotTotalDamage = (totalPower * BigInt(Math.floor(dotFraction * 100))) / 100n;
  const dotPerTick = dotTotalDamage / ability.rounds;

  // Apply direct damage if ability has any
  if (directDamage > 0n) {
    applyDirectDamage(ctx, target, directDamage, ability.damageType);
  }

  // Apply DoT effect
  addCharacterEffect(ctx, target.id, 'dot', dotPerTick, ability.rounds, ability.name);
}

// Apply power budget cost for debuff abilities
if (ability.kind === 'debuff' && ability.debuffPowerCost) {
  const damageFraction = 1.0 - ability.debuffPowerCost;
  const directDamage = (totalPower * BigInt(Math.floor(damageFraction * 100))) / 100n;

  // Apply reduced direct damage
  if (directDamage > 0n) {
    applyDirectDamage(ctx, target, directDamage, ability.damageType);
  }

  // Apply fixed magnitude debuff
  const effectType = (ability as any).effectType ?? 'ac_bonus';
  addCharacterEffect(ctx, target.id, effectType, ability.magnitude, ability.rounds, ability.name);
}
```

**Why this pattern:**
- User decision: "Enemies use the same power budget system as players"
- User decision: "Enemy abilities with DoTs/debuffs use power budget split (reduced direct damage)"
- Creates same tradeoffs as player abilities (DoT-heavy = less burst)
- Prevents enemies from having both full auto-attack AND full-power DoTs

**Source:** User decision + Phase 3.1.1 player power budget pattern (03.1.1-RESEARCH.md:186-235)

---

### Pattern 3: Enemy Healing Abilities

**What:** Some enemies can heal allies using same power budget split as player healing.

**When to use:** Enemy healer types (shamans, clerics, support enemies).

**Metadata (add to ENEMY_ABILITIES):**
```typescript
export const ENEMY_ABILITIES = {
  // ... existing abilities

  shaman_heal: {
    name: 'Shaman Heal',
    castSeconds: 2n,
    cooldownSeconds: 15n,
    kind: 'heal',
    power: 5n,
    healPowerSplit: 0.6,          // 60% direct heal, 40% HoT
    hotDuration: 3n,              // 3 ticks = 9 seconds of HoT
    targetRule: 'lowest_hp',      // Target ally with lowest HP
    aiChance: 70,                 // High chance to cast when available
    aiWeight: 80,
    aiRandomness: 10,
  },
};
```

**Implementation:**
```typescript
// In executeEnemyAbility, add 'heal' kind handling
if (ability.kind === 'heal') {
  const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
  const abilityPower = ability.power ?? 3n;
  const totalPower = enemyPower + abilityPower;

  // Find lowest HP ally enemy in combat
  const allies = [...ctx.db.combatEnemy.by_combat.filter(combatId)]
    .filter(e => e.currentHp > 0n)
    .sort((a, b) => a.currentHp > b.currentHp ? 1 : -1);
  const healTarget = allies[0];

  if (!healTarget) return;

  // Apply power budget split
  const directHealFraction = ability.healPowerSplit ?? 1.0;
  const directHeal = (totalPower * BigInt(Math.floor(directHealFraction * 100))) / 100n;
  const nextHp = healTarget.currentHp + directHeal > healTarget.maxHp
    ? healTarget.maxHp
    : healTarget.currentHp + directHeal;

  ctx.db.combatEnemy.id.update({ ...healTarget, currentHp: nextHp });

  // Apply HoT if split specified
  if (ability.hotDuration && ability.healPowerSplit < 1.0) {
    const hotFraction = 1.0 - ability.healPowerSplit;
    const hotTotal = (totalPower * BigInt(Math.floor(hotFraction * 100))) / 100n;
    const hotPerTick = hotTotal / ability.hotDuration;

    addEnemyEffect(ctx, combatId, healTarget.id, 'regen', hotPerTick, ability.hotDuration, ability.name);
  }

  // Log healing event
  logGroupEvent(ctx, combatId, target.id, 'heal', `${enemyName} heals ${healTarget.displayName} for ${directHeal}.`);
}
```

**Why this pattern:**
- User decision: "Enemy healers exist — some enemy types (shamans, clerics) can heal allies"
- User decision: "Enemy healing uses the same power budget split as player healing (direct heal + HoT)"
- Mirrors player healing mechanics for consistency
- Creates tactical healing enemies (players must prioritize killing healers)

**Source:** User decision + Phase 3.1 player healing pattern (combat_scaling.ts:284-295)

---

### Pattern 4: Enemy AoE Abilities (Direct Damage Only)

**What:** Some enemies can hit multiple players with one ability, using reduced damage per target.

**When to use:** Enemy AoE specialists (area attackers, boss enemies).

**Metadata (add to ENEMY_ABILITIES):**
```typescript
export const ENEMY_ABILITIES = {
  // ... existing abilities

  flame_burst: {
    name: 'Flame Burst',
    castSeconds: 2n,
    cooldownSeconds: 20n,
    kind: 'aoe_damage',
    power: 6n,
    damageType: 'magic' as DamageType,
    aoeTargets: 'all_players',    // Hit all players in combat
    aoeDamageMultiplier: 0.65,    // 65% damage per target (same as players)
    aiChance: 50,
    aiWeight: 75,
    aiRandomness: 15,
  },
};
```

**Implementation:**
```typescript
// In executeEnemyAbility, add 'aoe_damage' kind handling
if (ability.kind === 'aoe_damage') {
  const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
  const abilityPower = ability.power ?? 3n;
  const totalPower = enemyPower + abilityPower;

  const aoeMultiplier = ability.aoeDamageMultiplier ?? AOE_DAMAGE_MULTIPLIER / 100n;
  const perTargetDamage = (totalPower * BigInt(Math.floor(aoeMultiplier * 100))) / 100n;

  // Enumerate all players in combat
  const participants = [...ctx.db.combatParticipant.by_combat.filter(combatId)]
    .filter(p => p.status === 'active');

  for (const participant of participants) {
    const targetChar = ctx.db.character.id.find(participant.characterId);
    if (!targetChar || targetChar.hp === 0n) continue;

    // Apply damage with armor mitigation
    const effectiveArmor = targetChar.armorClass + sumCharacterEffect(ctx, targetChar.id, 'ac_bonus');
    const damageType = ability.damageType ?? 'physical';

    let finalDamage = perTargetDamage;
    if (damageType === 'physical') {
      finalDamage = applyArmorMitigation(perTargetDamage, effectiveArmor);
    } else if (damageType === 'magic') {
      const magicResist = sumCharacterEffect(ctx, targetChar.id, 'magic_resist');
      finalDamage = applyMagicResistMitigation(perTargetDamage, magicResist);
    }

    const nextHp = targetChar.hp > finalDamage ? targetChar.hp - finalDamage : 0n;
    ctx.db.character.id.update({ ...targetChar, hp: nextHp });

    // Log damage event
    appendPrivateEvent(ctx, targetChar.id, targetChar.ownerUserId, 'damage',
      `${enemyName} hits you with ${ability.name} for ${finalDamage}.`);

    if (targetChar.groupId) {
      appendGroupEvent(ctx, targetChar.groupId, targetChar.id, 'damage',
        `${enemyName} hits ${targetChar.name} with ${ability.name} for ${finalDamage}.`);
    }
  }
}
```

**Why this pattern:**
- User decision: "Enemy AoE abilities exist — some enemies can hit multiple players with one ability"
- User decision: "Enemy AoE uses 65% damage per target (same AOE_DAMAGE_MULTIPLIER as player AoE)"
- User decision: "No target cap — enemy AoE hits all players in the group"
- User decision: "Enemy AoE cannot apply DoTs — AoE abilities deal direct damage only"
- Creates dangerous group encounters (players must spread out or mitigate AoE)

**Source:** User decision + Phase 3.1.1 player AoE pattern (03.1.1-RESEARCH.md:431-465)

---

### Pattern 5: Enemy Damage Type Routing (Physical vs Magic)

**What:** Enemy abilities use `damageType` to route through armor or magic resist mitigation.

**When to use:** All enemy damage abilities.

**Implementation:**
```typescript
// In executeEnemyAbility, apply damage type routing
function applyEnemyDamage(
  ctx: any,
  target: typeof Character.rowType,
  baseDamage: bigint,
  damageType: DamageType,
  abilityName: string,
  enemyName: string
) {
  let finalDamage = baseDamage;

  if (damageType === 'physical') {
    const effectiveArmor = target.armorClass + sumCharacterEffect(ctx, target.id, 'ac_bonus');
    finalDamage = applyArmorMitigation(baseDamage, effectiveArmor);
  } else if (damageType === 'magic') {
    const magicResist = sumCharacterEffect(ctx, target.id, 'magic_resist');
    finalDamage = applyMagicResistMitigation(baseDamage, magicResist);
  }

  const nextHp = target.hp > finalDamage ? target.hp - finalDamage : 0n;
  ctx.db.character.id.update({ ...target, hp: nextHp });

  return finalDamage;
}
```

**Why this pattern:**
- Enemies need same damage type system as players (physical vs magic)
- Magic enemies bypass armor (consistent with player magic abilities)
- Physical enemies respect armor mitigation (consistent with player melee)
- Already implemented for players in Phase 3.1 (combat_scaling.ts:303-306)

**Source:** Phase 3.1 damage type system + existing player ability damage routing

---

### Pattern 6: Enemy Buff Abilities (Support Enemies)

**What:** Some enemies can buff allies (damage up, armor up, etc.), costing power budget.

**When to use:** Enemy support types (warchiefs, commanders, buff specialists).

**Metadata (add to ENEMY_ABILITIES):**
```typescript
export const ENEMY_ABILITIES = {
  // ... existing abilities

  warchief_rally: {
    name: 'Warchief Rally',
    castSeconds: 2n,
    cooldownSeconds: 30n,
    kind: 'buff',
    effectType: 'damage_bonus',   // Buff type (damage_bonus, armor_up, etc.)
    magnitude: 5n,                // +5 damage for allies
    rounds: 5n,                   // 5 ticks = 15 seconds
    power: 0n,                    // Buffs cost power budget (no direct damage)
    targetRule: 'all_allies',     // Buff all allies in combat
    aiChance: 60,
    aiWeight: 70,
    aiRandomness: 15,
  },
};
```

**Implementation:**
```typescript
// In executeEnemyAbility, add 'buff' kind handling
if (ability.kind === 'buff') {
  const allies = [...ctx.db.combatEnemy.by_combat.filter(combatId)]
    .filter(e => e.currentHp > 0n);

  const effectType = (ability as any).effectType ?? 'damage_bonus';
  const magnitude = ability.magnitude ?? 0n;
  const duration = ability.rounds ?? 3n;

  for (const ally of allies) {
    addEnemyEffect(ctx, combatId, ally.id, effectType, magnitude, duration, ability.name);
  }

  // Log buff event
  logGroupEvent(ctx, combatId, target.id, 'ability',
    `${enemyName} rallies allies with ${ability.name}!`);
}
```

**Why this pattern:**
- User decision: "Enemy buffs exist — some enemies can buff allies (damage up, armor up, etc.)"
- User decision: "Enemy buffs cost power budget like player buffs (buffs reduce direct damage)"
- Creates priority targets (players want to kill buff enemies early)
- Uses same effect tracking infrastructure as debuffs

**Source:** User decision + existing debuff pattern (index.ts:3099-3108)

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Enemy effect ticking | Custom timer for enemy effects | Existing `tick_hot` and `tick_effects` reducers | Already handles CharacterEffect and CombatEnemyEffect globally |
| Enemy effect stacking | New stacking rules for enemies | Existing `addCharacterEffect()` and `addEnemyEffect()` | Already handles refresh vs stack logic |
| Power scaling formulas | Complex stat-based system | Level-only formula (BASE + LEVEL * SCALING) | User decision: enemies don't have stats, simpler balance |
| Damage type mitigation | Custom armor/resist formulas | Existing `applyArmorMitigation()` and `applyMagicResistMitigation()` | Already implemented in Phase 3.1 |
| AoE target enumeration | Custom target selection | Existing `combatParticipant.by_combat.filter()` | Already used for player AoE abilities |
| Effect tracking tables | New enemy-only effect tables | Existing `CharacterEffect` and `CombatEnemyEffect` | Already stores all effect types with sourceAbility tracking |

**Key insight:** Almost all infrastructure exists. This phase is about:
1. Extending enemy ability metadata (power, damageType, power splits)
2. Adding power scaling formulas to `executeEnemyAbility`
3. Implementing new ability kinds (heal, aoe_damage, buff)

---

## Common Pitfalls

### Pitfall 1: Applying Stat Scaling to Enemy Abilities

**What goes wrong:** Treating enemies like players and trying to give them STR/DEX/INT stats to scale abilities.

**Why it happens:** Player abilities use stat scaling, easy to assume enemies need same system.

**How to avoid:** User decision is explicit: "Enemies do NOT have stats (no STR/DEX/INT/WIS affecting their abilities) — damage is purely level + power rating." Use level-only formula.

**Warning signs:** Enemy damage varying unexpectedly, balance issues at different levels, complexity in enemy templates.

**Example:**
```typescript
// ❌ WRONG: Trying to scale with stats
const enemyPower = ENEMY_BASE_POWER + (enemy.str * STAT_SCALING);

// ✅ RIGHT: Level-only scaling
const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
```

---

### Pitfall 2: Forgetting Power Budget Split for Enemy DoTs

**What goes wrong:** Enemy DoT abilities deal full direct damage AND apply full-power DoTs, making them overpowered.

**Why it happens:** Current `executeEnemyAbility` (index.ts:3091-3098) applies DoT without reducing direct damage.

**How to avoid:** Apply power budget split just like player DoTs: `directDamage = totalPower * (1 - dotPowerSplit)`.

**Warning signs:** Enemies with DoTs dramatically outperforming enemies without DoTs, players complaining about DoT spam.

**Example:**
```typescript
// ❌ WRONG: Full power to both direct and DoT
const directDamage = totalPower;
const dotDamage = ability.magnitude;  // Fixed magnitude ignores power budget

// ✅ RIGHT: Split power between direct and DoT
const directDamage = (totalPower * (100n - dotPowerSplit)) / 100n;
const dotTotal = (totalPower * dotPowerSplit) / 100n;
const dotPerTick = dotTotal / ability.rounds;
```

---

### Pitfall 3: Allowing Enemy AoE to Apply DoTs

**What goes wrong:** Enemy AoE abilities that apply DoTs overwhelm groups (every player gets DoT ticking).

**Why it happens:** Player AoE abilities can include DoTs (e.g., Druid Bramble), easy to assume enemies can too.

**How to avoid:** User decision is explicit: "Enemy AoE cannot apply DoTs — AoE abilities deal direct damage only, no periodic effects."

**Warning signs:** Group wipes due to stacked DoTs, healers unable to keep up with multi-target DoT pressure.

**Example:**
```typescript
// ❌ WRONG: AoE ability with DoT component
if (ability.kind === 'aoe_damage' && ability.dotPowerSplit) {
  // Apply DoT to all players — OVERWHELMING
}

// ✅ RIGHT: AoE direct damage only
if (ability.kind === 'aoe_damage') {
  // Apply direct damage per target
  // NO DoT application for AoE abilities
}
```

---

### Pitfall 4: Scaling Enemy Damage with Group Size

**What goes wrong:** Enemy damage increasing when fighting more players (to compensate for group advantage).

**Why it happens:** Trying to balance enemy threat against solo vs group play.

**How to avoid:** User decision is explicit: "No group size scaling — enemy damage is the same whether fighting 1 player or 5 players."

**Warning signs:** Enemy damage calculations checking participant count, balance complaints from solo players.

**Example:**
```typescript
// ❌ WRONG: Scaling with group size
const groupSize = participants.length;
const scaledDamage = baseDamage * BigInt(groupSize);

// ✅ RIGHT: Fixed damage regardless of group
const finalDamage = baseDamage;  // Same for 1 player or 5 players
```

---

### Pitfall 5: Not Using Existing Tick Infrastructure

**What goes wrong:** Creating custom scheduled reducers for enemy DoTs/HoTs instead of using existing system.

**Why it happens:** Thinking enemy effects need separate processing from player effects.

**How to avoid:** User decision: "Enemy DoTs/debuffs follow the same rules as player effects: 3-second tick rate (same tick_hot scheduled reducer)." Use `addCharacterEffect()` for DoTs to players, `addEnemyEffect()` for effects to enemies.

**Warning signs:** Creating new scheduled tables, duplicate tick logic, effects ticking at different rates.

**Example:**
```typescript
// ❌ WRONG: Custom enemy DoT tick system
ctx.db.enemyDotTick.insert({ ... });  // New scheduled table

// ✅ RIGHT: Use existing CharacterEffect + tick_hot
addCharacterEffect(ctx, targetPlayerId, 'dot', dotPerTick, rounds, abilityName);
// Existing tick_hot reducer (combat.ts:1240+) processes this automatically
```

---

### Pitfall 6: Fixed Magnitude Values Instead of Power Scaling

**What goes wrong:** Enemy abilities use hardcoded magnitude values (e.g., `magnitude: 2n`) that don't scale with enemy level.

**Why it happens:** Current system (index.ts:3091-3098) uses `ability.magnitude` directly without scaling.

**How to avoid:** Calculate magnitude from enemy level + ability power, then apply to effects.

**Warning signs:** Level 1 enemies dealing same DoT damage as level 10 enemies, flat difficulty curve.

**Example:**
```typescript
// ❌ WRONG: Fixed magnitude from metadata
const dotDamage = ability.magnitude;  // Always 2n regardless of level

// ✅ RIGHT: Scaled magnitude from power calculation
const enemyPower = ENEMY_BASE_POWER + (enemyLevel * ENEMY_LEVEL_POWER_SCALING);
const dotTotal = (enemyPower * dotPowerSplit) / 100n;
const dotPerTick = dotTotal / ability.rounds;
```

---

## Code Examples

Verified patterns from existing codebase:

### Current Enemy DoT Application (index.ts:3091-3098)
```typescript
// Source: index.ts:3091-3098
if (ability.kind === 'dot') {
  addCharacterEffect(ctx, target.id, 'dot', ability.magnitude, ability.rounds, ability.name);
  const privateMessage = `${enemyName} uses ${ability.name} on you.`;
  const groupMessage = `${enemyName} uses ${ability.name} on ${target.name}.`;
  appendPrivateEvent(ctx, target.id, target.ownerUserId, 'damage', privateMessage);
  if (target.groupId) {
    appendGroupEvent(ctx, target.groupId, target.id, 'damage', groupMessage);
  }
}
```

**Key insight:** Basic DoT application exists but uses fixed `ability.magnitude` without power scaling or budget splits.

---

### Enemy Auto-Attack Level Scaling (combat.ts:2176-2182)
```typescript
// Source: combat.ts:2176-2182
const enemyLevel = enemyTemplate?.level ?? 1n;
const levelDiff = enemyLevel > targetCharacter.level ? enemyLevel - targetCharacter.level : 0n;
const damageMultiplier = 100n + levelDiff * 20n;
const debuff = sumEnemyEffect(ctx, combat.id, 'damage_down', enemy.id);
const baseDamage = enemySnapshot.attackDamage + debuff;
const scaledDamage = (baseDamage * damageMultiplier) / 100n;
```

**Key insight:** Enemy auto-attacks already use level-based scaling with multipliers. Abilities should follow similar pattern.

---

### Player Ability Power Budget Split (Phase 3.1.1 pattern)
```typescript
// Based on Phase 3.1.1 pattern (not in codebase yet, planned)
const directPowerFraction = abilityEntry.dotPowerSplit
  ? 1.0 - abilityEntry.dotPowerSplit
  : 1.0;
const directDamage = (scaledAbilityDamage * BigInt(Math.floor(directPowerFraction * 100))) / 100n;

if (abilityEntry.dotPowerSplit && abilityEntry.dotDuration) {
  const dotPowerFraction = abilityEntry.dotPowerSplit;
  const dotTotalDamage = (scaledAbilityDamage * BigInt(Math.floor(dotPowerFraction * 100))) / 100n;
  const dotDamagePerTick = dotTotalDamage / abilityEntry.dotDuration;

  addEnemyEffect(ctx, combatId, enemy.id, 'dot', dotPerTickScaled, abilityEntry.dotDuration, abilityEntry.name);
}
```

**Key insight:** Player DoT power budget split pattern that enemies should mirror (without stat scaling component).

---

### Existing Effect Stacking Logic (index.ts:1767-1785)
```typescript
// Source: index.ts:1767-1785
function addCharacterEffect(
  ctx: any,
  characterId: bigint,
  effectType: string,
  magnitude: bigint,
  roundsRemaining: bigint,
  sourceAbility?: string
) {
  const existing = [...ctx.db.characterEffect.by_character.filter(characterId)].find(
    (effect) => effect.effectType === effectType && effect.sourceAbility === sourceAbility
  );
  if (existing) {
    ctx.db.characterEffect.id.update({ ...existing, magnitude, roundsRemaining });
    return;
  }
  ctx.db.characterEffect.insert({
    id: 0n,
    characterId,
    effectType,
    magnitude,
    roundsRemaining,
    sourceAbility,
  });
}
```

**Key insight:** Same `sourceAbility` refreshes duration, different `sourceAbility` stacks. Enemy abilities use same logic.

---

### HotTick Reducer Processing Effects (combat.ts:1240-1300)
```typescript
// Source: combat.ts:1240-1300 (simplified)
spacetimedb.reducer('tick_hot', { arg: HotTick.rowType }, (ctx) => {
  for (const effect of ctx.db.characterEffect.iter()) {
    if (effect.effectType !== 'regen' && effect.effectType !== 'dot') continue;
    if (effect.roundsRemaining === 0n) continue;

    const owner = ctx.db.character.id.find(effect.characterId);
    if (!owner) continue;

    if (effect.effectType === 'regen') {
      const nextHp = owner.hp + effect.magnitude > owner.maxHp ? owner.maxHp : owner.hp + effect.magnitude;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
    } else if (effect.effectType === 'dot') {
      const nextHp = owner.hp > effect.magnitude ? owner.hp - effect.magnitude : 0n;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
    }

    const remaining = effect.roundsRemaining - 1n;
    if (remaining === 0n) {
      ctx.db.characterEffect.id.delete(effect.id);
    } else {
      ctx.db.characterEffect.id.update({ ...effect, roundsRemaining: remaining });
    }
  }

  ctx.db.hotTick.insert({
    scheduledId: 0n,
    scheduledAt: ScheduleAt.time(ctx.timestamp.microsSinceUnixEpoch + HOT_TICK_MICROS),
  });
});
```

**Key insight:** Single reducer handles both DoT and HoT ticking for all characters. Enemy DoTs/HoTs to players piggyback on this existing system.

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Fixed enemy damage values | Level-based enemy scaling | Phase 03.1.2 | Enemy damage progresses naturally with player level |
| Enemy DoTs as bonus damage | Enemy DoTs use power budget | Phase 03.1.2 | Enemy DoT abilities balanced vs direct damage abilities |
| Enemies cannot heal | Enemy healers exist | Phase 03.1.2 | Creates priority targets, tactical depth |
| Single-target enemy abilities | Enemy AoE abilities | Phase 03.1.2 | Group content becomes more dangerous, requires coordination |

**Deprecated/outdated:**
- **Fixed magnitude enemy abilities:** Modern RPG enemy design scales abilities with level for consistent challenge curve (World of Warcraft, Final Fantasy XIV)
- **Enemies without support abilities:** Modern games use enemy healers/buffers to create tactical priority targets (Guild Wars 2, Elder Scrolls Online)

---

## Open Questions

1. **Exact enemy power scaling constants?**
   - What we know: Enemies scale by level only, no stats
   - What's unclear: Exact values for ENEMY_BASE_POWER and ENEMY_LEVEL_POWER_SCALING
   - Recommendation: Start with ENEMY_BASE_POWER = 10n, ENEMY_LEVEL_POWER_SCALING = 5n (similar to player power = level * 5), tune via playtesting

2. **Should enemy healing scale differently than damage?**
   - What we know: Enemy healing uses power budget split like player healing
   - What's unclear: Should healing power use same constants or separate scaling?
   - Recommendation: Use same power scaling (consistency), balance via power budget splits

3. **How many enemies should have AoE abilities?**
   - What we know: Enemy AoE exists, hits all players at 65% per target
   - What's unclear: What % of enemy types should have AoE? Boss-only or common?
   - Recommendation: AoE for elite/boss enemies only (10-15% of enemy types), prevents AoE spam in normal fights

4. **Should enemy buff abilities stack from multiple casters?**
   - What we know: Enemy buffs use effect system (addEnemyEffect)
   - What's unclear: Do multiple rally casts stack or refresh?
   - Recommendation: Follow existing effect stacking rules (same sourceAbility refreshes, different sourceAbilities stack)

---

## Sources

### Primary (HIGH confidence)
- **Existing codebase patterns:**
  - `spacetimedb/src/index.ts` (executeEnemyAbility, effect helpers, existing enemy DoT/debuff)
  - `spacetimedb/src/reducers/combat.ts` (enemy auto-attack scaling, tick reducers, combat loop)
  - `spacetimedb/src/data/ability_catalog.ts` (ENEMY_ABILITIES catalog with 30+ abilities)
  - `spacetimedb/src/data/combat_scaling.ts` (AOE_DAMAGE_MULTIPLIER, DOT_SCALING_RATE_MODIFIER, damage mitigation)
- **Phase 3.1.1 RESEARCH.md:** Player DoT/HoT/debuff/AoE power budget patterns (template for enemies)
- **User decisions from CONTEXT.md:** All enemy scaling, power budget, healing, AoE rules

### Secondary (MEDIUM confidence)
None needed — all research based on existing codebase and user decisions.

### Tertiary (LOW confidence)
None — high confidence in all findings.

---

## Metadata

**Confidence breakdown:**
- Enemy power scaling: HIGH - extends existing enemy auto-attack level scaling pattern
- Power budget splits: HIGH - mirrors Phase 3.1.1 player pattern without stat complexity
- Enemy healing: HIGH - uses same infrastructure as player healing (effect system, tick reducers)
- Enemy AoE: HIGH - uses existing participant enumeration and AoE multiplier constant
- Effect stacking: HIGH - existing infrastructure already handles all use cases

**Research date:** 2026-02-12
**Valid until:** 30 days (stable system, extension of existing patterns)
