# Phase 3.1.1: Combat Balance Part 2 (DoT/HoT/Debuff/Buff) - Research

**Researched:** 2026-02-12
**Domain:** DoT/HoT periodic effects, debuff/buff balance, power budget system, AoE mechanics
**Confidence:** HIGH

## Summary

Phase 3.1.1 extends the stat scaling foundation from Phase 3.1 to cover periodic effects (DoT/HoT), debuffs, buffs, and AoE abilities. The existing combat system already has a complete effect infrastructure: `CharacterEffect` and `CombatEnemyEffect` tables, scheduled tick reducers (`tick_hot` every 3 seconds, `tick_effects` every 10 seconds), and stacking/refresh logic. Enemy abilities already demonstrate DoT and debuff patterns that can be extended to player abilities.

**Current state analysis:**
- **Effect tables exist:** `CharacterEffect` (index.ts:927-941) and `CombatEnemyEffect` (index.ts:943-961) store `effectType`, `magnitude`, `roundsRemaining`, `sourceAbility`
- **Tick system exists:** `HotTick` scheduled table ticks every 3 seconds (combat.ts:1081), already handles `regen` and `dot` effectTypes
- **Effect helpers exist:** `addCharacterEffect()` (index.ts:1758), `addEnemyEffect()` (index.ts:1787), `sumCharacterEffect()` (index.ts:1846), `sumEnemyEffect()` (index.ts:1854)
- **Stacking/refresh logic exists:** `addCharacterEffect` refreshes duration if same `characterId + effectType + sourceAbility` (index.ts:1767-1775)
- **Enemy DoTs/debuffs exist:** Enemy abilities already use DoT (`kind: 'dot'`) and debuff (`kind: 'debuff'`) patterns (ability_catalog.ts:809-1116)
- **Stat scaling exists:** Phase 3.1 established `getAbilityStatScaling()` and `getAbilityMultiplier()` (combat_scaling.ts:226-256)
- **Ability damage formula exists:** Hybrid formula `(base + stat_scaling) * ability_multiplier / 100` (index.ts:2044-2057)

**Primary recommendation:** Extend ability catalog to add DoT/HoT/debuff/AoE metadata fields, split ability power budgets between direct damage and periodic/utility effects, scale DoT/HoT damage using same stat system as direct damage (with reduced scaling rate), and implement AoE target enumeration with per-target damage reduction.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**DoT Damage Scaling:**
- DoTs scale with the same stat as the ability's direct damage (Shadow Cut is STR, so its DoT also scales with STR)
- DoTs use reduced scaling rate compared to direct damage (account for multiple ticks - prevents double-dipping power)
- Power budget split approach: ability power is divided between direct damage and DoT
  - Example: Shadow Cut (power=4) might be 60% direct damage, 40% DoT total damage
  - Different abilities can use different splits (70/30 burst-heavy, 30/70 DoT-heavy)
  - Enables unique ability design across classes

**Debuff Magnitude Scaling:**
- Fixed magnitudes: debuffs have consistent power regardless of stats (predictable, tactical)
- Fixed durations: debuff duration does not scale with stats or ability power (consistent across all uses)
- Debuffs cost power budget: abilities with debuffs deal reduced damage proportionally
- All debuff types cost the same power budget: AC reduction, slow, damage amp - all cost flat % of power (simplifies balance)

**Duration vs Power Tradeoff:**
- Longer DoTs = same total damage, spread over more ticks
  - 3-tick DoT and 6-tick DoT with same power budget deal same total, just distributed differently
- Cast time bonus applies equally: long-cast DoT/debuff abilities get same power multiplier as direct damage
- Cooldown bonus applies equally: long-CD DoTs/debuffs get same power boost as direct damage
- Fixed tick rate: all DoTs tick every 3 seconds (predictable rhythm)

**AoE (Area of Effect) Balance:**
- AoE costs power budget: AoE abilities deal less damage per target than single-target (e.g., 60-70%)
- No target cap: AoE abilities hit unlimited enemies in range (balanced by reduced damage per target)
- Single tax: AoE abilities pay only the AoE cost - adding DoT/debuff to AoE doesn't further reduce power
- AoE buffs cost power budget: group buffs deal no damage or have reduced combat effectiveness

**HoT (Heal over Time) and Healing Balance:**
- HoTs mirror DoT rules: same stat scaling (WIS from Phase 3.1), reduced scaling rate, power budget split
- Direct heal + HoT power split: uses same power budget split approach as damage abilities
- HoTs tick at same rate as DoTs: every 3 seconds (unified rhythm for all periodic effects)
- AoE heals cost power budget: group heals heal for less per target, same as AoE damage cost

**Effect Stacking & Refresh:**
- Same ability refreshes duration: recasting the same DoT/HoT resets timer, doesn't stack damage
- Different abilities stack: Shadow Cut DoT + Plague Spark DoT both run simultaneously
- Same type stacks fully: multiple AC reduction debuffs stack additively (-5 AC + -3 AC = -8 AC)
- Different players stack: Player A's Shadow Cut + Player B's Shadow Cut = both DoTs run

### Claude's Discretion

- Exact power budget split percentages per ability (designer flexibility for unique abilities)
- AoE damage reduction percentage (60-70% range)
- Specific debuff magnitude values (balance through testing)
- DoT/HoT reduced scaling rate factor (balance total vs burst damage)

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed focused on DoT/HoT/debuff/buff balance within Phase 3.1.1 scope.
</user_constraints>

---

## Standard Stack

### Core Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SpacetimeDB | 1.11.x | Database/backend | Already in use, no new dependencies needed |
| BigInt arithmetic | Native | DoT/HoT calculations | SpacetimeDB uses bigint for all numeric values |

### Supporting

No additional libraries needed. This phase extends existing combat reducer logic and ability catalog.

### Installation

No new packages required. All work is in existing `spacetimedb/src/` TypeScript files.

---

## Architecture Patterns

### Recommended Code Structure

```
spacetimedb/src/
├── data/ability_catalog.ts           # EXTEND - add DoT/HoT/debuff/AoE metadata per ability
│   ├── ABILITIES object              # Add: dotPowerSplit?, dotDuration?, debuffType?, aoeTargets?
│   └── ENEMY_ABILITIES object        # EXISTING pattern to follow (already has DoT/debuff)
├── index.ts                          # EXTEND - power budget split logic in executeAbilityAction
│   ├── executeAbilityAction()        # EXTEND - split power, apply DoT/HoT/debuff from metadata
│   ├── addCharacterEffect()          # EXISTING - already handles stacking/refresh (line 1758)
│   ├── addEnemyEffect()              # EXISTING - already handles stacking/refresh (line 1787)
│   ├── applyDamage()                 # EXTEND - AoE target enumeration, per-target reduction
│   └── applyHeal()                   # EXTEND - AoE healing, per-target reduction
├── reducers/combat.ts                # EXISTING - tick reducers already process DoT/HoT
│   ├── tick_hot (3s interval)        # EXISTING - processes 'regen' and 'dot' effects (line 1240)
│   └── tick_effects (10s interval)   # EXISTING - processes buffs/debuffs (line 1141)
└── data/combat_scaling.ts            # EXTEND - add DoT/HoT scaling rate constants
    └── DOT_SCALING_RATE_MODIFIER     # NEW - reduced scaling rate for DoTs vs direct damage
```

### Pattern 1: Ability Metadata for DoT/HoT/Debuff/AoE

**What:** Extend ability catalog entries with optional metadata fields for periodic effects and AoE.

**When to use:** All abilities that have DoT, HoT, debuffs, or AoE components.

**Schema extension:**
```typescript
// In data/ability_catalog.ts
export interface AbilityMetadata {
  // Existing fields
  name: string;
  className: string;
  resource: string;
  level: bigint;
  power: bigint;
  cooldownSeconds: bigint;
  castSeconds: bigint;
  damageType: DamageType;

  // NEW: DoT/HoT metadata
  dotPowerSplit?: number;        // 0-1, fraction of power allocated to DoT total damage
  dotDuration?: bigint;          // Duration in "ticks" (1 tick = 3 seconds)
  hotPowerSplit?: number;        // 0-1, fraction of power allocated to HoT total healing
  hotDuration?: bigint;          // Duration in "ticks"

  // NEW: Debuff metadata
  debuffType?: string;           // 'ac_bonus' | 'damage_down' | 'armor_down' | 'slow'
  debuffMagnitude?: bigint;      // Fixed magnitude value
  debuffDuration?: bigint;       // Duration in "ticks"
  debuffPowerCost?: number;      // 0-1, fraction of power consumed by debuff

  // NEW: AoE metadata
  aoeTargets?: 'all_enemies' | 'all_allies' | 'all_party';  // Target type
  aoeDamageMultiplier?: number;  // 0-1, per-target damage multiplier (e.g., 0.65 = 65%)
}
```

**Example (Shadow Cut with DoT):**
```typescript
rogue_shadow_cut: {
  name: 'Shadow Cut',
  className: 'rogue',
  resource: 'stamina',
  level: 1n,
  power: 4n,
  cooldownSeconds: 4n,
  castSeconds: 0n,
  damageType: 'physical' as DamageType,
  dotPowerSplit: 0.4,        // 40% of power goes to DoT
  dotDuration: 2n,           // 2 ticks = 6 seconds total
},
```

**Why this pattern:**
- Declarative metadata keeps ability logic centralized (all power budget decisions in catalog)
- Enemy abilities already use this pattern (ability_catalog.ts:809-1116 has `kind`, `magnitude`, `rounds`)
- Enables per-ability tuning without changing core combat logic

**Source:** Existing enemy ability pattern (ability_catalog.ts:809-1116)

---

### Pattern 2: Power Budget Split for Direct + DoT/HoT

**What:** When ability has `dotPowerSplit` or `hotPowerSplit`, divide ability power between direct effect and periodic effect.

**When to use:** Abilities with both immediate damage/healing AND periodic effects (e.g., Shadow Cut, Spirit Mender).

**Implementation (in executeAbilityAction, index.ts:2020+):**
```typescript
// Current direct damage calculation (index.ts:2044-2057)
const abilityBaseDamage = abilityEntry ? abilityEntry.power * 5n : 0n;
const statScaling = getAbilityStatScaling(
  { str, dex, cha, wis, int },
  abilityKey,
  character.className
);
const abilityMultiplier = getAbilityMultiplier(
  abilityEntry.castSeconds,
  abilityEntry.cooldownSeconds
);
const scaledAbilityDamage = ((abilityBaseDamage + statScaling) * abilityMultiplier) / 100n;

// EXTEND: Power budget split
const directPowerFraction = abilityEntry.dotPowerSplit
  ? 1.0 - abilityEntry.dotPowerSplit
  : 1.0;
const directDamage = (scaledAbilityDamage * BigInt(Math.floor(directPowerFraction * 100))) / 100n;

// If DoT exists, calculate DoT damage per tick
if (abilityEntry.dotPowerSplit && abilityEntry.dotDuration) {
  const dotPowerFraction = abilityEntry.dotPowerSplit;
  const dotTotalDamage = (scaledAbilityDamage * BigInt(Math.floor(dotPowerFraction * 100))) / 100n;

  // DoT damage per tick = total DoT damage / duration (in ticks)
  const dotDamagePerTick = dotTotalDamage / abilityEntry.dotDuration;

  // Apply DoT with REDUCED stat scaling rate
  const dotStatScaling = (statScaling * DOT_SCALING_RATE_MODIFIER) / 100n;  // e.g., 50% of direct scaling
  const dotPerTickScaled = ((dotDamagePerTick + dotStatScaling) * abilityMultiplier) / 100n;

  addEnemyEffect(
    ctx,
    combatId,
    enemy.id,
    'dot',
    dotPerTickScaled,
    abilityEntry.dotDuration,
    abilityEntry.name
  );
}
```

**Example (Shadow Cut power=4, 60/40 split):**
- Total ability damage: `(20 + 30_STR) * 100% = 50 damage`
- Direct damage (60%): `50 * 0.6 = 30 damage`
- DoT total (40%): `50 * 0.4 = 20 damage`
- DoT per tick (2 ticks): `20 / 2 = 10 damage per tick`

**Why this pattern:**
- Matches user decision: "ability power is divided between direct damage and DoT"
- Different abilities use different splits (designer flexibility)
- Same total power output, just distributed differently over time

**Source:** User decision + [DoT balancing](https://www.gamedeveloper.com/design/balancing-damage-over-time-in-rpgs)

---

### Pattern 3: DoT/HoT Scaling with Reduced Rate

**What:** DoTs and HoTs use the same stat as direct damage, but with a reduced scaling rate to prevent double-dipping.

**When to use:** All DoT and HoT effects applied by player abilities.

**Constants (add to data/combat_scaling.ts):**
```typescript
/**
 * DoT/HoT stat scaling reduction factor (50% of direct damage scaling)
 * Prevents double-dipping: DoTs tick multiple times, so per-tick scaling is halved
 */
export const DOT_SCALING_RATE_MODIFIER = 50n;  // 50% on 100n scale
```

**Implementation:**
```typescript
// In executeAbilityAction when applying DoT
const baseStatScaling = getAbilityStatScaling(characterStats, abilityKey, className);
const dotStatScaling = (baseStatScaling * DOT_SCALING_RATE_MODIFIER) / 100n;

// Example: STR=30 → direct scaling = 30, DoT scaling = 15 per tick
```

**Why this pattern:**
- User decision: "DoTs use reduced scaling rate compared to direct damage"
- Prevents DoTs from becoming overpowered when ticking multiple times
- Same stat dependency as direct damage (Shadow Cut is STR, its DoT is also STR)

**Source:** User decision + standard MMO DoT scaling

---

### Pattern 4: Debuff Power Budget Cost

**What:** Abilities with debuffs deal reduced damage proportionally to debuff power cost.

**When to use:** Abilities that apply debuffs (AC reduction, slow, damage amp, etc.).

**Implementation:**
```typescript
// In executeAbilityAction
const debuffPowerCost = abilityEntry.debuffPowerCost ?? 0;
const damageAfterDebuffCost = directDamage * BigInt(Math.floor((1.0 - debuffPowerCost) * 100)) / 100n;

// Apply debuff with fixed magnitude
if (abilityEntry.debuffType && abilityEntry.debuffMagnitude && abilityEntry.debuffDuration) {
  addEnemyEffect(
    ctx,
    combatId,
    enemy.id,
    abilityEntry.debuffType,
    abilityEntry.debuffMagnitude,
    abilityEntry.debuffDuration,
    abilityEntry.name
  );
}
```

**Example (Hex with debuff):**
- Base damage: 40
- Debuff power cost: 25%
- Actual damage: `40 * 0.75 = 30 damage`
- Debuff applied: `-2 AC for 3 ticks` (fixed magnitude)

**Why this pattern:**
- User decision: "Debuffs cost power budget: abilities with debuffs deal reduced damage proportionally"
- User decision: "Fixed magnitudes: debuffs have consistent power regardless of stats"
- Creates tactical tradeoff: damage vs utility

**Source:** User decision

---

### Pattern 5: Effect Stacking and Refresh Logic

**What:** Same ability from same caster refreshes duration. Different abilities or different casters stack.

**When to use:** All DoT/HoT/buff/debuff applications.

**Existing implementation (index.ts:1767-1785):**
```typescript
function addCharacterEffect(
  ctx: any,
  characterId: bigint,
  effectType: string,
  magnitude: bigint,
  roundsRemaining: bigint,
  sourceAbility?: string
) {
  // Find existing effect with same characterId + effectType + sourceAbility
  const existing = [...ctx.db.characterEffect.by_character.filter(characterId)].find(
    (effect) => effect.effectType === effectType && effect.sourceAbility === sourceAbility
  );

  if (existing) {
    // REFRESH: update duration, magnitude stays the same
    ctx.db.characterEffect.id.update({ ...existing, roundsRemaining });
    return;
  }

  // STACK: insert new effect (different sourceAbility or different effectType)
  ctx.db.characterEffect.insert({
    id: 0n,
    characterId,
    effectType,
    magnitude,
    roundsRemaining,
    sourceAbility,
  });
}
```

**Stacking rules (already implemented correctly):**
- **Same ability refreshes:** Shadow Cut → Shadow Cut = duration resets to 2 ticks
- **Different abilities stack:** Shadow Cut DoT + Plague Spark DoT = both run simultaneously
- **Same type from different sources stacks:** Player A's Shadow Cut + Player B's Shadow Cut = both DoTs run (different `sourceAbility` values)
- **Same type debuffs stack additively:** Handled by `sumEnemyEffect()` which sums all matching `effectType`

**Why this pattern:**
- User decision: "Same ability refreshes duration", "Different abilities stack", "Different players stack"
- Already implemented correctly in existing codebase
- No changes needed, just document and use consistently

**Source:** Existing implementation (index.ts:1767-1785)

---

### Pattern 6: Fixed Tick Rate (3 Seconds)

**What:** All DoTs and HoTs tick every 3 seconds via the `HotTick` scheduled table.

**When to use:** All periodic effects.

**Existing implementation (combat.ts:1081, 1240-1345):**
```typescript
const HOT_TICK_MICROS = 3_000_000n;  // 3 seconds

spacetimedb.reducer('tick_hot', { arg: HotTick.rowType }, (ctx) => {
  for (const effect of ctx.db.characterEffect.iter()) {
    if (effect.effectType !== 'regen' && effect.effectType !== 'dot') continue;
    if (effect.roundsRemaining === 0n) continue;

    if (effect.effectType === 'regen') {
      // Apply HoT tick
      const nextHp = owner.hp + effect.magnitude > owner.maxHp ? owner.maxHp : owner.hp + effect.magnitude;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
    } else if (effect.effectType === 'dot') {
      // Apply DoT tick
      const nextHp = owner.hp > effect.magnitude ? owner.hp - effect.magnitude : 0n;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
    }

    // Decrement roundsRemaining
    const remaining = effect.roundsRemaining - 1n;
    if (remaining === 0n) {
      ctx.db.characterEffect.id.delete(effect.id);
    } else {
      ctx.db.characterEffect.id.update({ ...effect, roundsRemaining: remaining });
    }
  }

  // Schedule next tick
  ctx.db.hotTick.insert({
    scheduledId: 0n,
    scheduledAt: ScheduleAt.time(ctx.timestamp.microsSinceUnixEpoch + HOT_TICK_MICROS),
  });
});
```

**Why this pattern:**
- User decision: "Fixed tick rate: all DoTs tick every 3 seconds (predictable rhythm)"
- Already implemented and working (HotTick processes both 'regen' and 'dot')
- No changes needed, just use existing system

**Source:** Existing implementation (combat.ts:1081, 1240-1345)

---

### Pattern 7: AoE Target Enumeration and Damage Reduction

**What:** AoE abilities enumerate all targets in combat, apply reduced damage to each.

**When to use:** Abilities with `aoeTargets` metadata.

**Implementation (extend applyDamage in index.ts:2020+):**
```typescript
// In executeAbilityAction
if (abilityEntry.aoeTargets === 'all_enemies') {
  const aoeMultiplier = abilityEntry.aoeDamageMultiplier ?? 0.65;  // Default 65% per target

  // Enumerate all enemies in combat
  const enemies = [...ctx.db.combatEnemy.by_combat.filter(combatId)];

  for (const targetEnemy of enemies) {
    if (targetEnemy.currentHp === 0n) continue;  // Skip dead enemies

    // Calculate damage with AoE reduction
    const singleTargetDamage = directDamage;
    const aoeDamage = (singleTargetDamage * BigInt(Math.floor(aoeMultiplier * 100))) / 100n;

    // Apply damage to this enemy (use existing damage application logic)
    applyDamageToEnemy(ctx, character, targetEnemy, aoeDamage, combatId, abilityEntry);

    // If ability also has DoT, apply to all targets (DoT not further reduced)
    if (abilityEntry.dotPowerSplit) {
      addEnemyEffect(ctx, combatId, targetEnemy.id, 'dot', dotPerTick, dotDuration, abilityEntry.name);
    }
  }
} else {
  // Single-target ability (existing logic)
  applyDamage(directDamage, enemy);
}
```

**Example (Warrior Cleave):**
- Single-target damage: 50
- AoE multiplier: 65%
- 3 enemies in combat:
  - Enemy 1: 50 * 0.65 = 32 damage
  - Enemy 2: 50 * 0.65 = 32 damage
  - Enemy 3: 50 * 0.65 = 32 damage
  - Total output: 96 damage (vs 50 single-target)

**Why this pattern:**
- User decision: "AoE abilities deal less damage per target than single-target (e.g., 60-70%)"
- User decision: "No target cap: AoE abilities hit unlimited enemies in range"
- User decision: "Single tax: AoE abilities pay only the AoE cost - adding DoT/debuff to AoE doesn't further reduce power"

**Source:** User decision + standard MMO AoE mechanics

---

### Pattern 8: AoE Healing with Per-Target Reduction

**What:** Group healing abilities enumerate all party members, apply reduced healing to each.

**When to use:** Abilities with `aoeTargets: 'all_party'` or `'all_allies'`.

**Implementation (extend applyHeal in index.ts:2134+):**
```typescript
// In executeAbilityAction
if (abilityEntry.aoeTargets === 'all_party') {
  const aoeMultiplier = abilityEntry.aoeDamageMultiplier ?? 0.65;  // Same cost as damage AoE

  const partyMembers = partyMembersInLocation(ctx, character);

  for (const member of partyMembers) {
    if (member.hp === 0n) continue;  // Skip dead members

    // Calculate healing with AoE reduction
    const singleTargetHealing = baseHealing;
    const aoeHealing = (singleTargetHealing * BigInt(Math.floor(aoeMultiplier * 100))) / 100n;

    // Apply WIS scaling AFTER AoE reduction
    const scaledHealing = calculateHealingPower(aoeHealing, character.wis, character.className);
    applyHeal(member, scaledHealing, abilityEntry.name);

    // If ability also has HoT, apply to all targets
    if (abilityEntry.hotPowerSplit) {
      addCharacterEffect(ctx, member.id, 'regen', hotPerTick, hotDuration, abilityEntry.name);
    }
  }
}
```

**Why this pattern:**
- User decision: "AoE heals cost power budget: group heals heal for less per target, same as AoE damage cost"
- Mirrors AoE damage pattern for consistency

**Source:** User decision

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Periodic effect ticking | Custom timer system per effect | Existing `HotTick` scheduled table (3s interval) | Already implemented, handles all 'regen' and 'dot' effects globally |
| Effect stacking logic | New stacking rules per ability | Existing `addCharacterEffect()` refresh logic | Already handles same-source refresh, different-source stacking |
| Effect storage | Custom effect tables per type | Existing `CharacterEffect` and `CombatEnemyEffect` | Already stores `effectType`, `magnitude`, `roundsRemaining`, `sourceAbility` |
| DoT/HoT damage calculation | Per-ability custom formulas | Extend existing stat scaling system | Phase 3.1 already has `getAbilityStatScaling()` and `getAbilityMultiplier()` |
| Debuff magnitude scaling | Stats affecting debuff power | Fixed magnitude from ability metadata | User decision: "Fixed magnitudes: debuffs have consistent power regardless of stats" |

**Key insight:** The combat system already has all infrastructure for periodic effects. This phase is about extending ability metadata and splitting power budgets, not building new systems.

---

## Common Pitfalls

### Pitfall 1: Double-Scaling DoT Damage

**What goes wrong:** Applying full stat scaling to DoT per-tick damage causes DoTs to dramatically outperform direct damage (a 3-tick DoT with full scaling deals 3x stat-scaled damage).

**Why it happens:** Forgetting that DoTs apply damage multiple times, so each tick needs reduced scaling.

**How to avoid:** Always multiply DoT stat scaling by `DOT_SCALING_RATE_MODIFIER` (50% or similar).

**Warning signs:** DoT-heavy abilities suddenly dominating DPS meters, players spamming DoTs instead of direct damage abilities.

**Example:**
```typescript
// ❌ WRONG: Full stat scaling per tick
const dotDamage = (baseDotDamage + fullStatScaling) * multiplier;

// ✅ RIGHT: Reduced stat scaling per tick
const dotStatScaling = (fullStatScaling * DOT_SCALING_RATE_MODIFIER) / 100n;
const dotDamage = (baseDotDamage + dotStatScaling) * multiplier;
```

---

### Pitfall 2: Forgetting Power Budget Split Reduces Direct Damage

**What goes wrong:** Adding DoT to an ability without reducing direct damage means the ability does MORE total damage than intended.

**Why it happens:** Treating DoT as "bonus damage" instead of reallocating existing power budget.

**How to avoid:** Always calculate `directDamage = totalDamage * (1 - dotPowerSplit)` before applying direct damage.

**Warning signs:** Abilities with DoTs dealing significantly more total damage than pure direct-damage abilities of same power rating.

**Example:**
```typescript
// ❌ WRONG: DoT adds to full direct damage
const directDamage = calculateAbilityDamage(power);
const dotDamage = calculateDotDamage(power * 0.4);

// ✅ RIGHT: DoT reduces direct damage
const totalDamage = calculateAbilityDamage(power);
const directDamage = totalDamage * (1 - dotPowerSplit);
const dotTotalDamage = totalDamage * dotPowerSplit;
```

---

### Pitfall 3: Not Applying AoE Reduction to DoTs

**What goes wrong:** Treating user decision "Single tax: AoE abilities pay only the AoE cost - adding DoT/debuff to AoE doesn't further reduce power" as "DoTs on AoE are full power."

**Why it happens:** Misreading "single tax" as "DoTs exempt from AoE cost."

**How to avoid:** "Single tax" means AoE cost applies ONCE (to total power budget), not separately to direct damage AND DoT. DoT per-tick damage is derived from the already-reduced AoE power budget.

**Warning signs:** AoE abilities with DoTs dealing more total damage than single-target equivalents.

**Correct interpretation:**
```typescript
// Power budget: 100 damage total
// AoE multiplier: 65% per target
// DoT split: 40%

// Step 1: Split power BEFORE AoE reduction
const directPower = 100 * 0.6 = 60;
const dotPower = 100 * 0.4 = 40;

// Step 2: Apply AoE reduction to BOTH
const directDamagePerTarget = 60 * 0.65 = 39;
const dotDamagePerTarget = 40 * 0.65 = 26 (total over all ticks);

// Not: direct = 60 * 0.65, DoT = 40 (full power) ❌
```

---

### Pitfall 4: Using `roundsRemaining` for Wall-Clock Durations

**What goes wrong:** Trying to create a "30-minute buff" by setting `roundsRemaining = 600n` (expecting 30 min / 3 sec per tick).

**Why it happens:** Assuming `roundsRemaining` ticks by wall clock, when it actually ticks by combat events.

**How to avoid:** `roundsRemaining` decrements on `tick_hot` (every 3 seconds real-time) and `tick_effects` (every 10 seconds), but ONLY while those ticks run. Out-of-combat buffs need explicit timestamp-based expiry (see Hunger system's `wellFedUntil: t.timestamp()`).

**Warning signs:** Buffs expiring unexpectedly fast or lasting indefinitely.

**Source:** Phase 02-hunger research (02-RESEARCH.md:304-306)

---

### Pitfall 5: Forgetting to Apply Ability Multiplier to DoT/HoT

**What goes wrong:** Direct damage gets cast time and cooldown bonuses, but DoT/HoT damage doesn't.

**Why it happens:** Applying multiplier to direct damage only, forgetting that user decision says "Cast time bonus applies equally" and "Cooldown bonus applies equally."

**How to avoid:** Calculate ability multiplier ONCE from cast time + cooldown, apply to BOTH direct damage AND DoT/HoT damage.

**Warning signs:** Long-cast DoT abilities feeling weak compared to instant DoTs.

**Example:**
```typescript
// ✅ RIGHT: Ability multiplier applies to both
const abilityMultiplier = getAbilityMultiplier(castSeconds, cooldownSeconds);

const directDamage = ((baseDirect + statScaling) * abilityMultiplier) / 100n;
const dotPerTick = ((baseDotPerTick + dotStatScaling) * abilityMultiplier) / 100n;
```

---

### Pitfall 6: Allowing Debuff Magnitudes to Scale with Stats

**What goes wrong:** A high-INT wizard applies a stronger slow debuff than a low-INT wizard.

**Why it happens:** Reusing the same stat scaling logic for debuffs as damage.

**How to avoid:** User decision is explicit: "Fixed magnitudes: debuffs have consistent power regardless of stats." Debuff magnitude comes directly from ability metadata, never from character stats.

**Warning signs:** Debuff strength varying between players casting the same ability.

**Example:**
```typescript
// ❌ WRONG: Debuff magnitude scales
const debuffMagnitude = baseDebuff + (character.int * scalingFactor);

// ✅ RIGHT: Debuff magnitude is fixed
const debuffMagnitude = abilityEntry.debuffMagnitude;  // From ability_catalog.ts
```

---

## Code Examples

Verified patterns from existing codebase:

### Enemy Ability DoT Pattern (ability_catalog.ts:809-818)
```typescript
// Source: ability_catalog.ts:809-818
export const ENEMY_ABILITIES = {
  poison_bite: {
    name: 'Poison Bite',
    castSeconds: 3n,
    cooldownSeconds: 20n,
    kind: 'dot',
    magnitude: 2n,
    rounds: 3n,
    aiChance: 50,
    aiWeight: 70,
    aiRandomness: 15,
  },
  // ... more examples
};
```

**Key insight:** Enemy abilities already use `kind: 'dot'`, `magnitude`, `rounds` pattern. Player abilities should follow same structure.

---

### Enemy Ability Debuff Pattern (ability_catalog.ts:853-864)
```typescript
// Source: ability_catalog.ts:853-864
sapping_chant: {
  name: 'Sapping Chant',
  castSeconds: 2n,
  cooldownSeconds: 20n,
  kind: 'debuff',
  effectType: 'ac_bonus',
  magnitude: -2n,
  rounds: 3n,
  aiChance: 45,
  aiWeight: 60,
  aiRandomness: 20,
},
```

**Key insight:** Debuffs use `kind: 'debuff'`, `effectType`, `magnitude`, `rounds`. Magnitude is negative for debuffs, positive for buffs.

---

### Effect Application with Stacking/Refresh (index.ts:1767-1785)
```typescript
// Source: index.ts:1767-1785
function addCharacterEffect(
  ctx: any,
  characterId: bigint,
  effectType: string,
  magnitude: bigint,
  roundsRemaining: bigint,
  sourceAbility?: string
) {
  const existing = [...ctx.db.characterEffect.by_character.filter(characterId)].find(
    (effect) => effect.effectType === effectType && effect.sourceAbility === sourceAbility
  );
  if (existing) {
    ctx.db.characterEffect.id.update({
      ...existing,
      magnitude,
      roundsRemaining,
    });
    return;
  }
  ctx.db.characterEffect.insert({
    id: 0n,
    characterId,
    effectType,
    magnitude,
    roundsRemaining,
    sourceAbility,
  });
}
```

**Key insight:** Matching `effectType + sourceAbility` refreshes duration. Different `sourceAbility` stacks.

---

### HotTick Reducer Processing DoT/HoT (combat.ts:1240-1300)
```typescript
// Source: combat.ts:1240-1300
spacetimedb.reducer('tick_hot', { arg: HotTick.rowType }, (ctx) => {
  for (const effect of ctx.db.characterEffect.iter()) {
    if (effect.effectType !== 'regen' && effect.effectType !== 'dot') continue;
    if (effect.roundsRemaining === 0n) continue;

    if (effect.effectType === 'regen') {
      const nextHp = owner.hp + effect.magnitude > owner.maxHp ? owner.maxHp : owner.hp + effect.magnitude;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
      // ... logging
    } else if (effect.effectType === 'dot') {
      const nextHp = owner.hp > effect.magnitude ? owner.hp - effect.magnitude : 0n;
      ctx.db.character.id.update({ ...owner, hp: nextHp });
      // ... logging
    }

    const remaining = effect.roundsRemaining - 1n;
    if (remaining === 0n) {
      ctx.db.characterEffect.id.delete(effect.id);
    } else {
      ctx.db.characterEffect.id.update({ ...effect, roundsRemaining: remaining });
    }
  }

  ctx.db.hotTick.insert({
    scheduledId: 0n,
    scheduledAt: ScheduleAt.time(ctx.timestamp.microsSinceUnixEpoch + HOT_TICK_MICROS),
  });
});
```

**Key insight:** Single reducer handles both 'regen' (HoT) and 'dot' (DoT) by checking `effectType`. No separate reducers needed.

---

### Ability Damage with Hybrid Formula (index.ts:2044-2057)
```typescript
// Source: index.ts:2044-2057 (Phase 3.1 implementation)
const abilityEntry = ABILITIES[abilityKey as keyof typeof ABILITIES];
const statScaling = getAbilityStatScaling(
  { str: character.str, dex: character.dex, cha: character.cha, wis: character.wis, int: character.int },
  abilityKey,
  character.className
);
const abilityMultiplier = abilityEntry
  ? getAbilityMultiplier(abilityEntry.castSeconds, abilityEntry.cooldownSeconds)
  : 100n;

// Hybrid formula: (base + stat_scaling) * ability_multiplier / 100
const abilityBaseDamage = abilityEntry ? abilityEntry.power * 5n : 0n;
const scaledAbilityDamage = ((abilityBaseDamage + statScaling) * abilityMultiplier) / 100n;
```

**Key insight:** This formula is used for direct damage. DoT damage should use SAME formula but with:
1. Power budget fraction (`power * dotPowerSplit`)
2. Reduced stat scaling (`statScaling * DOT_SCALING_RATE_MODIFIER`)
3. Division by tick count (`/ dotDuration`)

---

### Summing Effect Bonuses (index.ts:1846-1852)
```typescript
// Source: index.ts:1846-1852
function sumCharacterEffect(ctx: any, characterId: bigint, effectType: string) {
  let total = 0n;
  for (const effect of ctx.db.characterEffect.by_character.filter(characterId)) {
    if (effect.effectType === effectType) total += BigInt(effect.magnitude);
  }
  return total;
}
```

**Key insight:** Multiple effects of same type stack additively. This is how "Same type stacks fully: multiple AC reduction debuffs stack additively (-5 AC + -3 AC = -8 AC)" is implemented.

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| DoTs as fixed damage values | DoTs scale with character stats | Phase 3.1.1 | DoTs now benefit from gear/level progression |
| Separate tick systems for DoT/HoT | Unified `tick_hot` reducer | Already implemented | Single tick system handles all periodic effects |
| Per-ability debuff implementations | Declarative metadata in ability catalog | Phase 3.1.1 | Easier to balance, tune, and add new abilities |
| AoE abilities same damage as single-target | AoE per-target damage reduction | Phase 3.1.1 | Prevents AoE spam dominating single-target |

**Deprecated/outdated:**
- **Treating DoT as "bonus damage":** Modern RPG design treats DoT as power budget tradeoff (lower burst, same total damage). World of Warcraft shifted to this model in Shadowlands (2020).
- **Scaling debuff magnitude with stats:** Creates unpredictable CC durations and balance nightmares. Modern games use fixed durations/magnitudes (League of Legends, Dota 2).

---

## Open Questions

1. **What is the exact DoT scaling rate modifier?**
   - What we know: User decision says "reduced scaling rate compared to direct damage"
   - What's unclear: Exact percentage (50%? 33%? 25%?)
   - Recommendation: Start with 50% (half of direct damage scaling), tune via playtesting

2. **What is the AoE damage multiplier per target?**
   - What we know: User decision says "60-70% range"
   - What's unclear: Exact value (60%? 65%? 70%?)
   - Recommendation: Start with 65%, adjust if AoE feels too weak or too strong

3. **How should AoE abilities enumerate targets?**
   - What we know: "No target cap: AoE abilities hit unlimited enemies in range"
   - What's unclear: How to determine "in range" (all in combat? specific distance?)
   - Recommendation: All enemies in same combat (simplest, matches current combat system architecture)

4. **Should debuff power cost be uniform or per-debuff-type?**
   - What we know: User decision says "All debuff types cost the same power budget"
   - What's unclear: Exact power cost percentage
   - Recommendation: 20-30% power cost for debuffs (similar to typical DoT split)

---

## Sources

### Primary (HIGH confidence)
- **Existing codebase patterns:**
  - `spacetimedb/src/index.ts` (CharacterEffect table, effect helpers, ability execution)
  - `spacetimedb/src/reducers/combat.ts` (tick_hot reducer, effect processing)
  - `spacetimedb/src/data/ability_catalog.ts` (enemy ability DoT/debuff patterns)
  - `spacetimedb/src/data/combat_scaling.ts` (stat scaling, ability multipliers)
- **Phase 3.1 RESEARCH.md:** Established stat scaling patterns, hybrid formula, ability multipliers
- **User decisions from CONTEXT.md:** All power budget, scaling, stacking, and AoE rules

### Secondary (MEDIUM confidence)
- [Game Developer: Balancing Damage Over Time](https://www.gamedeveloper.com/design/balancing-damage-over-time-in-rpgs) - DoT power budget principles
- [Power Scaling in RPGs](https://marcleoseguin.com/2020/11/18/power-scaling-in-rpgs/) - Multiplicative vs additive scaling

### Tertiary (LOW confidence)
None — all research based on existing codebase and user decisions.

---

## Metadata

**Confidence breakdown:**
- Architecture patterns: HIGH - existing effect system already handles all requirements
- DoT/HoT scaling: HIGH - extends proven Phase 3.1 stat scaling system
- Power budget splitting: MEDIUM - approach is clear, exact percentages need tuning
- AoE mechanics: MEDIUM - enumeration logic is straightforward, multiplier values need testing
- Effect stacking: HIGH - already implemented and working correctly

**Research date:** 2026-02-12
**Valid until:** 30 days (stable system, extension of existing patterns)
