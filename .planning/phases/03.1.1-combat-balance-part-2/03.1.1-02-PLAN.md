---
phase: 03.1.1-combat-balance-part-2
plan: 02
type: execute
wave: 2
depends_on: ["03.1.1-01"]
files_modified:
  - spacetimedb/src/index.ts
autonomous: false

must_haves:
  truths:
    - "Shadow Cut (power=4, STR-based) with 60/40 split deals ~15 direct damage and creates DoT for ~10 total damage over 2 ticks"
    - "DoT damage scales with STR (same stat as direct damage)"
    - "DoT uses reduced scaling rate (50% of direct damage stat scaling via DOT_SCALING_RATE_MODIFIER)"
    - "Recasting Shadow Cut on same target refreshes DoT duration, doesn't stack damage"
    - "Spirit Mender (power=2, WIS-based) with 50/50 split heals ~10 direct and creates HoT for ~10 total over 2 ticks"
    - "HoT healing scales with WIS using reduced scaling rate"
    - "Shaman Hex with debuff deals reduced damage (75% of normal due to 25% debuff power cost)"
    - "Warrior Cleave hits all enemies in combat with ~65% damage per target"
    - "Debuffs have fixed magnitude (-2 AC for Hex) regardless of caster stats"
    - "DoTs and HoTs tick every 3 seconds via existing tick_hot scheduled reducer"
  artifacts:
    - path: "spacetimedb/src/index.ts"
      provides: "Power budget split logic in executeAbilityAction"
      contains: "dotPowerSplit"
    - path: "spacetimedb/src/index.ts"
      provides: "AoE target enumeration and per-target damage reduction"
      contains: "aoeTargets"
  key_links:
    - from: "spacetimedb/src/index.ts executeAbilityAction"
      to: "ABILITIES metadata (dotPowerSplit, hotPowerSplit, etc.)"
      via: "Read ability metadata from catalog"
      pattern: "abilityEntry\\.dotPowerSplit"
    - from: "spacetimedb/src/index.ts"
      to: "DOT_SCALING_RATE_MODIFIER from combat_scaling.ts"
      via: "Import and apply to DoT stat scaling"
      pattern: "DOT_SCALING_RATE_MODIFIER"
    - from: "spacetimedb/src/index.ts"
      to: "addEnemyEffect for DoTs, addCharacterEffect for HoTs"
      via: "Create effect rows when abilities execute"
      pattern: "addEnemyEffect.*'dot'"
    - from: "spacetimedb/src/index.ts"
      to: "combatEnemy.by_combat.filter for AoE enumeration"
      via: "Enumerate all enemies in combat"
      pattern: "combatEnemy\\.by_combat\\.filter"
---

<objective>
Implement power budget split logic for DoT/HoT/debuff/AoE abilities in executeAbilityAction reducer. Split ability power between direct and periodic effects, apply reduced stat scaling to DoT/HoT, enumerate AoE targets with per-target damage reduction, and apply debuff power costs.

Purpose: Make DoT/HoT/debuff/AoE metadata functional by implementing the power budget calculations and effect creation logic.

Output: Functional DoT/HoT/debuff/AoE abilities using power budget split system, verified via human testing.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/projects/uwr/.planning/PROJECT.md
@C:/projects/uwr/.planning/ROADMAP.md
@C:/projects/uwr/.planning/STATE.md
@C:/projects/uwr/.planning/phases/03.1.1-combat-balance-part-2/03.1.1-CONTEXT.md
@C:/projects/uwr/.planning/phases/03.1.1-combat-balance-part-2/03.1.1-RESEARCH.md
@C:/projects/uwr/.planning/phases/03.1.1-combat-balance-part-2/03.1.1-01-SUMMARY.md
@C:/projects/uwr/spacetimedb/src/index.ts
@C:/projects/uwr/spacetimedb/src/data/combat_scaling.ts
@C:/projects/uwr/spacetimedb/src/data/ability_catalog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement power budget split logic for DoT/HoT in applyDamage/applyHeal</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
Modify the `applyDamage` function (starting around line 2020) and `applyHeal` function (around line 2134) within the `executeAbilityAction` reducer to implement power budget splitting for DoT/HoT abilities.

**Step 1: Import constants at top of file**

Add to existing imports from combat_scaling.ts (around line 10):
```typescript
import {
  // ... existing imports
  DOT_SCALING_RATE_MODIFIER,
  AOE_DAMAGE_MULTIPLIER,
  DEBUFF_POWER_COST_PERCENT,
} from './data/combat_scaling.js';
```

**Step 2: Extend applyDamage function with DoT power budget split**

Inside `applyDamage` function, AFTER the existing ability damage calculation (around line 2057), ADD:

```typescript
// Power budget split for DoT abilities
const directPowerFraction = abilityEntry?.dotPowerSplit ? 1.0 - abilityEntry.dotPowerSplit : 1.0;

// Apply power budget split to scaled ability damage
const directAbilityDamage = (scaledAbilityDamage * BigInt(Math.floor(directPowerFraction * 100))) / 100n;

// If ability has DoT, calculate DoT damage with reduced stat scaling
let dotDamagePerTick = 0n;
let dotDuration = 0n;
if (abilityEntry?.dotPowerSplit && abilityEntry?.dotDuration) {
  const dotPowerFraction = abilityEntry.dotPowerSplit;
  const dotTotalDamage = (scaledAbilityDamage * BigInt(Math.floor(dotPowerFraction * 100))) / 100n;

  // DoT stat scaling uses REDUCED rate (50% of direct scaling)
  const dotStatScaling = (statScaling * DOT_SCALING_RATE_MODIFIER) / 100n;

  // DoT damage per tick = (total DoT power + reduced stat scaling) / duration
  dotDamagePerTick = ((dotTotalDamage + dotStatScaling) / abilityEntry.dotDuration);
  dotDuration = abilityEntry.dotDuration;
}

// If ability has debuff, reduce direct damage by debuff power cost
let finalDirectDamage = directAbilityDamage;
if (abilityEntry?.debuffType && abilityEntry?.debuffMagnitude && abilityEntry?.debuffDuration) {
  const debuffCostFraction = 1.0 - (Number(DEBUFF_POWER_COST_PERCENT) / 100);
  finalDirectDamage = (directAbilityDamage * BigInt(Math.floor(debuffCostFraction * 100))) / 100n;
}
```

**Step 3: Replace scaledAbilityDamage usage with finalDirectDamage**

FIND (around line 2066):
```typescript
const raw = weaponComponent + scaledAbilityDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);
```

REPLACE with:
```typescript
const raw = weaponComponent + finalDirectDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);
```

**Step 4: Add DoT effect creation AFTER damage application**

AFTER the debuff application block (around line 2102), ADD:

```typescript
// Apply DoT effect if ability has DoT metadata
if (dotDamagePerTick > 0n && dotDuration > 0n && abilityEntry?.name) {
  addEnemyEffect(
    ctx,
    combatId,
    enemy.id,
    'dot',
    dotDamagePerTick,
    dotDuration,
    abilityEntry.name
  );
}

// Apply debuff effect if ability has debuff metadata
if (abilityEntry?.debuffType && abilityEntry?.debuffMagnitude && abilityEntry?.debuffDuration) {
  addEnemyEffect(
    ctx,
    combatId,
    enemy.id,
    abilityEntry.debuffType,
    abilityEntry.debuffMagnitude,
    abilityEntry.debuffDuration,
    abilityEntry.name
  );
}
```

**Step 5: Extend applyHeal function with HoT power budget split**

Inside `applyHeal` function (around line 2134), BEFORE the `calculateHealingPower` call, ADD:

```typescript
// Power budget split for HoT abilities
const abilityEntry = ABILITIES[abilityKey as keyof typeof ABILITIES];
const directHealFraction = abilityEntry?.hotPowerSplit ? 1.0 - abilityEntry.hotPowerSplit : 1.0;
const directHeal = (amount * BigInt(Math.floor(directHealFraction * 100))) / 100n;

// If ability has HoT, calculate HoT healing with reduced stat scaling
if (abilityEntry?.hotPowerSplit && abilityEntry?.hotDuration && abilityEntry?.name) {
  const hotPowerFraction = abilityEntry.hotPowerSplit;
  const hotTotalHealing = (amount * BigInt(Math.floor(hotPowerFraction * 100))) / 100n;

  // HoT stat scaling uses REDUCED rate (50% of direct healing scaling)
  // Note: WIS scaling already applied via calculateHealingPower, so we split the final scaled amount
  const scaledHotTotal = calculateHealingPower(hotTotalHealing, character.wis, character.className);
  const hotHealPerTick = scaledHotTotal / abilityEntry.hotDuration;

  // Apply HoT effect to target
  addCharacterEffect(ctx, target.id, 'regen', hotHealPerTick, abilityEntry.hotDuration, abilityEntry.name);
}

// Use directHeal for immediate healing (replace 'amount' with 'directHeal')
const scaledAmount = calculateHealingPower(directHeal, character.wis, character.className);
```

FIND in applyHeal (around line 2138):
```typescript
const scaledAmount = calculateHealingPower(amount, character.wis, character.className);
```

This line should now be at the END of the new code block above (already replaced).

This implements HoT power budget split with reduced scaling rate, mirroring DoT implementation per user decision.
  </action>
  <verify>
Verify power budget split logic added:
```bash
cd C:/projects/uwr/spacetimedb
grep -A 5 "Power budget split for DoT" src/index.ts
grep -A 5 "Power budget split for HoT" src/index.ts
grep -c "dotPowerSplit" src/index.ts
grep -c "DOT_SCALING_RATE_MODIFIER" src/index.ts
```
Should see power budget split blocks for both DoT and HoT, with DOT_SCALING_RATE_MODIFIER usage.
  </verify>
  <done>
index.ts applyDamage and applyHeal functions implement power budget splits. DoT damage split between direct and periodic with reduced stat scaling. HoT healing split between direct and periodic. Debuff power costs reduce direct damage. DoT and HoT effects created via existing addEnemyEffect/addCharacterEffect helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AoE target enumeration and per-target damage reduction</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
Extend the `applyDamage` function to handle AoE abilities by enumerating all enemies in combat and applying per-target damage reduction.

**Step 1: Add AoE check BEFORE single-target damage application**

AFTER the power budget split logic added in Task 1, BEFORE the damage application loop (around line 2064), ADD:

```typescript
// AoE target enumeration and damage reduction
if (abilityEntry?.aoeTargets === 'all_enemies') {
  const aoeMultiplier = Number(AOE_DAMAGE_MULTIPLIER) / 100;  // 65% = 0.65
  const enemies = [...ctx.db.combatEnemy.by_combat.filter(combatId)];

  for (const targetEnemy of enemies) {
    if (targetEnemy.currentHp === 0n) continue;  // Skip dead enemies

    // Apply AoE damage reduction to final direct damage
    const aoeDamage = (finalDirectDamage * BigInt(Math.floor(aoeMultiplier * 100))) / 100n;

    // Get target's armor for mitigation
    let targetArmor = targetEnemy.armorClass;
    const armorDebuff = sumEnemyEffect(ctx, combatId, 'armor_down', targetEnemy.id);
    if (armorDebuff !== 0n) {
      targetArmor = targetArmor + armorDebuff;
      if (targetArmor < 0n) targetArmor = 0n;
    }

    // Route mitigation by damage type
    const dmgType = abilityEntry?.damageType ?? 'physical';
    let mitigatedDamage: bigint;
    if (dmgType === 'magic') {
      mitigatedDamage = aoeDamage > 0n ? aoeDamage : 1n;
    } else {
      mitigatedDamage = applyArmorMitigation(aoeDamage, targetArmor);
    }

    // Apply damage to target
    const nextHp = targetEnemy.currentHp > mitigatedDamage ? targetEnemy.currentHp - mitigatedDamage : 0n;
    ctx.db.combatEnemy.id.update({ ...targetEnemy, currentHp: nextHp });

    // Update aggro for this target
    for (const entry of ctx.db.aggroEntry.by_combat.filter(combatId)) {
      if (entry.characterId === character.id && entry.enemyId === targetEnemy.id) {
        ctx.db.aggroEntry.id.update({
          ...entry,
          value: entry.value + mitigatedDamage,
        });
        break;
      }
    }

    // Apply DoT to all AoE targets (DoT not further reduced per user decision: "Single tax")
    if (dotDamagePerTick > 0n && dotDuration > 0n && abilityEntry?.name) {
      addEnemyEffect(
        ctx,
        combatId,
        targetEnemy.id,
        'dot',
        dotDamagePerTick,
        dotDuration,
        abilityEntry.name
      );
    }

    // Log damage for each target
    const enemyTemplate = ENEMY_DATA.find((t) => t.name === targetEnemy.name);
    const targetName = enemyTemplate?.name ?? 'enemy';
    appendPrivateEvent(
      ctx,
      character.id,
      character.ownerUserId,
      'damage',
      `Your ${abilityEntry.name} hits ${targetName} for ${mitigatedDamage} damage.`
    );
    if (actorGroupId) {
      appendGroupEvent(
        ctx,
        actorGroupId,
        character.id,
        'damage',
        `${character.name}'s ${abilityEntry.name} hits ${targetName} for ${mitigatedDamage} damage.`
      );
    }
  }

  // AoE abilities skip single-target damage application (already processed all targets above)
  return 0n;  // Return early from applyDamage function
}
```

**Step 2: Ensure single-target path remains unchanged**

The EXISTING single-target damage application code (the loop starting around line 2064) should remain as-is. The AoE block above returns early, so single-target abilities continue to use the existing logic.

**Step 3: Handle AoE healing for party buffs**

Modify the `applyPartyHeal` or create similar AoE healing logic if abilities like `paladin_devotion` need group healing with power budget split. For now, existing `applyPartyEffect` and `applyPartyHpBonus` helpers work for group buffs (no power budget split needed for pure buffs per user decision: "AoE buffs cost power budget: group buffs deal no damage").

This implementation follows user decision: "No target cap: AoE abilities hit unlimited enemies in range" (all enemies in combat) and "Single tax: AoE abilities pay only the AoE cost - adding DoT/debuff to AoE doesn't further reduce power" (DoT applied at full calculated per-tick value to all targets).
  </action>
  <verify>
Verify AoE logic added:
```bash
cd C:/projects/uwr/spacetimedb
grep -A 10 "AoE target enumeration" src/index.ts
grep -c "aoeTargets" src/index.ts
grep -c "AOE_DAMAGE_MULTIPLIER" src/index.ts
```
Should see AoE enumeration block with all_enemies check and AOE_DAMAGE_MULTIPLIER usage.
  </verify>
  <done>
index.ts applyDamage function handles AoE abilities by enumerating all enemies in combat, applying 65% per-target damage reduction, and creating DoT effects on all targets. Single-target abilities continue using existing logic. AoE damage routed through same mitigation logic (magic vs physical).
  </done>
</task>

<task type="auto">
  <name>Task 3: Publish module and regenerate bindings</name>
  <files>spacetimedb/package.json, client/src/module_bindings/</files>
  <action>
Publish updated SpacetimeDB module with power budget split implementation and regenerate client bindings.

```bash
cd C:/projects/uwr
spacetime publish uwr --project-path spacetimedb
spacetime generate --lang typescript --out-dir client/src/module_bindings --project-path spacetimedb
```

No schema changes (only reducer logic changes), so no --clear-database flag needed.
  </action>
  <verify>
```bash
cd C:/projects/uwr
spacetime logs uwr --tail 30
```
Should see successful module publish with no errors. Check for any TypeScript compilation errors in logs.
  </verify>
  <done>
Module published successfully with power budget split logic. Client bindings regenerated. No schema errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Power budget split system for DoT/HoT/debuff/AoE abilities implemented in SpacetimeDB combat reducer. Shadow Cut now deals split damage (60% direct, 40% DoT over 2 ticks). Spirit Mender heals with split (50% direct, 50% HoT over 2 ticks). Warrior Cleave hits all enemies at 65% per target. Debuffs reduce ability damage by 25%.
  </what-built>
  <how-to-verify>
**Test 1: DoT power budget split and stat scaling**
1. Create a Rogue character (STR-based Shadow Cut ability)
2. Note character's STR stat
3. Enter combat with a single enemy
4. Use Shadow Cut ability
5. Observe combat log for direct damage amount
6. Wait 3 seconds and observe DoT tick damage
7. Wait another 3 seconds for second DoT tick
8. Verify:
   - Direct damage is ~15-20 (60% of total power)
   - Each DoT tick is ~5 (40% total / 2 ticks)
   - DoT ticks scale with STR (higher STR = higher DoT ticks)
   - Total damage (direct + 2 DoT ticks) is consistent with ability power rating

**Test 2: DoT refresh vs stacking**
1. Use Shadow Cut on same enemy again BEFORE DoT expires
2. Verify:
   - DoT duration resets to 2 ticks (refreshed, not stacked)
   - DoT damage per tick remains same (not doubled)
3. If in a group, have another Rogue use Shadow Cut on same enemy
4. Verify:
   - Both DoT effects run simultaneously (different casters stack)

**Test 3: HoT power budget split and WIS scaling**
1. Create a Shaman character (WIS-based Spirit Mender ability)
2. Note character's WIS stat
3. Damage a party member to ~50% HP
4. Use Spirit Mender on damaged party member
5. Observe immediate heal amount
6. Wait 3 seconds and observe HoT tick heal
7. Wait another 3 seconds for second HoT tick
8. Verify:
   - Immediate heal is ~10 (50% of total healing)
   - Each HoT tick is ~5 (50% total / 2 ticks)
   - HoT ticks scale with WIS (higher WIS = higher HoT ticks)
   - Total healing (immediate + 2 HoT ticks) is consistent with ability power

**Test 4: Debuff power cost**
1. Create an Enchanter or Shaman character
2. Enter combat with single enemy
3. Note enemy's AC value in combat UI
4. Use Hex ability (applies AC debuff)
5. Observe direct damage dealt
6. Verify:
   - Damage is ~25% lower than similar power abilities without debuffs
   - Enemy's effective AC is reduced by 2 (fixed magnitude)
   - Debuff lasts for 3 ticks (9 seconds)

**Test 5: AoE damage reduction and target enumeration**
1. Create a Warrior character
2. Enter combat with 3+ enemies (use group combat or spawn multiple enemies)
3. Use Cleave ability
4. Observe combat log
5. Verify:
   - All enemies in combat take damage (no target cap)
   - Damage per enemy is ~65% of single-target ability damage
   - All enemies show damage in combat log

**Test 6: Effect stacking confirmation**
1. Use Shadow Cut (DoT ability) on enemy
2. Use Plague Spark (different DoT ability) on same enemy
3. Verify:
   - Both DoT effects appear in enemy debuff list
   - Both DoTs tick simultaneously every 3 seconds
   - Total DoT damage per tick = sum of both DoTs

**Success criteria:**
- [ ] Shadow Cut deals split damage (direct + DoT over time)
- [ ] DoT scales with STR (same stat as direct damage)
- [ ] Recasting same DoT refreshes, doesn't stack
- [ ] Different DoT abilities stack on same target
- [ ] Spirit Mender heals with split (direct + HoT over time)
- [ ] HoT scales with WIS
- [ ] Hex deals reduced damage (~75%) and applies fixed -2 AC debuff
- [ ] Warrior Cleave hits all enemies at ~65% damage each
- [ ] DoT and HoT tick every 3 seconds
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe any issues observed (e.g., "DoT damage too high", "AoE not hitting all enemies", "debuff magnitude scaling with stats").
  </resume-signal>
</task>

</tasks>

<verification>
After human verification approval:

1. **Power budget split functional:**
   - Shadow Cut deals 60% direct, 40% DoT total
   - Spirit Mender heals 50% direct, 50% HoT total
   - Debuff abilities deal reduced damage

2. **Stat scaling correct:**
   - DoTs scale with same stat as direct damage (STR for Shadow Cut)
   - DoTs use reduced scaling rate (50% via DOT_SCALING_RATE_MODIFIER)
   - HoTs scale with WIS

3. **AoE working:**
   - Warrior Cleave hits all enemies in combat
   - Damage per target is ~65% of single-target

4. **Effect stacking correct:**
   - Same ability refreshes duration
   - Different abilities stack
</verification>

<success_criteria>
- [ ] DoT power budget split implemented (direct damage reduced when DoT present)
- [ ] HoT power budget split implemented (direct heal reduced when HoT present)
- [ ] DoT stat scaling uses DOT_SCALING_RATE_MODIFIER (50% of direct scaling)
- [ ] HoT stat scaling uses reduced rate
- [ ] Debuff power cost reduces direct damage by 25%
- [ ] Debuff magnitude is fixed (from ability metadata, not scaled by stats)
- [ ] AoE abilities enumerate all enemies in combat
- [ ] AoE damage per target is 65% of single-target damage
- [ ] DoT/HoT effects created via addEnemyEffect/addCharacterEffect
- [ ] Effect stacking logic working (same ability refreshes, different abilities stack)
- [ ] Human verification passes all 6 test scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/03.1.1-combat-balance-part-2/03.1.1-02-SUMMARY.md`
</output>
