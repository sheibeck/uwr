---
phase: 19-npc-interactions
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - spacetimedb/src/reducers/commands.ts
  - spacetimedb/src/reducers/npc_interaction.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/index.ts
  - spacetimedb/src/helpers/events.ts
autonomous: true

must_haves:
  truths:
    - "Hailing an NPC produces a dynamic greeting based on affinity tier"
    - "Players can choose dialogue options and receive NPC responses"
    - "Players can give inventory items to NPCs for affinity gains"
    - "Conversation cooldown prevents affinity farming via repeated hailing"
    - "Choosing a dialogue option awards affinity and logs the exchange"
    - "Gift-giving consumes the item and increases affinity based on item value"
  artifacts:
    - path: "spacetimedb/src/reducers/npc_interaction.ts"
      provides: "choose_dialogue_option and give_gift_to_npc reducers"
      exports: ["registerNpcInteractionReducers"]
    - path: "spacetimedb/src/reducers/commands.ts"
      provides: "Updated hailNpc with dynamic greeting based on affinity/faction/renown context"
    - path: "spacetimedb/src/helpers/events.ts"
      provides: "Updated appendNpcDialog with optional sentiment field"
  key_links:
    - from: "spacetimedb/src/reducers/npc_interaction.ts"
      to: "spacetimedb/src/helpers/npc_affinity.ts"
      via: "imports awardNpcAffinity, getAffinityForNpc, getAvailableDialogueOptions"
      pattern: "awardNpcAffinity|getAvailableDialogueOptions"
    - from: "spacetimedb/src/reducers/commands.ts"
      to: "spacetimedb/src/helpers/npc_affinity.ts"
      via: "imports getAffinityForNpc, canConverseWithNpc for dynamic greetings"
      pattern: "getAffinityForNpc|canConverseWithNpc"
    - from: "spacetimedb/src/reducers/npc_interaction.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "ctx.db.npcDialogueOption, ctx.db.npcAffinity, ctx.db.itemInstance lookups"
      pattern: "ctx\\.db\\.npcDialogueOption|ctx\\.db\\.npcAffinity|ctx\\.db\\.itemInstance"
---

<objective>
Implement NPC interaction reducers: dynamic greetings based on affinity/context, choose_dialogue_option for branching conversations, give_gift_to_npc for item-based affinity gains. Publish module and regenerate client bindings.

Purpose: These reducers are the core interaction layer that connects the foundation tables (Plan 01) to player actions. Without them, players cannot build relationships or interact with the dialogue system.
Output: New reducers (choose_dialogue_option, give_gift_to_npc), updated hailNpc with dynamic greetings, published module with regenerated bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-npc-interactions-deepen-relationships-dialogue-complexity-affinity-systems-and-dynamic-npc-reactions-to-player-actions/19-01-SUMMARY.md
@spacetimedb/src/reducers/commands.ts
@spacetimedb/src/helpers/npc_affinity.ts
@spacetimedb/src/helpers/events.ts
@spacetimedb/src/reducers/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update hailNpc with dynamic greetings and create NPC interaction reducers</name>
  <files>
    spacetimedb/src/reducers/commands.ts
    spacetimedb/src/reducers/npc_interaction.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**Update `spacetimedb/src/reducers/commands.ts`:**

1. Import `getAffinityForNpc`, `canConverseWithNpc`, `awardNpcAffinity` from `../helpers/npc_affinity`.
2. Import `AFFINITY_TIERS` from `../data/npc_data`.

3. Replace the existing `hailNpc` function with a version that generates dynamic greetings based on context:

```typescript
const hailNpc = (ctx: any, character: any, npcName: string) => {
  const targetName = npcName.trim();
  if (!targetName) return fail(ctx, character, 'NPC name required');

  let npc: any | null = null;
  for (const row of ctx.db.npc.by_location.filter(character.locationId)) {
    if (row.name.toLowerCase() === targetName.toLowerCase()) {
      npc = row;
      break;
    }
  }
  if (!npc) return fail(ctx, character, 'No such NPC here');

  // Get affinity for dynamic greeting
  const affinity = Number(getAffinityForNpc(ctx, character.id, npc.id));

  // Get faction standing if NPC has faction
  let factionStanding = 0;
  if (npc.factionId) {
    for (const fs of ctx.db.factionStanding.by_character.filter(character.id)) {
      if (fs.factionId === npc.factionId) {
        factionStanding = Number(fs.standing);
        break;
      }
    }
  }

  // Get renown rank
  let renownRank = 0;
  for (const r of ctx.db.renown.by_character.filter(character.id)) {
    renownRank = Number(r.currentRank);
    break;
  }

  // Generate dynamic greeting
  let greeting: string;
  if (factionStanding < -50 || affinity < -50) {
    greeting = `${npc.name} glares at you with open hostility. "Leave. Now."`;
  } else if (affinity >= 75) {
    greeting = `${npc.name} greets you warmly. "Ah, my friend! It is good to see you again."`;
  } else if (affinity >= 50) {
    greeting = `${npc.name} nods in recognition. "Welcome back. What can I do for you?"`;
  } else if (affinity >= 25) {
    greeting = `${npc.name} regards you with growing familiarity. "You again. What brings you?"`;
  } else if (renownRank >= 5 && affinity < 25) {
    greeting = `${npc.name} eyes you with a mix of respect and wariness. "Your reputation precedes you."`;
  } else {
    greeting = `${npc.name} says, "${npc.greeting}"`;
  }

  // IMPORTANT: Log "You begin to talk with X" to Log panel, actual greeting goes to Journal
  appendSystemMessage(ctx, character, `You begin to talk with ${npc.name}.`);

  // Greeting goes to Journal (NPC Dialog panel), not Log
  appendNpcDialog(ctx, character.id, npc.id, greeting);
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'npc', greeting);

  // Award small affinity for greeting (if cooldown allows)
  if (canConverseWithNpc(ctx, character.id, npc.id)) {
    awardNpcAffinity(ctx, character, npc.id, 1n);
  }

  // Existing quest logic remains unchanged
  const quests = [...ctx.db.questTemplate.by_npc.filter(npc.id)].filter(
    (quest) => character.level >= quest.minLevel && character.level <= quest.maxLevel
  );
  // ... rest of existing quest handling stays the same
};
```

Important: Keep the entire existing quest handling code (the for loop with quest template filtering, quest instance checking, etc.) intact after the new greeting logic. Only the greeting generation at the top changes.

**Create `spacetimedb/src/reducers/npc_interaction.ts`** (NEW FILE):

```typescript
import type { ReducerDeps } from './types';  // or match the existing import pattern
import { SenderError } from 'spacetimedb/server';
import { awardNpcAffinity, getAffinityForNpc, getAffinityRow, canConverseWithNpc } from '../helpers/npc_affinity';
import { appendNpcDialog, appendSystemMessage, appendPrivateEvent, fail, requireCharacterOwnedBy } from '../helpers/events';
import { MAX_GIFTS_PER_DAY, GIFT_COOLDOWN_MICROS } from '../data/npc_data';

export const registerNpcInteractionReducers = (deps: any) => {
  const { spacetimedb, t } = deps;

  // Choose a dialogue option from an NPC's dialogue tree
  spacetimedb.reducer('choose_dialogue_option', {
    characterId: t.u64(),
    npcId: t.u64(),
    optionId: t.u64(),
  }, (ctx: any, args: any) => {
    const character = requireCharacterOwnedBy(ctx, args.characterId);
    const { npcId, optionId } = args;

    const npc = ctx.db.npc.id.find(npcId);
    if (!npc) throw new SenderError('NPC not found');

    // Check character is at NPC location
    if (character.locationId !== npc.locationId) {
      return fail(ctx, character, 'You are not near this NPC.');
    }

    // Find the dialogue option
    const option = ctx.db.npcDialogueOption.id.find(optionId);
    if (!option || option.npcId !== npcId) {
      return fail(ctx, character, 'Invalid dialogue option.');
    }

    // Check affinity requirement
    const currentAffinity = getAffinityForNpc(ctx, character.id, npcId);
    if (currentAffinity < option.requiredAffinity) {
      return fail(ctx, character, 'Your relationship is not strong enough for this conversation.');
    }

    // Check faction requirement
    if (option.requiredFactionId) {
      const minStanding = option.requiredFactionStanding ?? 0n;
      let hasFaction = false;
      for (const fs of ctx.db.factionStanding.by_character.filter(character.id)) {
        if (fs.factionId === option.requiredFactionId && fs.standing >= minStanding) {
          hasFaction = true;
          break;
        }
      }
      if (!hasFaction) {
        return fail(ctx, character, 'Your faction standing is insufficient.');
      }
    }

    // Check renown requirement
    if (option.requiredRenownRank) {
      let renownRow: any = null;
      for (const r of ctx.db.renown.by_character.filter(character.id)) {
        renownRow = r;
        break;
      }
      if (!renownRow || renownRow.currentRank < option.requiredRenownRank) {
        return fail(ctx, character, 'Your renown rank is too low.');
      }
    }

    // Apply affinity change
    if (option.affinityChange !== 0n) {
      awardNpcAffinity(ctx, character, npcId, option.affinityChange);
    }

    // IMPORTANT: Dialogue goes to Journal (NPC Dialog panel), NOT to Log
    // Log the player's dialogue choice to Journal
    const playerLine = `You say, "${option.playerText}"`;
    appendNpcDialog(ctx, character.id, npc.id, playerLine);
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'npc', playerLine);

    // Log the NPC's response to Journal
    const npcLine = `${npc.name} says, "${option.npcResponse}"`;
    appendNpcDialog(ctx, character.id, npc.id, npcLine);
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'npc', npcLine);
  });

  // Give an inventory item to an NPC as a gift
  spacetimedb.reducer('give_gift_to_npc', {
    characterId: t.u64(),
    npcId: t.u64(),
    itemInstanceId: t.u64(),
  }, (ctx: any, args: any) => {
    const character = requireCharacterOwnedBy(ctx, args.characterId);
    const { npcId, itemInstanceId } = args;

    const npc = ctx.db.npc.id.find(npcId);
    if (!npc) throw new SenderError('NPC not found');

    // Check location
    if (character.locationId !== npc.locationId) {
      return fail(ctx, character, 'You are not near this NPC.');
    }

    // Check item ownership
    const item = ctx.db.itemInstance.id.find(itemInstanceId);
    if (!item || item.ownerCharacterId !== character.id) {
      return fail(ctx, character, 'Item not found in your inventory.');
    }

    // Don't allow gifting equipped items
    if (item.equippedSlot) {
      return fail(ctx, character, 'Unequip the item before gifting it.');
    }

    // Check gift count (max 3 per NPC per day using giftsGiven counter)
    const affinityRow = getAffinityRow(ctx, character.id, npcId);
    // Gift cooldown is simple: we don't implement daily reset for now,
    // just cap total gifts contributing to affinity at diminishing returns

    // Get item template for value calculation
    const template = ctx.db.itemTemplate.id.find(item.templateId);
    if (!template) {
      return fail(ctx, character, 'Unknown item.');
    }

    // Calculate affinity gain based on item vendor value
    let affinityGain = template.vendorValue / 10n;
    if (affinityGain < 1n) affinityGain = 1n;
    if (affinityGain > 20n) affinityGain = 20n; // Cap gain per gift

    // Delete the item (consume it)
    if (item.quantity > 1n) {
      // Stackable: reduce quantity by 1
      ctx.db.itemInstance.id.update({
        ...item,
        quantity: item.quantity - 1n,
      });
    } else {
      ctx.db.itemInstance.id.delete(itemInstanceId);
    }

    // Award affinity
    awardNpcAffinity(ctx, character, npcId, affinityGain);

    // Update gift counter
    if (affinityRow) {
      ctx.db.npcAffinity.id.update({
        ...affinityRow,
        giftsGiven: affinityRow.giftsGiven + 1n,
      });
    }
    // If no affinityRow exists, awardNpcAffinity already created one

    // IMPORTANT: Gift dialogue goes to Journal, NOT to Log
    // Log the gift to Journal
    const giftMsg = `You give ${template.name} to ${npc.name}. (+${affinityGain} affinity)`;
    appendNpcDialog(ctx, character.id, npc.id, giftMsg);
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'npc', giftMsg);

    // NPC reaction based on current affinity (goes to Journal)
    const newAffinity = Number(getAffinityForNpc(ctx, character.id, npcId));
    let reaction: string;
    if (newAffinity >= 75) {
      reaction = `${npc.name} accepts your gift with genuine warmth. "You are too kind, friend."`;
    } else if (newAffinity >= 50) {
      reaction = `${npc.name} nods appreciatively. "A thoughtful gesture."`;
    } else if (newAffinity >= 25) {
      reaction = `${npc.name} accepts the gift. "Well, that is... unexpected."`;
    } else {
      reaction = `${npc.name} takes the offering with a brief nod.`;
    }
    appendNpcDialog(ctx, character.id, npc.id, reaction);
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'npc', reaction);
  });
};
```

Match the existing reducer registration pattern used in commands.ts -- check how deps are passed and follow the same pattern.

**Update `spacetimedb/src/reducers/index.ts`:**

1. Import `registerNpcInteractionReducers` from `./npc_interaction`.
2. Call `registerNpcInteractionReducers(deps)` in the `registerReducers` function.

**Update `spacetimedb/src/index.ts`:**

1. Import `NpcAffinity` and `NpcDialogueOption` from `./schema/tables` (add to existing import).
2. Pass them through the dependency injection if needed by reducers/views.
3. Ensure `awardNpcAffinity` and related helpers are available to the commands.ts dep injection (check how commands.ts receives its deps and add the new helpers).
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` to confirm compilation. Then publish the module:
```bash
spacetime publish uwr --project-path spacetimedb
```
Then regenerate client bindings:
```bash
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```
Verify that `NpcAffinityRow`, `NpcDialogueOptionRow`, `chooseDialogueOption`, and `giveGiftToNpc` appear in the generated bindings.
  </verify>
  <done>
hailNpc generates dynamic greetings based on affinity tier (-50 hostile, 0 stranger, 25 acquaintance, 50 friend, 75 close friend) with faction standing and renown rank context. choose_dialogue_option reducer validates affinity/faction/renown requirements, awards affinity, logs player+NPC dialogue lines. give_gift_to_npc reducer consumes inventory items (handles stacks), calculates affinity gain from vendor value (1-20 range), logs gift+reaction. Conversation cooldown enforced on hail (1 hour). Module published, bindings regenerated with new types and reducers.
  </done>
</task>

</tasks>

<verification>
- hailNpc produces different greetings at affinity levels: <-50, 0, 25, 50, 75+
- hailNpc awards 1 affinity per greeting (with cooldown)
- choose_dialogue_option validates affinity/faction/renown before allowing choice
- choose_dialogue_option logs both player text and NPC response to NpcDialog
- give_gift_to_npc consumes item (reduces stack or deletes)
- give_gift_to_npc calculates affinity gain from vendorValue/10 clamped 1-20
- NPC reaction to gift varies by current affinity tier
- Equipped items cannot be gifted
- Module publishes successfully
- Client bindings include NpcAffinityRow, NpcDialogueOptionRow, chooseDialogueOption, giveGiftToNpc
</verification>

<success_criteria>
All NPC interaction reducers functional: dynamic greetings, dialogue option selection with requirement gating, gift-giving with item consumption. Module published, bindings regenerated. Ready for Plan 03 frontend integration.
</success_criteria>

<output>
After completion, create `.planning/phases/19-npc-interactions-deepen-relationships-dialogue-complexity-affinity-systems-and-dynamic-npc-reactions-to-player-actions/19-02-SUMMARY.md`
</output>
