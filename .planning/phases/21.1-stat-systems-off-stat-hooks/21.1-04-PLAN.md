---
phase: 21.1-stat-systems-off-stat-hooks
plan: "04"
type: execute
wave: 3
depends_on:
  - "21.1-02"
  - "21.1-03"
files_modified:
  - spacetimedb/src/module_bindings/
  - src/components/StatsPanel.vue
autonomous: false
requirements:
  - STAT-01
  - STAT-02
  - STAT-03
  - STAT-04
  - STAT-05

must_haves:
  truths:
    - "The backend publishes successfully with all stat hook changes from Plans 01-03"
    - "Client bindings are regenerated and TypeScript compiles cleanly in the client"
    - "Block chance and mitigation values are visible to the player in the stats panel"
    - "The stats panel shows computed block chance (from DEX) and block mitigation (from STR)"
  artifacts:
    - path: "spacetimedb/src/module_bindings/"
      provides: "Regenerated client bindings reflecting any schema changes"
    - path: "src/components/StatsPanel.vue"
      provides: "Block chance and mitigation display computed from character.dex and character.str"
      contains: "blockChance"
  key_links:
    - from: "src/components/StatsPanel.vue"
      to: "spacetimedb/src/module_bindings/"
      via: "useTable(tables.character) accessing .dex and .str"
      pattern: "character\\.dex|character\\.str"
---

<objective>
Publish the backend with all Phase 21.1 changes, regenerate client bindings, display block chance/mitigation in the stats panel, and verify the system end-to-end.

Purpose: Plans 01-03 implement all server-side logic. This plan deploys to local SpacetimeDB, regenerates bindings, adds the client-side block stats display, and human-verifies that salvage, vendor pricing, and block stats all work correctly in-game.

Output: Local SpacetimeDB running the updated module; fresh module_bindings/; StatsPanel.vue shows "Block Chance: X%" and "Block Mitigation: X%" rows when character stats are available; human approval confirming all five off-stat hooks function correctly.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-CONTEXT.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-RESEARCH.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-01-SUMMARY.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-02-SUMMARY.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-03-SUMMARY.md
@src/components/StatsPanel.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Publish backend to local SpacetimeDB and regenerate bindings</name>
  <files>spacetimedb/src/module_bindings/</files>
  <action>
    **Step 1: Verify TypeScript compiles cleanly**
    ```bash
    cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1
    ```
    Fix any remaining errors before proceeding. Common issues from prior plans:
    - Missing imports in files that now use `statOffset`
    - TypeScript type inference issues with signed bigint arithmetic

    **Step 2: Publish to local SpacetimeDB**
    Per MEMORY.md: NEVER auto-publish to maincloud. Only local publishing is automated.
    ```bash
    spacetime publish uwr --project-path C:/projects/uwr/spacetimedb
    ```
    If this fails with a connection error, ensure SpacetimeDB is running:
    ```bash
    spacetime start
    ```
    Then retry the publish. If the schema changed (e.g., if vendorBuyMod type changed — it should NOT have changed in this phase since we kept u64), use `--clear-database -y` only if necessary and only on local.

    **Step 3: Regenerate client bindings**
    ```bash
    spacetime generate --lang typescript --out-dir C:/projects/uwr/src/module_bindings --project-path C:/projects/uwr/spacetimedb
    ```

    **Step 4: Verify client TypeScript compiles**
    ```bash
    cd C:/projects/uwr && npx tsc --noEmit 2>&1 | head -30
    ```
    Fix any client-side type errors from the regenerated bindings.
  </action>
  <verify>
    1. `spacetime logs uwr 2>&1 | tail -20` — no PANIC or ERROR entries from the module.
    2. `ls C:/projects/uwr/src/module_bindings/*.ts | wc -l` — binding files exist and are non-empty.
    3. `cd C:/projects/uwr && npx tsc --noEmit 2>&1` — zero errors.
  </verify>
  <done>
    Module published to local SpacetimeDB without errors. Client bindings regenerated. Both server and client TypeScript compile cleanly. `spacetime logs uwr` shows no panics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Display block chance and mitigation in StatsPanel.vue</name>
  <files>src/components/StatsPanel.vue</files>
  <action>
    Read `src/components/StatsPanel.vue` fully before editing. Find where combat-relevant derived stats are displayed (sections like "Combat Stats", "Offense", "Defense" etc.).

    Add block chance and mitigation display computed from the character's DEX and STR. These are computed client-side using the same formula as the server — do NOT add new backend columns (keeping block computation inline in the combat loop per the research decision).

    **In the script section**, add a computed property (or computed values in the existing setup) for block stats. If the component uses `<script setup>` with Vue composables, add:

    ```typescript
    // Import the same constants used on the server for consistency
    // Since client can't import from spacetimedb/src/, define the constants inline:
    const STAT_BASE = 10n;
    const BLOCK_CHANCE_DEX_PER_POINT = 5n;  // same as combat_scaling.ts
    const BLOCK_CHANCE_BASE = 50n;           // same as combat_scaling.ts (1000-scale)
    const BLOCK_MITIGATION_STR_PER_POINT = 2n; // same as combat_scaling.ts
    const BLOCK_MITIGATION_BASE = 30n;       // same as combat_scaling.ts (100n-scale)

    // Computed block stats from character DEX and STR
    const blockChancePercent = computed(() => {
      if (!character.value) return 0;
      const dex = character.value.dex;
      const offset = (dex - STAT_BASE) * BLOCK_CHANCE_DEX_PER_POINT;
      const raw = BLOCK_CHANCE_BASE + offset;
      const clamped = raw < 10n ? 10n : raw > 200n ? 200n : raw;
      // Convert from 1000-scale to percentage with one decimal
      return Number(clamped) / 10;  // e.g. 70n -> 7.0%
    });

    const blockMitigationPercent = computed(() => {
      if (!character.value) return 0;
      const str = character.value.str;
      const offset = (str - STAT_BASE) * BLOCK_MITIGATION_STR_PER_POINT;
      const raw = BLOCK_MITIGATION_BASE + offset;
      const clamped = raw < 10n ? 10n : raw > 80n ? 80n : raw;
      return Number(clamped);  // e.g. 38n -> 38%
    });
    ```

    Note: In Vue 3, `character` is likely a ref or computed from `useTable`. Check the existing code pattern for how character stats are accessed (e.g., `myCharacter.value`, `character.value`, or a prop). Use the exact same pattern already in the file.

    **In the template section**, add block stats display in the combat/defense stats section. Follow the existing stat row pattern in the file. Add something like:

    ```html
    <!-- Block Stats (shown always - reflects DEX/STR even without a shield) -->
    <div class="stat-row">
      <span class="stat-label">Block Chance</span>
      <span class="stat-value">{{ blockChancePercent.toFixed(1) }}% <span class="stat-note">(with shield)</span></span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Block Mitigation</span>
      <span class="stat-value">{{ blockMitigationPercent }}% <span class="stat-note">(with shield)</span></span>
    </div>
    ```

    The "(with shield)" note is important — block only activates when a shield is equipped, so showing these stats always tells the player their potential block effectiveness. This is standard RPG convention (e.g., showing parry chance even when dual-wielding).

    Match the CSS classes already used in the file for stat rows. Do NOT invent new CSS classes — look at adjacent stat rows and copy their structure exactly.

    If the component does not use `computed` from Vue, adapt to whatever reactivity pattern is already in use (e.g., plain computed properties in Options API).
  </action>
  <verify>
    1. `cd C:/projects/uwr && npx tsc --noEmit 2>&1 | head -30` — zero errors.
    2. Run the dev server: `cd C:/projects/uwr && npm run dev` — no console errors on startup.
    3. Open the StatsPanel in the browser and verify block stats rows appear with numeric values.
  </verify>
  <done>
    StatsPanel.vue shows "Block Chance: X.X% (with shield)" and "Block Mitigation: X% (with shield)" rows. Values match the formula: at DEX=10, block chance shows 5.0%; at STR=10, mitigation shows 30%. TypeScript compiles cleanly. Dev server starts without errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification of all Phase 21.1 stat systems</name>
  <files>src/components/StatsPanel.vue</files>
  <action>
    All automated work is complete. The player needs to verify that the stat systems work correctly end-to-end in the running game.

    This checkpoint covers: block stats display in UI, shield equip restriction by class, salvage producing recipe scrolls (not auto-learning), vendor pricing reflecting CHA, and no server panics from any of the new hooks.
  </action>
  <verify>
    1. Open the app in the browser. Go to the stats panel for your character.
       - Confirm "Block Chance" and "Block Mitigation" rows appear with values.
       - At base stats (DEX=10, STR=10): expect ~5.0% block chance, 30% mitigation.

    2. Test shield restriction (if shields exist in the DB):
       - Try to equip a shield on a wizard or rogue — expect rejection.
       - Try to equip a shield on a warrior — expect success.

    3. Test salvage:
       - Salvage a craftable gear item (one with a matching recipe).
       - Confirm you do NOT get an instant "You have learned: X" message.
       - Confirm you may get a "You found a recipe scroll: Scroll: X" item in inventory.
       - Right-click the scroll in inventory — confirm it teaches the recipe via the existing learn flow.

    4. Test vendor prices (if you have a character with CHA above 10):
       - Visit a vendor and note buy/sell prices.
       - A character with CHA=12 should show slightly cheaper buy prices and better sell prices than CHA=10.

    5. Check server logs for any PANICs: `spacetime logs uwr 2>&1 | tail -30`
       - Should show no errors from the new changes.
  </verify>
  <done>
    User types "approved". Block stats visible in UI. Salvage drops scrolls instead of auto-learning. No server panics observed. Vendor pricing changes observable for CHA above 10.
  </done>
  <resume-signal>Type "approved" if everything looks correct, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Full system check:
- `spacetime logs uwr 2>&1 | tail -30` — no PANIC, no ERROR from stat hooks
- `cd C:/projects/uwr && npx tsc --noEmit 2>&1` — zero client errors
- StatsPanel shows block chance and block mitigation rows with real numeric values
- salvage_item no longer auto-learns recipes (RecipeDiscovered.insert removed from that code path)
</verification>

<success_criteria>
- Backend published to local SpacetimeDB with zero publish errors
- Client bindings regenerated and TypeScript compiles cleanly on both client and server
- StatsPanel.vue displays block chance (DEX-derived, %) and block mitigation (STR-derived, %) with "(with shield)" labels
- Human verification passes: salvage drops scrolls, block stats display correctly, no server panics
- Maincloud is NOT published (manual user action only, per MEMORY.md)
</success_criteria>

<output>
After completion, create `.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-04-SUMMARY.md`
</output>
