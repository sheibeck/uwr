# Phase 21.1: Stat Systems & Off-Stat Hooks - Research

**Researched:** 2026-02-20
**Domain:** SpacetimeDB TypeScript backend — game stat formulas, combat resolution, economy, crafting/salvage
**Confidence:** HIGH (all findings from direct codebase reading)

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Block System
- Shield occupies the off-hand slot; block only triggers when a shield is equipped
- Classes that can equip shields: warrior, paladin, cleric, spellblade, shaman
- DEX drives block chance (% chance to block an incoming hit)
- STR drives block mitigation (% of damage absorbed when a block triggers)

#### Stat Scaling Formula
- Linear, symmetric around base 10
- Above 10: bonus per point above 10
- Below 10: penalty per point below 10
- Same formula applied consistently across all stats / their respective systems

#### Off-Stat Hooks
| Stat | Effect |
|------|--------|
| WIS  | % reduction to chance of pulling additional enemies (node perception mechanic unchanged) |
| INT  | % boost to recipe item drop chance on salvage |
| CHA  | % boost to vendor sell price + % discount on vendor buy price + % boost to faction gains + % boost to NPC affinity gains |
| STR  | Block mitigation % (new hook) |
| DEX  | Block chance % (new hook) |

#### Recipe System Changes
- Remove auto-learn on salvage entirely
- Salvage now drops a recipe item (same item type as mob-dropped recipes) with INT-boosted chance
- Recipe items sit in inventory, are tradeable, and are learned via right-click (same flow as existing recipe items)

### Claude's Discretion (Implementation Details)
- Exact per-point scaling values (tuning subject to playtesting)
- How stat bonuses/penalties are applied in the damage/block pipeline (additive vs multiplicative)
- Where scaling helpers live in the codebase
- Server vs client responsibility split for block resolution

### Deferred / Out of Scope
- Shield visual art / 3D models
- Block animations or VFX
- Block-related affixes or crafting modifiers
- Any other stat hooks not listed above
</user_constraints>

---

## Summary

Phase 21.1 implements four interconnected systems: a symmetric stat-scaling formula, off-stat hooks (WIS/INT/CHA vendor/faction/affinity, STR/DEX block), the block system itself (shield in offHand, DEX chance, STR mitigation), and a recipe system overhaul (remove auto-learn from salvage, replace with INT-boosted scroll drop).

The codebase is well-organized with clear seams for each injection point. Every area targeted by this phase has a single authoritative location: stats flow through `recomputeCharacterDerived` in `helpers/character.ts`; combat hit resolution flows through `rollAttackOutcome` in `helpers/combat.ts` and `resolveAttack` in `reducers/combat.ts`; pull resolution flows through `resolve_pull` in `reducers/combat.ts`; vendor buy/sell flows through `buy_item` and `sell_item` in `reducers/items.ts`; faction gains flow through `mutateStanding` in `helpers/economy.ts`; NPC affinity gains flow through `awardNpcAffinity` in `helpers/npc_affinity.ts`; salvage flows through `salvage_item` in `reducers/items.ts`.

The recipe scroll system is already fully operational — mob-dropped scrolls follow the `Scroll: RecipeName` naming pattern and are learned via `learn_recipe_scroll` reducer which reads an item from inventory. Salvage needs to drop one of these scrolls (with an INT-boosted roll) instead of directly inserting a `RecipeDiscovered` row.

**Primary recommendation:** Implement the stat-scaling helper first in `data/combat_scaling.ts` (or a new `data/stat_scaling.ts`), then wire all five systems to call it, then convert salvage to drop a scroll item rather than direct recipe-learn, and finally add shield-class restrictions to `class_stats.ts`.

---

## Codebase Architecture — Existing Systems

### 1. Stats: Where They Live and Flow

**Character table** (`schema/tables.ts` lines 258-325) stores raw stats: `str`, `dex`, `cha`, `wis`, `int` plus derived stats: `hitChance`, `dodgeChance`, `parryChance`, `critMelee`, `critRanged`, `critDivine`, `critArcane`, `armorClass`, `perception`, `search`, `ccPower`, `vendorBuyMod`, `vendorSellMod`.

**`recomputeCharacterDerived`** (`helpers/character.ts` lines 53-141) is the single source of truth for all derived stat recomputation. It combines `character.str/dex/...` + gear bonuses (from `getEquippedBonuses`) + effect bonuses (from `characterEffect` table). Called whenever equipment changes or effects are applied.

Current derived stat formulas (from `helpers/character.ts`):
```typescript
const perception   = totalStats.wis * 25n + racialPerceptionBonus;
const search       = totalStats.int * 25n;
const ccPower      = totalStats.cha * 15n;
const vendorBuyMod = totalStats.cha * 10n;   // stored, currently NOT applied at buy time
const vendorSellMod = totalStats.cha * 8n;   // stored, currently NOT applied at sell time
```

**Key insight:** `vendorBuyMod` and `vendorSellMod` are ALREADY computed from CHA and stored in the Character row. However they are NOT currently applied in `buy_item` or `sell_item` reducers — those use `getPerkBonusByField` for renown-based discounts but ignore the character's `vendorBuyMod`/`vendorSellMod` columns. This means the CHA vendor hook needs to wire these existing fields into the buy/sell reducers.

### 2. Stat Base Values

From `data/class_stats.ts`:
```typescript
export const BASE_STAT = 8n;       // all stats start at 8
export const PRIMARY_BONUS = 4n;   // class primary gets +4 at level 1 (so 12 at start)
export const SECONDARY_BONUS = 2n; // class secondary gets +2 at level 1 (so 10 at start)
```

Stats grow per level: primary +3/level, secondary +2/level, others +1/level. The locked decision requires a formula symmetric around 10: points above 10 give a bonus, points below 10 give a penalty. Since BASE_STAT=8 and characters start at 8-12 depending on class, some characters will start below 10 in off-stats (penalty applies immediately).

### 3. Combat Hit Resolution

**`rollAttackOutcome`** (`helpers/combat.ts` lines 143-178):
```typescript
export function rollAttackOutcome(seed, opts: { canBlock, canParry, canDodge, characterDex, weaponName, weaponType }) {
  const roll = seed % 1000n;
  let cursor = 0n;
  if (opts.canDodge) { cursor += 50n; if (roll < cursor) return { outcome: 'dodge', multiplier: 0n }; }
  if (opts.canParry) { cursor += 50n; if (roll < cursor) return { outcome: 'parry', multiplier: 0n }; }
  if (opts.canBlock) { cursor += 50n; if (roll < cursor) return { outcome: 'block', multiplier: 50n }; }
  // crit check...
  return { outcome: 'hit', multiplier: 100n };
}
```

**Critical observation:** Block already EXISTS in `rollAttackOutcome`. It uses `canBlock: boolean` passed in, and returns `multiplier: 50n` (50% damage on block — i.e., 50% mitigation hardcoded). The DEX-based block CHANCE and STR-based block MITIGATION need to replace these hardcoded behaviors.

**`resolveAttack`** (`reducers/combat.ts` lines 438-551) calls `rollAttackOutcome` and passes the resulting `multiplier` to compute final damage. The block multiplier comes from `rollAttackOutcome` return value.

**Where `canBlock` is determined**: In the combat loop, `hasShieldEquipped(ctx, characterId)` (defined at `helpers/combat.ts` lines 105-114) returns true if offHand item has 'shield' in name or `armorType === 'shield'`.

**Current block behavior**: `canBlock: hasShieldEquipped(...)` hardcoded to `cursor += 50n` (5% chance on 1000-scale) with `multiplier: 50n` (50% damage taken = 50% mitigation). Both values need to become stat-derived.

### 4. Auto-Attack and Ability Damage Pipeline

Auto-attack damage: `calculateStatScaledAutoAttack(baseWeaponDamage, characterStr)` from `data/combat_scaling.ts`. STR already drives auto-attack scaling (1.5% per point).

For the block system, the multiplier in `rollAttackOutcome` returns per-block-outcome. Currently hardcoded 50n (out of 100n). To make STR-driven, the function needs the character's STR or a pre-computed `blockMitigationPercent` passed in.

### 5. Pull Resolution — WIS Hook

**`resolve_pull`** (`reducers/combat.ts` lines 841-986):
- Computes `success`, `partial`, `fail` percentages based on `pullType` ('careful' or 'body') and `overlapPressure`
- Checks for `pull_veil` character effect (adds +15% success, -15% fail)
- Checks `awarenessAlert` (subtracts from success, adds to fail)
- Rolls dice: `success` → clean pull, `partial` → delayed adds, `failure` → immediate adds

**WIS hook injection point:** After the `veil` and `awarenessAlert` adjustments but before the final roll, apply a WIS-based reduction to the `addCount` or to the `partial` + `failure` outcomes. The most natural approach: WIS reduces `addCount` (number of adds that arrive on partial/failure), not the roll thresholds. This keeps the "was it a partial or failure" determination unchanged, but WIS caps how many extra enemies join.

Alternative: WIS shifts `success` up and `fail` down (same pattern as the existing `pull_veil` effect). This is more consistent with the existing pattern. Recommended approach.

### 6. Salvage — Recipe System

**Current `salvage_item`** (`reducers/items.ts` lines 1809-1897):
1. Yields crafting material (always, based on slot/tier)
2. Yields bonus modifier reagent (12% chance, if item has matching affixes)
3. **Recipe discovery (75% chance)**: Directly inserts into `RecipeDiscovered` table
4. Deletes affixes, deletes item instance

**What must change:** Step 3 must be replaced entirely:
- Remove the direct `RecipeDiscovered.insert(...)` block
- Instead: find the `Scroll: RecipeName` item template (already seeded by `ensureRecipeScrollItemTemplates`)
- Roll with INT-boosted chance (base 75% → modify with INT)
- If roll succeeds: `addItemToInventory(ctx, character.id, scrollTemplate.id, 1n)`

**Existing `learn_recipe_scroll`** reducer (`reducers/items.ts` lines 1287-1330):
```typescript
spacetimedb.reducer('learn_recipe_scroll', { characterId, itemInstanceId }, (ctx, args) => {
  // Validates item is a "Scroll: ..." item
  // Extracts recipe name, finds RecipeTemplate
  // Inserts RecipeDiscovered row
  // removeItemFromInventory(ctx, character.id, instance.templateId, 1n)
});
```

This reducer already handles the complete "right-click to learn" flow. Salvage just needs to drop the scroll item into inventory instead of directly learning.

**Scroll naming convention:** `Scroll: ${recipeName}` (e.g., `Scroll: Longsword`). The `findItemTemplateByName` helper exists in `helpers/items.ts` to look up by name.

**Scroll item properties:** `slot: 'resource'`, `stackable: true`, `rarity: 'uncommon'`, `tier: 1`. This means `addItemToInventory` handles stacking automatically.

**INT hook formula (discretion):** Recommended: `baseChance + Math.max(0, (intStat - 10) * bonusPerPoint)`. At base INT=10 the chance equals the old 75%. INT>10 increases it, INT<10 reduces it. This follows the symmetric formula.

### 7. CHA Vendor Hook

**`buy_item`** (`reducers/items.ts` lines 135-177):
- Currently applies `vendorBuyDiscount` from renown perks only
- `character.vendorBuyMod` (from `recomputeCharacterDerived`) is computed but NOT used here

**`sell_item`** (`reducers/items.ts` lines 179-240):
- Currently applies `vendorSellBonus` from renown perks only
- `character.vendorSellMod` is computed but NOT used

**Implementation:** Wire `character.vendorBuyMod` and `character.vendorSellMod` into the price calculation in `buy_item` and `sell_item`. The existing columns already scale with CHA in `recomputeCharacterDerived`.

**Current formula in character.ts:**
```typescript
vendorBuyMod  = totalStats.cha * 10n;  // 10 units per CHA point (unit = 0.1% if on 1000-scale)
vendorSellMod = totalStats.cha * 8n;   // 8 units per CHA point
```

**Interpretation:** These are probably intended as basis points or similar. The exact mapping to % discount needs to be defined. Recommended: treat `vendorBuyMod` / `vendorSellMod` as "per-1000 scale" modifiers (i.e., `vendorBuyMod = 100n` means 10% discount). At CHA=10: `vendorBuyMod = 100n` = 10% discount. Symmetric: CHA=8 → `vendorBuyMod = 80n` → 8% discount. This is already meaningful.

**Faction gains (CHA hook):** `mutateStanding` in `helpers/economy.ts` already applies `racialFactionBonus`. The CHA hook follows the same pattern — apply a `chaFactionBonus` percentage to positive deltas. Add alongside the racial check.

**NPC affinity gains (CHA hook):** `awardNpcAffinity` in `helpers/npc_affinity.ts` already applies `npcAffinityGainBonus` via renown perks. The CHA hook follows the same `multiplier` pattern. Add a CHA-derived multiplier alongside the perk multiplier.

### 8. Equipment: Shield Classes and Off-Hand Slot

**`EQUIPMENT_SLOTS`** (`helpers/items.ts` line 6-19): includes `'offHand'` already.

**`isClassAllowed`** (`helpers/character.ts` lines 143-152): checks `allowedClasses` string on item template.

**`isArmorAllowedForClass`** (`helpers/character.ts` lines 165-168): checks `CLASS_ARMOR` which already includes plate access for warrior/paladin/cleric/bard.

**`CLASS_ARMOR`** (`data/class_stats.ts` lines 73-90): Defines allowed armor types per class. Does NOT currently address shields. Shields need class-restriction logic: only warrior, paladin, cleric, spellblade, shaman can equip them.

**Shield detection:** `hasShieldEquipped` already checks `template.armorType === 'shield'` or name includes 'shield'. So `armorType: 'shield'` is the canonical way to mark a shield item.

**`ARMOR_TYPES_WITH_NONE`** in `class_stats.ts` = `['none', 'cloth', 'leather', 'chain', 'plate']`. 'shield' is NOT currently in this list. Adding 'shield' to the armor type enum is required for the equip validator to accept it.

**Class restriction for shields:** The `equip_item` reducer (`reducers/items.ts` line 476) calls `isArmorAllowedForClass(character.className, template.armorType)`. To restrict shields to specific classes, add 'shield' to `ARMOR_TYPES_WITH_NONE` and add `shield: ['warrior', 'paladin', 'cleric', 'spellblade', 'shaman']` to `CLASS_ARMOR`. Then add logic in `isArmorAllowedForClass` or `equip_item` to check it.

### 9. The Stat Scaling Formula

**Locked decision:** Linear, symmetric around base 10. Bonus per point above 10, penalty per point below 10.

**Recommended helper in `data/combat_scaling.ts` (or new `data/stat_scaling.ts`):**
```typescript
// Returns a signed integer offset: +N for stat > 10, -N for stat < 10, 0 at exactly 10
// bonusPerPoint: e.g., 2n means +2 per point above/below 10
export function statOffset(statValue: bigint, bonusPerPoint: bigint): bigint {
  return (statValue - 10n) * bonusPerPoint;
}
```

This single function is then called in:
- Block chance: `DEX offset → add to base block chance`
- Block mitigation: `STR offset → adjust damage multiplier on block`
- WIS pull reduction: `WIS offset → reduce add count or shift success/fail percentages`
- INT salvage scroll: `INT offset → modify base scroll drop chance`
- CHA vendor: already handled via `vendorBuyMod/vendorSellMod` in `recomputeCharacterDerived` (those formulas would need to use symmetric formula)
- CHA faction/affinity: apply offset as percentage modifier

**Calibration note (Claude's discretion):** Exact per-point values are not locked. Suggested starting points:
- Block chance: base 5% + (DEX - 10) * 0.5% per point (DEX=10 → 5%, DEX=14 → 7%, DEX=6 → 3%)
- Block mitigation: base 30% + (STR - 10) * 2% per point (STR=10 → 30%, STR=14 → 38%, STR=6 → 22%)
- WIS pull: (WIS - 10) * 2% reduction to `addCount` chance (on partial/fail outcomes)
- INT salvage: base 25% + (INT - 10) * 3% per point
- CHA vendor: already scales via `cha * 10n` in character.ts (each CHA point = 0.1% discount at 1000-scale), or redefine using symmetric formula

### 10. Block System Integration

**Where to add block chance:** The `resolveAttack` call site in the combat loop needs to pass `canBlock: hasShieldEquipped(...)` AND a `blockChance` parameter. Currently `rollAttackOutcome` uses hardcoded `cursor += 50n` for block. Need to parameterize this.

**Modified `rollAttackOutcome` signature:**
```typescript
export function rollAttackOutcome(seed, opts: {
  canBlock: boolean;
  blockChanceBasis?: bigint;     // NEW: replaces hardcoded 50n
  blockMitigationPercent?: bigint; // NEW: replaces hardcoded 50n
  canParry: boolean;
  canDodge: boolean;
  characterDex?: bigint;
  weaponName?: string;
  weaponType?: string;
}) {
  // ...
  if (opts.canBlock) {
    const blockChance = opts.blockChanceBasis ?? 50n;         // default 5% on 1000-scale
    const blockMitigation = opts.blockMitigationPercent ?? 50n; // default 50% mitigation
    cursor += blockChance;
    if (roll < cursor) return { outcome: 'block', multiplier: 100n - blockMitigation };
  }
  // ...
}
```

**Where to compute block stats:** In the combat loop reducer (`reducers/combat.ts`), when resolving a character being attacked, look up:
- `character.dex` → compute `blockChanceBasis = f(DEX)` using stat offset formula
- `character.str` → compute `blockMitigationPercent = f(STR)` using stat offset formula
- Pass both to `rollAttackOutcome`

The character data is available in the combat loop at the point where `resolveAttack` is called. The lookup is straightforward.

### 11. Existing Patterns to Follow

**BigInt throughout server:** All server calculations use `bigint`. Percentage calculations use `value * percent / 100n` pattern. The `1000n`-scale (0.1% per unit) is used for crit chance; the `100n`-scale is used for simpler percentages.

**Negative BigInt for penalties:** The server uses signed `i64` in `ItemAffix.magnitude` for negative affixes. For stat-based penalties, be careful: `Character.str` is `u64`, so `str - 10n` can go negative if STR < 10. The result needs to be treated as signed (TypeScript bigint handles this fine).

**`recomputeCharacterDerived` is the only place to add new derived stat columns:** If a new derived column is needed (e.g., `blockChance`, `blockMitigation`), it goes in `recomputeCharacterDerived` AND in the `Character` table schema. However, for block, the stats (DEX, STR) are already stored on Character — the derivation can happen inline in the combat loop without needing new Character columns.

---

## Architecture Patterns

### Pattern 1: Stat Scaling Helper (New)

Add a `statOffset(statValue, bonusPerPoint)` function to `data/combat_scaling.ts`. Returns `bigint` (positive, zero, or negative). Used by all five off-stat hooks and the block system.

```typescript
// data/combat_scaling.ts (addition)
export const STAT_BASE = 10n;

export function statOffset(statValue: bigint, bonusPerPoint: bigint): bigint {
  return (statValue - STAT_BASE) * bonusPerPoint;
}
```

### Pattern 2: Block Chance + Mitigation via `rollAttackOutcome`

Extend `rollAttackOutcome` opts to accept `blockChanceBasis` and `blockMitigationPercent`. Compute them from DEX/STR at the call site in the combat loop, using `statOffset`.

### Pattern 3: WIS Pull Hook

In `resolve_pull`, after the existing `veil` and `awarenessAlert` checks, apply a WIS-based `success` boost identical to the `pull_veil` pattern:
```typescript
const pullerChar = character; // already loaded
const wisOffset = statOffset(pullerChar.wis, WIS_PULL_BONUS_PER_POINT); // bigint, may be negative
success = Math.min(95, Math.max(5, success + Number(wisOffset)));
fail   = Math.max(5, Math.min(95, fail - Number(wisOffset)));
```

### Pattern 4: INT Salvage Scroll

Replace the `RecipeDiscovered.insert` block in `salvage_item` with:
```typescript
// INT-boosted scroll drop chance
const BASE_SCROLL_CHANCE = 75n;
const intBonus = statOffset(character.int, INT_SALVAGE_BONUS_PER_POINT);
const scrollChance = BASE_SCROLL_CHANCE + intBonus;
const clampedChance = scrollChance > 95n ? 95n : scrollChance < 5n ? 5n : scrollChance;
const roll = (ctx.timestamp.microsSinceUnixEpoch + character.id) % 100n;
if (roll < clampedChance) {
  const scrollTemplate = findItemTemplateByName(ctx, `Scroll: ${matchingRecipe.name}`);
  if (scrollTemplate) {
    addItemToInventory(ctx, character.id, scrollTemplate.id, 1n);
    appendPrivateEvent(..., `You found a recipe scroll: Scroll: ${matchingRecipe.name}.`);
  }
}
```

### Pattern 5: CHA Vendor Hook

In `buy_item`, apply `character.vendorBuyMod` alongside renown perk discount:
```typescript
// character.vendorBuyMod is on 1000-scale (e.g., 100n = 10% discount at CHA=10)
// Only apply for positive (discounting) values
const chaDiscount = character.vendorBuyMod; // always >= 0 (u64)
if (chaDiscount > 0n) {
  finalPrice = (finalPrice * (1000n - chaDiscount)) / 1000n;
  if (finalPrice < 1n) finalPrice = 1n;
}
```

However, if the symmetric formula means CHA < 10 gives a PENALTY (higher prices), the Character table's `vendorBuyMod` column needs to use a signed-friendly calculation. Consider making the formula:
- `vendorBuyMod = (totalStats.cha - 10n) * CHA_VENDOR_SCALE` (can be negative)
- Apply it as a signed offset to price percentage

This requires the `recomputeCharacterDerived` formula to change from `cha * 10n` to `(cha - 10n) * scale`. Both `vendorBuyMod` and `vendorSellMod` are `u64` in the schema — this would need them to either become `i64` OR clamp to 0 at the minimum.

**Simplest approach:** Keep `vendorBuyMod`/`vendorSellMod` as `u64` (clamped to 0 minimum), update the formula in `recomputeCharacterDerived` to use `(cha - 10n) * scale` but clamp negative to 0. At CHA < 10, no discount/bonus but no penalty. This avoids a schema migration for the penalty direction on vendor prices. Alternatively, change column type to `i64` to support CHA penalties as price increases — schema change required.

### Pattern 6: CHA Faction Gains

In `mutateStanding` (`helpers/economy.ts`), after the existing `racialFactionBonus` check:
```typescript
if (delta > 0n) {
  const racialBonus = character?.racialFactionBonus ?? 0n;
  if (racialBonus > 0n) { effectiveDelta = delta + (delta * racialBonus) / 100n; }

  // NEW: CHA off-stat hook
  const chaOffset = statOffset(character.cha, CHA_FACTION_BONUS_PER_POINT);
  if (chaOffset !== 0n) {
    effectiveDelta = effectiveDelta + (effectiveDelta * chaOffset) / 100n;
    if (effectiveDelta < 1n) effectiveDelta = 1n; // floor at 1 on positive delta
  }
}
```

### Pattern 7: CHA NPC Affinity Gains

In `awardNpcAffinity` (`helpers/npc_affinity.ts`), modify the `multiplier` calculation:
```typescript
let multiplier = 1.0; // personality modifier
// Existing perk bonus...
if (baseChange > 0n) {
  const affinityBonus = getPerkBonusByField(ctx, character.id, 'npcAffinityGainBonus', character.level);
  if (affinityBonus > 0) { multiplier = multiplier * (1.0 + affinityBonus / 100.0); }

  // NEW: CHA off-stat hook
  const chaOffsetPct = Number(statOffset(character.cha, CHA_AFFINITY_BONUS_PER_POINT));
  multiplier = multiplier * (1.0 + chaOffsetPct / 100.0);
}
```

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Recipe scroll items | A new item type / table | Existing `Scroll: Name` ItemTemplate + `learn_recipe_scroll` reducer | Already fully implemented, same flow as mob drops |
| Block result storage | A new table for block events | Use existing `rollAttackOutcome` return value + `resolveAttack` damage path | Already handles block outcome display |
| Stat formula | Per-system custom formulas | Single `statOffset(statValue, bonusPerPoint)` helper | Consistency, single tuning point |
| CHA vendor derived stat | New column or in-reducer computation | Existing `vendorBuyMod`/`vendorSellMod` Character columns | Already computed in `recomputeCharacterDerived` |

---

## Common Pitfalls

### Pitfall 1: BigInt Negative Overflow on u64 Stats
**What goes wrong:** `character.str - 10n` when STR < 10 produces a large positive BigInt if using unsigned arithmetic (TypeScript bigint is fine but DB schema uses `u64`). The CHARACTER table stores stats as `u64`. Direct arithmetic in TypeScript bigint handles negatives correctly, but any stored derived value must be `i64` or clamped.
**How to avoid:** Keep block-related computations entirely in-memory at the combat resolution call site — don't store `blockChance` or `blockMitigation` as Character columns. Compute from `character.dex`/`character.str` inline in the combat loop.

### Pitfall 2: `rollAttackOutcome` is used in multiple places
**What goes wrong:** The function is called both for character auto-attacks (in the combat loop) and potentially for other attack resolution. Changing its signature breaks all callers.
**How to avoid:** Make new parameters optional with backward-compatible defaults (`blockChanceBasis?: bigint` defaults to `50n`). All existing callers continue to work unchanged.

### Pitfall 3: Salvage Loop Iterates All RecipeTemplates
**What goes wrong:** `[...ctx.db.recipeTemplate.iter()]` scans the entire table. This is an existing issue but becomes more visible if called more frequently.
**How to avoid:** This is pre-existing and acceptable for now. The scan happens at most once per salvage operation.

### Pitfall 4: CHA Vendor Columns are `u64` (No Negative Support)
**What goes wrong:** The symmetric formula implies CHA < 10 gives a vendor PENALTY (higher buy prices, lower sell prices). But `vendorBuyMod`/`vendorSellMod` are `u64` — they can't store negative values.
**How to avoid:** Either (a) change schema columns to `i64` (requires table migration), or (b) define CHA vendor as bonus-only (CHA < 10 = no bonus, not a penalty). The locked decision says "symmetric" — the schema change to `i64` is the correct approach if penalties must be applied. If only bonuses, no schema change needed.

### Pitfall 5: Shield armorType Not in ARMOR_TYPES_WITH_NONE
**What goes wrong:** `equip_item` calls `normalizeArmorType(template.armorType)` which falls back to `'cloth'` for unknown types. If shields have `armorType: 'shield'`, this would make shields look like cloth items.
**How to avoid:** Add `'shield'` to `ARMOR_TYPES_WITH_NONE` in `class_stats.ts`. Also update `isArmorAllowedForClass` to check shield-class list. This requires a small `ARMOR_TYPES_WITH_NONE` update which is already a typed const.

### Pitfall 6: Auto-learn vs Scroll Drop Race Condition in Salvage
**What goes wrong:** After removing auto-learn, if a recipe scroll template doesn't exist for a given recipe (e.g., recipes added after Phase 13 seeding), `findItemTemplateByName(ctx, `Scroll: ${name}`)` returns null silently and no scroll drops.
**How to avoid:** Ensure `ensureRecipeScrollItemTemplates` is called for all gear recipes in seeding. Verify the scroll template exists before attempting the drop. Log a warning event if template is missing (helps diagnose seeding gaps).

### Pitfall 7: Pull WIS Hook Breaks Guarantee of "at least 1 add on failure"
**What goes wrong:** If WIS very aggressively reduces `addCount`, even on a `failure` outcome the player might pull cleanly. This defeats the purpose of a failed pull.
**How to avoid:** Apply WIS to the `success`/`fail` probability thresholds (as recommended in Pattern 3), not to `addCount` directly. This reduces the chance of a partial/failure but doesn't override the consequences if a partial/failure does occur.

---

## Code Examples

### Existing `rollAttackOutcome` (from `helpers/combat.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/helpers/combat.ts lines 143-178
export function rollAttackOutcome(seed, opts: { canBlock, canParry, canDodge, characterDex, weaponName, weaponType }) {
  const roll = seed % 1000n;
  let cursor = 0n;
  if (opts.canDodge) { cursor += 50n; if (roll < cursor) return { outcome: 'dodge', multiplier: 0n }; }
  if (opts.canParry) { cursor += 50n; if (roll < cursor) return { outcome: 'parry', multiplier: 0n }; }
  if (opts.canBlock) { cursor += 50n; if (roll < cursor) return { outcome: 'block', multiplier: 50n }; }
  // crit...
  return { outcome: 'hit', multiplier: 100n };
}
```

### Existing `recomputeCharacterDerived` vendor lines (from `helpers/character.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/helpers/character.ts lines 111-112
const vendorBuyMod  = totalStats.cha * 10n;
const vendorSellMod = totalStats.cha * 8n;
// These are stored in Character but NOT applied in buy_item/sell_item
```

### Existing `salvage_item` recipe block (from `reducers/items.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/reducers/items.ts lines 1866-1888 — TO BE REPLACED
const matchingRecipe = [...ctx.db.recipeTemplate.iter()].find(r => r.outputTemplateId === instance.templateId);
if (matchingRecipe) {
  const alreadyKnown = [...ctx.db.recipeDiscovered.by_character.filter(character.id)]
    .some(r => r.recipeTemplateId === matchingRecipe.id);
  if (!alreadyKnown) {
    const roll = (ctx.timestamp.microsSinceUnixEpoch + character.id) % 100n;
    if (roll < 75n) {
      ctx.db.recipeDiscovered.insert({ id: 0n, characterId: character.id, recipeTemplateId: matchingRecipe.id, discoveredAt: ctx.timestamp });
      appendPrivateEvent(..., `You have learned: ${matchingRecipe.name}`);
    }
  }
}
```

### Existing `learn_recipe_scroll` reducer (from `reducers/items.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/reducers/items.ts lines 1287-1330
// Already handles: validate scroll, extract recipe name, insert RecipeDiscovered, consume scroll
// Salvage drop + this reducer = complete recipe item flow
```

### Existing `resolve_pull` WIS injection point (from `reducers/combat.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/reducers/combat.ts lines 893-908
// After these lines, add WIS-based success/fail adjustment:
const veil = deps.sumCharacterEffect(ctx, character.id, 'pull_veil');
if (veil > 0n) {
  success = Math.min(95, success + 15);
  fail = Math.max(5, fail - 15);
  // ...
}
const awarenessAlert = ...;
if (awarenessAlert) {
  success = Math.max(5, success - 10);
  fail = Math.min(95, fail + 10);
}
// ← WIS hook goes HERE
```

### Existing `mutateStanding` CHA injection point (from `helpers/economy.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/helpers/economy.ts lines 6-24
export function mutateStanding(ctx, characterId, factionId, delta) {
  let effectiveDelta = delta;
  if (delta > 0n) {
    const character = ctx.db.character.id.find(characterId);
    const racialBonus = character?.racialFactionBonus ?? 0n;
    if (racialBonus > 0n) {
      effectiveDelta = delta + (delta * racialBonus) / 100n;
    }
    // ← CHA hook goes HERE (same pattern as racialBonus)
  }
  // ...
}
```

### Existing `awardNpcAffinity` CHA injection point (from `helpers/npc_affinity.ts`)
```typescript
// Source: C:/projects/uwr/spacetimedb/src/helpers/npc_affinity.ts lines 31-52
if (baseChange > 0n) {
  const affinityBonus = getPerkBonusByField(ctx, character.id, 'npcAffinityGainBonus', character.level);
  if (affinityBonus > 0) { multiplier = multiplier * (1.0 + affinityBonus / 100.0); }
  // ← CHA hook goes HERE (same pattern, add to multiplier)
}
```

---

## Schema Changes Required

| Change | File | Why |
|--------|------|-----|
| Add `'shield'` to `ARMOR_TYPES_WITH_NONE` | `data/class_stats.ts` | Shield armorType must be recognized as valid |
| Add `shield: [classes]` to `CLASS_ARMOR` | `data/class_stats.ts` | Restrict shield equip to correct classes |
| Optionally change `vendorBuyMod`/`vendorSellMod` to `i64` | `schema/tables.ts` | Only if CHA < 10 should increase buy price / decrease sell price |
| No new tables required | — | Block uses existing combat flow; recipe drops use existing ItemInstance |

---

## File-by-File Change Map

| File | Changes |
|------|---------|
| `data/combat_scaling.ts` | Add `STAT_BASE`, `statOffset()` helper, block chance/mitigation constants |
| `data/class_stats.ts` | Add `'shield'` to `ARMOR_TYPES_WITH_NONE`; add shield to `CLASS_ARMOR` for allowed classes |
| `helpers/combat.ts` | Extend `rollAttackOutcome` opts for `blockChanceBasis`, `blockMitigationPercent` |
| `helpers/character.ts` | Update `vendorBuyMod`/`vendorSellMod` formula to use symmetric `(cha - 10n) * scale` |
| `helpers/economy.ts` | Add CHA hook in `mutateStanding` for positive faction deltas |
| `helpers/npc_affinity.ts` | Add CHA hook in `awardNpcAffinity` multiplier for positive affinity changes |
| `reducers/combat.ts` | In `resolve_pull`: add WIS hook to adjust success/fail percentages. In combat loop: compute block DEX/STR values, pass to `rollAttackOutcome` |
| `reducers/items.ts` | In `buy_item`: apply `character.vendorBuyMod`. In `sell_item`: apply `character.vendorSellMod`. In `salvage_item`: replace auto-learn block with INT-boosted scroll drop |

---

## Open Questions

1. **Should CHA < 10 penalize vendor prices (higher buy / lower sell)?**
   - What we know: The symmetric formula implies penalty below 10. `vendorBuyMod`/`vendorSellMod` are `u64` columns.
   - What's unclear: Whether a full schema migration is in scope for this phase.
   - Recommendation: If penalties are desired, change column types to `i64` (small schema change). If bonus-only (simplest), clamp the formula at 0 in `recomputeCharacterDerived`.

2. **Exact per-point scaling values for all 5 hooks.**
   - What we know: Discretion left to implementation. All hooks need concrete starting values.
   - Recommendation: Propose defaults in task descriptions; flag as "tune via playtesting."

3. **Should the `vendorBuyMod`/`vendorSellMod` columns be reused or should new Character columns be added for the symmetric CHA vendor values?**
   - What we know: The existing columns are computed from `cha * 10n` (not symmetric, no penalty below 10).
   - Recommendation: Reuse the columns, update the formula in `recomputeCharacterDerived` to use `(cha - 10n) * scale` + clamp.

4. **Client display of block chance and mitigation?**
   - What we know: The client has a character stats UI. Block stats are not currently displayed.
   - What's unclear: Whether the phase requires client UI updates for the new stats.
   - Recommendation: Block chance/mitigation can be computed client-side from character.dex/character.str using the same formula, displayed in the character stats panel. No new server columns needed if computed on-the-fly.

---

## Sources

### Primary (HIGH confidence)
- `C:/projects/uwr/spacetimedb/src/schema/tables.ts` — full Character schema, ItemInstance, RecipeTemplate, RecipeDiscovered, PullState, VendorInventory
- `C:/projects/uwr/spacetimedb/src/helpers/character.ts` — `recomputeCharacterDerived`, all derived stat formulas
- `C:/projects/uwr/spacetimedb/src/helpers/combat.ts` — `rollAttackOutcome`, `hasShieldEquipped`, combat helpers
- `C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — `resolveAttack`, `resolve_pull`, combat loop
- `C:/projects/uwr/spacetimedb/src/reducers/items.ts` — `salvage_item`, `learn_recipe_scroll`, `buy_item`, `sell_item`
- `C:/projects/uwr/spacetimedb/src/data/combat_scaling.ts` — existing STR/DEX scaling formulas
- `C:/projects/uwr/spacetimedb/src/data/class_stats.ts` — BASE_STAT, CLASS_CONFIG, CLASS_ARMOR, ARMOR_TYPES
- `C:/projects/uwr/spacetimedb/src/helpers/economy.ts` — `mutateStanding`, faction gain logic
- `C:/projects/uwr/spacetimedb/src/helpers/npc_affinity.ts` — `awardNpcAffinity`, affinity multiplier logic
- `C:/projects/uwr/spacetimedb/src/helpers/items.ts` — EQUIPMENT_SLOTS, `findItemTemplateByName`
- `C:/projects/uwr/spacetimedb/src/seeding/ensure_items.ts` — `ensureRecipeScrollItemTemplates`, scroll naming

---

## Metadata

**Confidence breakdown:**
- Block system seams: HIGH — `rollAttackOutcome`, `hasShieldEquipped`, `resolveAttack` all directly read and verified
- Recipe scroll drop: HIGH — `learn_recipe_scroll`, `salvage_item`, `ensureRecipeScrollItemTemplates` all directly read
- CHA vendor hook: HIGH — column existence verified in schema and character.ts; gap between stored value and usage confirmed
- WIS pull hook: HIGH — `resolve_pull` logic fully read, injection point identified
- CHA faction/affinity hooks: HIGH — `mutateStanding`, `awardNpcAffinity` both fully read
- Stat scaling formula: HIGH — existing stat formulas in `class_stats.ts` and `combat_scaling.ts` verified

**Research date:** 2026-02-20
**Valid until:** 2026-04-20 (codebase is stable; changes only if server source modified)
