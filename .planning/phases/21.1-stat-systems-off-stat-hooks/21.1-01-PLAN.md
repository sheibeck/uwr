---
phase: 21.1-stat-systems-off-stat-hooks
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/data/combat_scaling.ts
  - spacetimedb/src/data/class_stats.ts
  - spacetimedb/src/data/item_defs.ts
  - spacetimedb/src/seeding/ensure_items.ts
autonomous: true
requirements:
  - STAT-01
  - STAT-02

must_haves:
  truths:
    - "statOffset() helper exists and returns a signed bigint based on (statValue - 10n) * bonusPerPoint"
    - "Shield is a valid armor type recognized by the equip system without falling back to 'cloth'"
    - "Only warrior, paladin, cleric, spellblade, shaman can equip shields — other classes are rejected at equip_item time"
    - "The Wooden Shield item_defs entry has armorType 'shield' and allowedClasses matching the five shield classes"
  artifacts:
    - path: "spacetimedb/src/data/combat_scaling.ts"
      provides: "statOffset() helper and STAT_BASE constant"
      contains: "export function statOffset"
    - path: "spacetimedb/src/data/class_stats.ts"
      provides: "Shield in armor type list, CLASS_ARMOR, and isArmorAllowedForClass routing shield correctly"
      contains: "shield"
    - path: "spacetimedb/src/data/item_defs.ts"
      provides: "Wooden Shield with correct armorType and allowedClasses"
      contains: "armorType: 'shield'"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "statOffset import"
      pattern: "statOffset"
    - from: "spacetimedb/src/data/class_stats.ts"
      to: "CLASS_ARMOR"
      via: "isArmorAllowedForClass routes through CLASS_ARMOR which now includes shield"
      pattern: "CLASS_ARMOR.*shield|shield.*CLASS_ARMOR"
---

<objective>
Add the symmetric stat-scaling helper and wire shield class restrictions into the data layer.

Purpose: All five off-stat hooks and the block system share one `statOffset()` formula. Shield equipment restrictions require armor type data + class validation. These are pure data/helper changes with zero impact on game behavior until later plans wire them in.

Output: `statOffset()` exported from `data/combat_scaling.ts`; 'shield' added to armor type constants and CLASS_ARMOR; Wooden Shield item_defs entry corrected to armorType 'shield' and correct allowedClasses.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-CONTEXT.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-RESEARCH.md
@spacetimedb/src/data/combat_scaling.ts
@spacetimedb/src/data/class_stats.ts
@spacetimedb/src/data/item_defs.ts
@spacetimedb/src/seeding/ensure_items.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add statOffset() helper to combat_scaling.ts</name>
  <files>spacetimedb/src/data/combat_scaling.ts</files>
  <action>
    Append to the end of `spacetimedb/src/data/combat_scaling.ts` (after the existing `calculateHealingPower` and `applyMagicResistMitigation` functions):

    ```typescript
    // ============================================================================
    // STAT OFFSET SCALING (Phase 21.1)
    // ============================================================================

    /**
     * Symmetric stat scaling base — all off-stat hooks scale around this value.
     * Formula: bonus above STAT_BASE = penalty below STAT_BASE (mirror symmetry).
     */
    export const STAT_BASE = 10n;

    /**
     * Compute a signed bigint offset for a stat relative to STAT_BASE (10).
     * Returns: (statValue - STAT_BASE) * bonusPerPoint
     *   - statValue > 10: positive offset (bonus)
     *   - statValue = 10: zero offset (no change)
     *   - statValue < 10: negative offset (penalty)
     *
     * TypeScript bigint handles negatives natively.
     * Do NOT store this as u64 in the DB — compute inline at call sites only.
     *
     * @param statValue  Character stat (u64 from DB, treated as signed in arithmetic)
     * @param bonusPerPoint Bonus per point above 10 (same magnitude used for penalty below 10)
     */
    export function statOffset(statValue: bigint, bonusPerPoint: bigint): bigint {
      return (statValue - STAT_BASE) * bonusPerPoint;
    }

    // ===== Block system constants (DEX / STR) =====

    /** Block chance on 1000-scale per DEX point above/below 10.
     *  5n = 0.5% per point. At DEX=10: base only. At DEX=14: +2%. At DEX=6: -2%. */
    export const BLOCK_CHANCE_DEX_PER_POINT = 5n;

    /** Base block chance on 1000-scale (50n = 5%). Applied when shield is equipped.
     *  DEX offset added/subtracted from this base. */
    export const BLOCK_CHANCE_BASE = 50n;

    /** Block mitigation per STR point above/below 10, on 100n (percent) scale.
     *  2n = 2% per point. At STR=10: 30%. At STR=14: 38%. At STR=6: 22%. */
    export const BLOCK_MITIGATION_STR_PER_POINT = 2n;

    /** Base block mitigation percent on 100n scale (30n = 30% damage absorbed).
     *  STR offset added/subtracted from this base. */
    export const BLOCK_MITIGATION_BASE = 30n;

    // ===== WIS pull hook constant =====

    /** WIS offset per point for pull success/fail shift, in integer percentage points.
     *  2n = ±2 percentage points per WIS point above/below 10. */
    export const WIS_PULL_BONUS_PER_POINT = 2n;

    // ===== INT salvage scroll constant =====

    /** INT offset per point for scroll drop chance, on 100n (percent) scale.
     *  3n = ±3% per point. At INT=10: base 25%. At INT=14: 37%. At INT=6: 13%. */
    export const INT_SALVAGE_BONUS_PER_POINT = 3n;

    /** Base scroll drop chance on 100n scale. Replaces old hardcoded 75n auto-learn.
     *  Lower base reflects that the player now gets a tradeable item (more valuable). */
    export const SALVAGE_SCROLL_CHANCE_BASE = 25n;

    // ===== CHA hooks constants =====

    /** CHA offset per point for faction gains, on 100n (percent) scale.
     *  1n = ±1% per point. Applied as a multiplier on positive faction deltas. */
    export const CHA_FACTION_BONUS_PER_POINT = 1n;

    /** CHA offset per point for NPC affinity gains, on 100n (percent) scale.
     *  1n = ±1% per point. Applied as a multiplier on positive affinity changes. */
    export const CHA_AFFINITY_BONUS_PER_POINT = 1n;

    /** CHA vendor modifier scale for recomputeCharacterDerived.
     *  10n means CHA=10 gives +0, CHA=11 gives +10, CHA=9 gives -10 (on 1000-scale).
     *  vendorBuyMod = (cha - 10) * 10 (clamped ≥ 0 to avoid penalties on u64 col) */
    export const CHA_VENDOR_SCALE = 10n;

    /** CHA vendor sell modifier scale for recomputeCharacterDerived.
     *  8n means CHA=10 gives +0, CHA=11 gives +8, CHA=9 gives -8 (on 1000-scale).
     *  vendorSellMod = (cha - 10) * 8 (clamped ≥ 0 to avoid penalties on u64 col) */
    export const CHA_VENDOR_SELL_SCALE = 8n;
    ```

    Note: The CHA vendor columns (`vendorBuyMod`, `vendorSellMod`) remain `u64` (no schema migration). The formula changes from `cha * scale` to `(cha - 10n) * scale` clamped at 0n. This means CHA < 10 gives no bonus (not a penalty), consistent with the u64 constraint. CHA > 10 gives the expected bonus. This is documented clearly in the constants.
  </action>
  <verify>Run: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30`. No TypeScript errors in combat_scaling.ts.</verify>
  <done>File exports `statOffset`, `STAT_BASE`, and all six system constants (BLOCK_CHANCE_BASE, BLOCK_CHANCE_DEX_PER_POINT, BLOCK_MITIGATION_BASE, BLOCK_MITIGATION_STR_PER_POINT, WIS_PULL_BONUS_PER_POINT, INT_SALVAGE_BONUS_PER_POINT, SALVAGE_SCROLL_CHANCE_BASE, CHA_FACTION_BONUS_PER_POINT, CHA_AFFINITY_BONUS_PER_POINT, CHA_VENDOR_SCALE, CHA_VENDOR_SELL_SCALE). TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add shield armor type and class restrictions in class_stats.ts</name>
  <files>spacetimedb/src/data/class_stats.ts</files>
  <action>
    All changes are in `spacetimedb/src/data/class_stats.ts` only. Do NOT modify `helpers/character.ts` — `isArmorAllowedForClass` is defined in `class_stats.ts` at lines 165-169 and already routes through `CLASS_ARMOR`, so updating CLASS_ARMOR is sufficient.

    **Step 1: Add 'shield' to ARMOR_TYPES_WITH_NONE**

    Change this line:
    ```typescript
    export const ARMOR_TYPES_WITH_NONE = ['none', ...ARMOR_TYPES] as const;
    ```
    to:
    ```typescript
    export const ARMOR_TYPES_WITH_NONE = ['none', ...ARMOR_TYPES, 'shield'] as const;
    ```
    This makes `normalizeArmorType('shield')` return `'shield'` instead of falling back to `'cloth'`.

    **Step 2: Add 'shield' to CLASS_ARMOR for the five allowed classes**

    The locked decision is: warrior, paladin, cleric, spellblade, shaman. Update those five entries in `CLASS_ARMOR` to include 'shield' in their armor array:
    ```typescript
    warrior: ['plate', 'chain', 'leather', 'cloth', 'shield'],
    paladin: ['plate', 'chain', 'leather', 'cloth', 'shield'],
    cleric: ['plate', 'chain', 'leather', 'cloth', 'shield'],
    spellblade: ['chain', 'leather', 'cloth', 'shield'],
    shaman: ['chain', 'leather', 'cloth', 'shield'],
    ```
    All other classes remain unchanged — they do not get 'shield' in their list.

    **Step 3: Add SHIELD_CLASSES export constant**

    After the CLASS_ARMOR definition, add:
    ```typescript
    export const SHIELD_CLASSES = new Set([
      'warrior', 'paladin', 'cleric', 'spellblade', 'shaman',
    ]);
    ```

    The existing `isArmorAllowedForClass` function (lines 165-169) needs no modification. It already does:
    ```typescript
    export function isArmorAllowedForClass(className: string, armorType: string) {
      const normalized = normalizeClassName(className);
      const allowed = CLASS_ARMOR[normalized] ?? ['cloth'];
      return allowed.includes(normalizeArmorType(armorType));
    }
    ```
    Since 'shield' is now in `ARMOR_TYPES_WITH_NONE` (so `normalizeArmorType('shield')` returns 'shield') and in `CLASS_ARMOR` for the five allowed classes, the function automatically handles shield restrictions correctly without any changes to the function body or to `helpers/character.ts`.
  </action>
  <verify>
    1. Run: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30`. No TypeScript errors.
    2. Grep: `grep -n "shield" C:/projects/uwr/spacetimedb/src/data/class_stats.ts` — should show 'shield' in ARMOR_TYPES_WITH_NONE, SHIELD_CLASSES, and five CLASS_ARMOR entries.
  </verify>
  <done>
    - `ARMOR_TYPES_WITH_NONE` includes 'shield'
    - `CLASS_ARMOR` has 'shield' in warrior, paladin, cleric, spellblade, shaman arrays only
    - `normalizeArmorType('shield')` returns 'shield' (not 'cloth')
    - `isArmorAllowedForClass('warrior', 'shield')` returns true; `isArmorAllowedForClass('wizard', 'shield')` returns false
    - TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix Wooden Shield item data and audit seeding for shield items</name>
  <files>spacetimedb/src/data/item_defs.ts, spacetimedb/src/seeding/ensure_items.ts</files>
  <action>
    The CLASS_ARMOR approach only restricts items with `armorType: 'shield'`. The existing Wooden Shield entry has `armorType: 'none'`, which means the class restriction is silently bypassed — any class can equip it. This must be fixed.

    **Step 1: Fix Wooden Shield in item_defs.ts**

    Locate the Wooden Shield entry in `spacetimedb/src/data/item_defs.ts` (line 271). It currently reads:
    ```typescript
    { name: 'Wooden Shield', slot: 'offHand', armorType: 'none', rarity: 'common', tier: 1n, isJunk: false, vendorValue: 5n, requiredLevel: 1n, allowedClasses: 'warrior,paladin,bard,cleric', armorClassBonus: 4n, description: 'A round wooden shield banded with iron.' },
    ```

    Change it to:
    ```typescript
    { name: 'Wooden Shield', slot: 'offHand', armorType: 'shield', rarity: 'common', tier: 1n, isJunk: false, vendorValue: 5n, requiredLevel: 1n, allowedClasses: 'warrior,paladin,cleric,spellblade,shaman', armorClassBonus: 4n, description: 'A round wooden shield banded with iron.' },
    ```

    Two changes:
    - `armorType: 'none'` → `armorType: 'shield'`
    - `allowedClasses: 'warrior,paladin,bard,cleric'` → `allowedClasses: 'warrior,paladin,cleric,spellblade,shaman'`

    **Step 2: Audit seeding/ensure_items.ts for other shield items**

    Read `spacetimedb/src/seeding/ensure_items.ts` and search for any item entries with:
    - `slot: 'offHand'` combined with any shield-like name
    - `armorType: 'none'` on items that should be shields
    - Any item named with "Shield" in it

    For any shield-type items found in seeding:
    - Set `armorType: 'shield'`
    - Set `allowedClasses: 'warrior,paladin,cleric,spellblade,shaman'` (the five locked classes)

    If no shield items exist in seeding beyond the Wooden Shield (which comes from item_defs.ts, not seeding), note this in the summary. Do not make unnecessary changes.
  </action>
  <verify>
    1. Run: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30`. No TypeScript errors.
    2. Grep: `grep -n "Wooden Shield" C:/projects/uwr/spacetimedb/src/data/item_defs.ts` — should show `armorType: 'shield'` and `allowedClasses: 'warrior,paladin,cleric,spellblade,shaman'`.
    3. Grep: `grep -in "shield" C:/projects/uwr/spacetimedb/src/seeding/ensure_items.ts` — review all matches; any shield-slot items should have `armorType: 'shield'`.
  </verify>
  <done>
    - Wooden Shield in item_defs.ts has `armorType: 'shield'` (not 'none')
    - Wooden Shield `allowedClasses` matches the five locked shield classes: warrior, paladin, cleric, spellblade, shaman (bard removed)
    - Any other shield items in seeding have been corrected or confirmed correct
    - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
Run `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1`. Zero errors.

Check exports:
- `grep "statOffset\|STAT_BASE\|BLOCK_CHANCE\|BLOCK_MITIGATION\|WIS_PULL\|INT_SALVAGE\|CHA_FACTION\|CHA_AFFINITY\|CHA_VENDOR" C:/projects/uwr/spacetimedb/src/data/combat_scaling.ts` — all constants present.
- `grep "shield" C:/projects/uwr/spacetimedb/src/data/class_stats.ts` — appears in ARMOR_TYPES_WITH_NONE, SHIELD_CLASSES, and five CLASS_ARMOR entries.
- `grep "Wooden Shield" C:/projects/uwr/spacetimedb/src/data/item_defs.ts` — shows armorType: 'shield' and correct allowedClasses.
</verification>

<success_criteria>
- `statOffset(14n, 2n)` would return `8n`; `statOffset(6n, 2n)` would return `-8n`; `statOffset(10n, 2n)` would return `0n`
- All scaling constants are named, documented with comments explaining the scale (1000-scale vs 100-scale) and intent
- Shield is recognized as a valid armor type — no class treats it as 'cloth'
- Five shield classes (warrior, paladin, cleric, spellblade, shaman) allow shield in CLASS_ARMOR; all other classes do not
- Wooden Shield has armorType 'shield' — class restriction is actually enforced by equip_item, not silently bypassed
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-01-SUMMARY.md`
</output>
