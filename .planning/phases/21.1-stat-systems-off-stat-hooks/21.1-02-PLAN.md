---
phase: 21.1-stat-systems-off-stat-hooks
plan: "02"
type: execute
wave: 2
depends_on:
  - "21.1-01"
files_modified:
  - spacetimedb/src/helpers/combat.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true
requirements:
  - STAT-03
  - STAT-04

must_haves:
  truths:
    - "Block chance scales with DEX: a warrior with DEX=14 blocks more often than one with DEX=6"
    - "Block mitigation scales with STR: a warrior with STR=14 absorbs more damage on block than one with STR=6"
    - "Block only triggers when a shield is equipped in the off-hand slot"
    - "WIS reduces the probability of a bad pull outcome: higher WIS shifts success% up and fail% down"
    - "WIS hook applies the same success/fail adjustment pattern as the existing pull_veil effect"
  artifacts:
    - path: "spacetimedb/src/helpers/combat.ts"
      provides: "Parameterized blockChanceBasis and blockMitigationPercent in rollAttackOutcome"
      contains: "blockChanceBasis"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "blockChanceBasis/blockMitigationPercent on resolveAttack param type; DEX/STR values computed at combat loop; WIS hook in resolve_pull"
      contains: "statOffset"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/combat.ts"
      via: "rollAttackOutcome call with blockChanceBasis and blockMitigationPercent (threaded through resolveAttack)"
      pattern: "blockChanceBasis.*blockMitigationPercent|blockMitigationPercent.*blockChanceBasis"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "statOffset import for block and WIS"
      pattern: "statOffset.*BLOCK|WIS_PULL"
---

<objective>
Wire DEX/STR block system and WIS pull hook into the combat reducers, using the statOffset() helper established in Plan 01.

Purpose: The block system currently uses hardcoded 5% chance and 50% mitigation. This plan makes both values stat-derived (DEX for chance, STR for mitigation) and adds the WIS hook to pull probability. All changes are server-side only; no schema changes needed.

Output: `rollAttackOutcome` accepts optional `blockChanceBasis` and `blockMitigationPercent` params (backward-compatible defaults). The `resolveAttack` wrapper in `reducers/combat.ts` also accepts and threads these params. Combat loop computes DEX/STR values and passes them to `resolveAttack`. `resolve_pull` adjusts success/fail% based on WIS offset.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-CONTEXT.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-RESEARCH.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-01-SUMMARY.md
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/data/combat_scaling.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize rollAttackOutcome block values in helpers/combat.ts</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
    Locate `rollAttackOutcome` in `spacetimedb/src/helpers/combat.ts` (approximately lines 143-178 per research).

    Extend the opts type to add two optional parameters with backward-compatible defaults:

    ```typescript
    // BEFORE (existing opts type, abbreviated):
    opts: {
      canBlock: boolean;
      canParry: boolean;
      canDodge: boolean;
      characterDex?: bigint;
      weaponName?: string;
      weaponType?: string;
    }

    // AFTER (add two optional fields):
    opts: {
      canBlock: boolean;
      blockChanceBasis?: bigint;        // NEW: on 1000-scale; default 50n (5%)
      blockMitigationPercent?: bigint;  // NEW: on 100n-scale; default 50n (50% mitigation)
      canParry: boolean;
      canDodge: boolean;
      characterDex?: bigint;
      weaponName?: string;
      weaponType?: string;
    }
    ```

    Update the block resolution section inside the function body. Currently it looks like:
    ```typescript
    if (opts.canBlock) { cursor += 50n; if (roll < cursor) return { outcome: 'block', multiplier: 50n }; }
    ```

    Replace with:
    ```typescript
    if (opts.canBlock) {
      const blockChance = opts.blockChanceBasis ?? 50n;          // default 5% on 1000-scale
      const blockMitigation = opts.blockMitigationPercent ?? 50n; // default 50% mitigation
      cursor += blockChance;
      if (roll < cursor) {
        // multiplier represents damage taken: 100% - mitigation%
        // e.g. 30% mitigation → multiplier 70n (player takes 70% of hit damage)
        const damageTaken = 100n - blockMitigation;
        return { outcome: 'block', multiplier: damageTaken > 0n ? damageTaken : 1n };
      }
    }
    ```

    All existing callers of `rollAttackOutcome` that do NOT pass `blockChanceBasis`/`blockMitigationPercent` continue to use the default 50n values, so backward compatibility is preserved.

    Do NOT change any other part of the function.
  </action>
  <verify>
    1. `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30` — zero errors.
    2. Grep: `grep -n "blockChanceBasis\|blockMitigationPercent" C:/projects/uwr/spacetimedb/src/helpers/combat.ts` — both fields appear in opts type and function body.
  </verify>
  <done>
    `rollAttackOutcome` opts type includes `blockChanceBasis?: bigint` and `blockMitigationPercent?: bigint`. The block resolution section uses these values with `?? 50n` fallback defaults. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire DEX/STR block values and WIS hook in reducers/combat.ts</name>
  <files>spacetimedb/src/reducers/combat.ts</files>
  <action>
    **Part A: Thread blockChanceBasis/blockMitigationPercent through the resolveAttack wrapper**

    IMPORTANT CONTEXT: `resolveAttack` in `reducers/combat.ts` is a local wrapper function (defined around line 438) that internally calls `rollAttackOutcome`. To pass stat-derived block values through to `rollAttackOutcome`, you must update BOTH the wrapper AND its call sites. There are four steps:

    **Step 1 — Add imports at the top of reducers/combat.ts:**
    ```typescript
    import {
      statOffset,
      BLOCK_CHANCE_BASE,
      BLOCK_CHANCE_DEX_PER_POINT,
      BLOCK_MITIGATION_BASE,
      BLOCK_MITIGATION_STR_PER_POINT,
      WIS_PULL_BONUS_PER_POINT,
    } from '../data/combat_scaling.js';
    ```
    (Use `.js` extension — check existing imports in the file to confirm the extension pattern.)

    **Step 2 — Extend resolveAttack's parameter type to accept the two new optional fields:**

    In the `resolveAttack` parameter destructuring and its type annotation (around line 459), add:
    ```typescript
    blockChanceBasis?: bigint;        // NEW: stat-derived, on 1000-scale
    blockMitigationPercent?: bigint;  // NEW: stat-derived, on 100n-scale
    ```
    These go in the same param object as `canBlock`, `canParry`, `canDodge`, etc.

    **Step 3 — Thread the values into rollAttackOutcome inside resolveAttack:**

    The current call inside `resolveAttack` (around line 495) is:
    ```typescript
    const outcome = rollAttackOutcome(seed, { canBlock, canParry, canDodge, characterDex, weaponName, weaponType });
    ```

    Update it to pass through the new params:
    ```typescript
    const outcome = rollAttackOutcome(seed, {
      canBlock,
      blockChanceBasis,       // NEW — undefined if not provided, rollAttackOutcome uses ?? 50n default
      blockMitigationPercent, // NEW — undefined if not provided, rollAttackOutcome uses ?? 50n default
      canParry,
      canDodge,
      characterDex,
      weaponName,
      weaponType,
    });
    ```

    **Step 4 — Compute stat-derived values at the two combat loop call sites where canBlock can be true:**

    There are two call sites:
    - ~Line 2108: character attacks enemy (`canBlock: hasShieldEquipped(ctx, character.id)`)
    - ~Line 2848: enemy attacks character (`canBlock: hasShieldEquipped(ctx, targetCharacter.id)`)

    At each call site, determine which character's DEX and STR to use (the defender's stats). Read the actual code to confirm variable names before editing.

    At the character-attacks-enemy call site (~line 2108), the defender is the enemy (no DEX/STR stats available for enemies), so pass no blockChanceBasis/blockMitigationPercent — the defaults in rollAttackOutcome apply. NOTE: if after reading the code this canBlock check refers to the character blocking, use character.dex and character.str.

    At the enemy-attacks-character call site (~line 2848), the defender is `targetCharacter`. Immediately before the `resolveAttack(...)` call, compute:

    ```typescript
    // Compute stat-derived block values for the defending character
    const blockChanceBasis: bigint = (() => {
      const offset = statOffset(targetCharacter.dex, BLOCK_CHANCE_DEX_PER_POINT);
      const raw = BLOCK_CHANCE_BASE + offset;
      // Clamp to [10n, 200n] on 1000-scale (1% min, 20% max)
      return raw < 10n ? 10n : raw > 200n ? 200n : raw;
    })();

    const blockMitigationPercent: bigint = (() => {
      const offset = statOffset(targetCharacter.str, BLOCK_MITIGATION_STR_PER_POINT);
      const raw = BLOCK_MITIGATION_BASE + offset;
      // Clamp to [10n, 80n] on 100n-scale (10% min, 80% max)
      return raw < 10n ? 10n : raw > 80n ? 80n : raw;
    })();
    ```

    Then pass these to `resolveAttack`:
    ```typescript
    resolveAttack(ctx, {
      ...existingParams,
      blockChanceBasis,       // NEW
      blockMitigationPercent, // NEW
    });
    ```

    CRITICAL: Read the actual code at BOTH call sites before modifying. Use the exact variable names that are in scope. Do not invent variable names.

    **Part B: WIS hook in resolve_pull**

    Locate `resolve_pull` reducer in the same file (approximately lines 841-986 per research). Find the section after the `pull_veil` and `awarenessAlert` adjustments. The research shows the injection point:

    ```typescript
    // After awarenessAlert block ends — insert WIS hook here:
    // WIS off-stat hook: WIS shifts pull success% up and fail% down (same pattern as pull_veil)
    const wisOffset = Number(statOffset(character.wis, WIS_PULL_BONUS_PER_POINT));
    if (wisOffset !== 0) {
      success = Math.min(95, Math.max(5, success + wisOffset));
      fail    = Math.max(5, Math.min(95, fail - wisOffset));
      // partial is the remainder (100 - success - fail), not adjusted directly
    }
    ```

    The WIS hook MUST be placed AFTER both the `pull_veil` effect and `awarenessAlert` adjustments, and BEFORE the final dice roll. The `character` variable (the pulling character) must already be in scope at this point — verify before adding code.

    Ensure the `statOffset` and `WIS_PULL_BONUS_PER_POINT` import is added (see Step 1 imports above).
  </action>
  <verify>
    1. `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30` — zero errors.
    2. Grep: `grep -n "blockChanceBasis\|blockMitigationPercent" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — at minimum four occurrences: in resolveAttack param type, in rollAttackOutcome call inside resolveAttack, and in each relevant combat loop call site.
    3. Grep: `grep -n "WIS_PULL_BONUS_PER_POINT\|wisOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — WIS hook present in resolve_pull.
    4. Grep: `grep -n "statOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — imported and used.
    5. Confirm WIS hook order: `grep -n -A 5 "wisOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — verify the wisOffset lines appear BEFORE the dice roll line in resolve_pull (the roll line will be something like `const roll = ...` or `if (rand < success)`).
  </verify>
  <done>
    - `resolveAttack` param type includes `blockChanceBasis?: bigint` and `blockMitigationPercent?: bigint`
    - `rollAttackOutcome` inside `resolveAttack` receives these values (passes undefined when not provided, using ?? 50n defaults)
    - At the enemy-attacks-character call site, stat-derived blockChanceBasis and blockMitigationPercent are computed from targetCharacter.dex/str and passed to resolveAttack
    - Block chance for DEX=14 = BLOCK_CHANCE_BASE + (14n-10n)*5n = 50n+20n = 70n (7% on 1000-scale)
    - Block mitigation for STR=14 = BLOCK_MITIGATION_BASE + (14n-10n)*2n = 30n+8n = 38n (38% absorbed)
    - WIS hook in resolve_pull shifts success% and fail% using signed wisOffset, placed BEFORE the dice roll
    - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
Run `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1`. Zero errors.

Confirm the wiring chain:
- `combat_scaling.ts` exports `statOffset`, `BLOCK_CHANCE_BASE`, `BLOCK_CHANCE_DEX_PER_POINT`, `BLOCK_MITIGATION_BASE`, `BLOCK_MITIGATION_STR_PER_POINT`, `WIS_PULL_BONUS_PER_POINT`
- `reducers/combat.ts` imports these and uses them — `blockChanceBasis`/`blockMitigationPercent` on `resolveAttack` param type, threaded through to `rollAttackOutcome`, computed at relevant combat loop call site
- `helpers/combat.ts` rollAttackOutcome accepts `blockChanceBasis` and `blockMitigationPercent` with backward-compatible defaults
- WIS hook in resolve_pull: `grep -n -A 5 "wisOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — wisOffset lines appear before the dice roll
</verification>

<success_criteria>
- Block chance on 1000-scale = `clamp(50 + (DEX - 10) * 5, 10, 200)` — tunable via BLOCK_CHANCE_DEX_PER_POINT constant
- Block mitigation on 100n-scale = `clamp(30 + (STR - 10) * 2, 10, 80)` — tunable via BLOCK_MITIGATION_STR_PER_POINT constant
- Block only fires when `canBlock: true` (i.e., shield equipped in offHand — existing `hasShieldEquipped` check, unchanged)
- WIS hook adjusts pull success%/fail% using ±2 percentage points per WIS point above/below 10, before the dice roll
- All existing callers of `resolveAttack` without block params continue to use 5% chance / 50% mitigation defaults (undefined → ?? 50n in rollAttackOutcome)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-02-SUMMARY.md`
</output>
