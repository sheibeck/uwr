---
phase: 21.1-stat-systems-off-stat-hooks
plan: "02"
type: execute
wave: 2
depends_on:
  - "21.1-01"
files_modified:
  - spacetimedb/src/helpers/combat.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true
requirements:
  - STAT-03
  - STAT-04

must_haves:
  truths:
    - "Block chance scales with DEX: a warrior with DEX=14 blocks more often than one with DEX=6"
    - "Block mitigation scales with STR: a warrior with STR=14 absorbs more damage on block than one with STR=6"
    - "Block only triggers when a shield is equipped in the off-hand slot"
    - "WIS reduces the probability of a bad pull outcome: higher WIS shifts success% up and fail% down"
    - "WIS hook applies the same success/fail adjustment pattern as the existing pull_veil effect"
  artifacts:
    - path: "spacetimedb/src/helpers/combat.ts"
      provides: "Parameterized blockChanceBasis and blockMitigationPercent in rollAttackOutcome"
      contains: "blockChanceBasis"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "DEX/STR block values computed at call site; WIS hook in resolve_pull"
      contains: "statOffset"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/combat.ts"
      via: "rollAttackOutcome call with blockChanceBasis and blockMitigationPercent"
      pattern: "blockChanceBasis.*blockMitigationPercent|blockMitigationPercent.*blockChanceBasis"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/data/combat_scaling.ts"
      via: "statOffset import for block and WIS"
      pattern: "statOffset.*BLOCK|WIS_PULL"
---

<objective>
Wire DEX/STR block system and WIS pull hook into the combat reducers, using the statOffset() helper established in Plan 01.

Purpose: The block system currently uses hardcoded 5% chance and 50% mitigation. This plan makes both values stat-derived (DEX for chance, STR for mitigation) and adds the WIS hook to pull probability. All changes are server-side only; no schema changes needed.

Output: `rollAttackOutcome` accepts optional `blockChanceBasis` and `blockMitigationPercent` params (backward-compatible defaults). Combat loop computes DEX/STR values and passes them. `resolve_pull` adjusts success/fail% based on WIS offset.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-CONTEXT.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-RESEARCH.md
@.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-01-SUMMARY.md
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/data/combat_scaling.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize rollAttackOutcome block values in helpers/combat.ts</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
    Locate `rollAttackOutcome` in `spacetimedb/src/helpers/combat.ts` (approximately lines 143-178 per research).

    Extend the opts type to add two optional parameters with backward-compatible defaults:

    ```typescript
    // BEFORE (existing opts type, abbreviated):
    opts: {
      canBlock: boolean;
      canParry: boolean;
      canDodge: boolean;
      characterDex?: bigint;
      weaponName?: string;
      weaponType?: string;
    }

    // AFTER (add two optional fields):
    opts: {
      canBlock: boolean;
      blockChanceBasis?: bigint;        // NEW: on 1000-scale; default 50n (5%)
      blockMitigationPercent?: bigint;  // NEW: on 100n-scale; default 50n (50% mitigation)
      canParry: boolean;
      canDodge: boolean;
      characterDex?: bigint;
      weaponName?: string;
      weaponType?: string;
    }
    ```

    Update the block resolution section inside the function body. Currently it looks like:
    ```typescript
    if (opts.canBlock) { cursor += 50n; if (roll < cursor) return { outcome: 'block', multiplier: 50n }; }
    ```

    Replace with:
    ```typescript
    if (opts.canBlock) {
      const blockChance = opts.blockChanceBasis ?? 50n;          // default 5% on 1000-scale
      const blockMitigation = opts.blockMitigationPercent ?? 50n; // default 50% mitigation
      cursor += blockChance;
      if (roll < cursor) {
        // multiplier represents damage taken: 100% - mitigation%
        // e.g. 30% mitigation → multiplier 70n (player takes 70% of hit damage)
        const damageTaken = 100n - blockMitigation;
        return { outcome: 'block', multiplier: damageTaken > 0n ? damageTaken : 1n };
      }
    }
    ```

    All existing callers of `rollAttackOutcome` that do NOT pass `blockChanceBasis`/`blockMitigationPercent` continue to use the default 50n values, so backward compatibility is preserved.

    Do NOT change any other part of the function.
  </action>
  <verify>
    1. `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30` — zero errors.
    2. Grep: `grep -n "blockChanceBasis\|blockMitigationPercent" C:/projects/uwr/spacetimedb/src/helpers/combat.ts` — both fields appear in opts type and function body.
  </verify>
  <done>
    `rollAttackOutcome` opts type includes `blockChanceBasis?: bigint` and `blockMitigationPercent?: bigint`. The block resolution section uses these values with `?? 50n` fallback defaults. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire DEX/STR block values and WIS hook in reducers/combat.ts</name>
  <files>spacetimedb/src/reducers/combat.ts</files>
  <action>
    **Part A: Block system — DEX/STR values at rollAttackOutcome call site**

    In `spacetimedb/src/reducers/combat.ts`, add the necessary imports at the top of the file:
    ```typescript
    import {
      statOffset,
      BLOCK_CHANCE_BASE,
      BLOCK_CHANCE_DEX_PER_POINT,
      BLOCK_MITIGATION_BASE,
      BLOCK_MITIGATION_STR_PER_POINT,
      WIS_PULL_BONUS_PER_POINT,
    } from '../data/combat_scaling.js';
    ```
    (Use `.js` extension as is the convention in this SpacetimeDB TypeScript project — check existing imports in the file to confirm the extension pattern.)

    Locate `resolveAttack` or the combat loop where `rollAttackOutcome` is called with `canBlock`. The character's DEX and STR stats are available at this point (either via the `character` row or passed in as parameters). Immediately before the `rollAttackOutcome` call, compute:

    ```typescript
    // Compute stat-derived block values for this defender
    const blockChanceBasis: bigint = (() => {
      const offset = statOffset(defenderDex, BLOCK_CHANCE_DEX_PER_POINT); // signed bigint
      const raw = BLOCK_CHANCE_BASE + offset;
      // Clamp to [10n, 200n] on 1000-scale (1% min, 20% max)
      if (raw < 10n) return 10n;
      if (raw > 200n) return 200n;
      return raw;
    })();

    const blockMitigationPercent: bigint = (() => {
      const offset = statOffset(defenderStr, BLOCK_MITIGATION_STR_PER_POINT); // signed bigint
      const raw = BLOCK_MITIGATION_BASE + offset;
      // Clamp to [10n, 80n] on 100n-scale (10% min, 80% max)
      if (raw < 10n) return 10n;
      if (raw > 80n) return 80n;
      return raw;
    })();
    ```

    Then pass these to `rollAttackOutcome`:
    ```typescript
    const attackResult = rollAttackOutcome(seed, {
      canBlock,
      blockChanceBasis,       // NEW
      blockMitigationPercent, // NEW
      canParry,
      canDodge,
      characterDex: defenderDex,
      weaponName,
      weaponType,
    });
    ```

    IMPORTANT: Read the actual current call signature before modifying. The variable names (`defenderDex`, `defenderStr`, etc.) must match what is actually in scope at the call site. If the character object is `defender` or `targetChar`, use `defender.dex`, `defender.str` etc. Do not invent variable names — read the actual code first.

    **Part B: WIS hook in resolve_pull**

    Locate `resolve_pull` reducer in the same file (approximately lines 841-986 per research). Find the section after the `pull_veil` and `awarenessAlert` adjustments. The research shows the injection point:

    ```typescript
    // After awarenessAlert block ends — insert WIS hook here:
    // WIS off-stat hook: WIS shifts pull success% up and fail% down (same pattern as pull_veil)
    const wisOffset = Number(statOffset(character.wis, WIS_PULL_BONUS_PER_POINT));
    if (wisOffset !== 0) {
      success = Math.min(95, Math.max(5, success + wisOffset));
      fail    = Math.max(5, Math.min(95, fail - wisOffset));
      // partial is the remainder (100 - success - fail), not adjusted directly
    }
    ```

    The WIS hook must be placed AFTER both the `pull_veil` effect and `awarenessAlert` adjustments, and BEFORE the final dice roll. The `character` variable (the pulling character) must already be in scope at this point — verify before adding code.

    Ensure the `statOffset` and `WIS_PULL_BONUS_PER_POINT` import is added (see Part A imports above).
  </action>
  <verify>
    1. `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1 | head -30` — zero errors.
    2. Grep: `grep -n "blockChanceBasis\|blockMitigationPercent" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — two occurrences (compute + pass to rollAttackOutcome).
    3. Grep: `grep -n "WIS_PULL_BONUS_PER_POINT\|wisOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — WIS hook present in resolve_pull.
    4. Grep: `grep -n "statOffset" C:/projects/uwr/spacetimedb/src/reducers/combat.ts` — imported and used.
  </verify>
  <done>
    - `rollAttackOutcome` is called with stat-derived `blockChanceBasis` and `blockMitigationPercent` at the combat loop call site
    - Block chance for DEX=14 warrior = BLOCK_CHANCE_BASE + (14n-10n)*5n = 50n+20n = 70n (7% on 1000-scale)
    - Block mitigation for STR=14 = BLOCK_MITIGATION_BASE + (14n-10n)*2n = 30n+8n = 38n (38% absorbed)
    - WIS hook in resolve_pull shifts success% and fail% using signed wisOffset
    - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
Run `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit 2>&1`. Zero errors.

Confirm the wiring chain:
- `combat_scaling.ts` exports `statOffset`, `BLOCK_CHANCE_BASE`, `BLOCK_CHANCE_DEX_PER_POINT`, `BLOCK_MITIGATION_BASE`, `BLOCK_MITIGATION_STR_PER_POINT`, `WIS_PULL_BONUS_PER_POINT`
- `reducers/combat.ts` imports these and uses them at the rollAttackOutcome call site and in resolve_pull
- `helpers/combat.ts` rollAttackOutcome accepts `blockChanceBasis` and `blockMitigationPercent` with backward-compatible defaults
</verification>

<success_criteria>
- Block chance on 1000-scale = `clamp(50 + (DEX - 10) * 5, 10, 200)` — tunable via BLOCK_CHANCE_DEX_PER_POINT constant
- Block mitigation on 100n-scale = `clamp(30 + (STR - 10) * 2, 10, 80)` — tunable via BLOCK_MITIGATION_STR_PER_POINT constant
- Block only fires when `canBlock: true` (i.e., shield equipped in offHand — existing `hasShieldEquipped` check, unchanged)
- WIS hook adjusts pull success%/fail% using ±2 percentage points per WIS point above/below 10
- All existing callers of `rollAttackOutcome` without block params continue to use 5% chance / 50% mitigation defaults
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/21.1-stat-systems-off-stat-hooks/21.1-02-SUMMARY.md`
</output>
