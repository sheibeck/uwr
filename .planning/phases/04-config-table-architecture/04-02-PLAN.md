---
phase: 04-config-table-architecture
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - spacetimedb/src/index.ts
  - spacetimedb/src/data/combat_scaling.ts
autonomous: true
must_haves:
  truths:
    - "executeAbility and all helper functions read ability metadata from database (ctx.db.abilityTemplate) instead of ABILITIES constant"
    - "getAbilityStatScaling reads statScaling from database row instead of ABILITY_STAT_SCALING constant"
    - "legacyDescriptions block removed from ensureAbilityTemplates"
    - "ABILITY_STAT_SCALING constant removed from combat_scaling.ts"
    - "All combat flows work identically reading from database vs constants"
    - "Client bindings regenerated to expose new AbilityTemplate columns"
  artifacts:
    - path: "spacetimedb/src/index.ts"
      provides: "Database-driven ability execution"
      contains: "ctx.db.abilityTemplate.by_key"
    - path: "spacetimedb/src/data/combat_scaling.ts"
      provides: "Combat scaling without ABILITY_STAT_SCALING constant"
    - path: "src/module_bindings/"
      provides: "Regenerated client bindings with new AbilityTemplate columns"
  key_links:
    - from: "spacetimedb/src/index.ts (executeAbility)"
      to: "spacetimedb/src/index.ts (AbilityTemplate table)"
      via: "ctx.db.abilityTemplate.by_key lookup"
      pattern: "ctx\\.db\\.abilityTemplate\\.by_key"
    - from: "spacetimedb/src/index.ts (abilityCooldownMicros)"
      to: "spacetimedb/src/index.ts (AbilityTemplate table)"
      via: "ctx parameter for db access"
      pattern: "ctx\\.db\\.abilityTemplate"
---

<objective>
Migrate all ability metadata consumers from hardcoded constants (ABILITIES, ABILITY_STAT_SCALING, legacyDescriptions) to reading from the AbilityTemplate database table. Remove the eliminated constants. Regenerate client bindings and publish the module.

Purpose: Complete the single-source-of-truth migration. After this plan, all ability metadata lives in the database and the 3-file fragmentation is eliminated.

Output: Database-driven ability execution, removed constants, regenerated client bindings, published module.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-config-table-architecture/04-RESEARCH.md
@.planning/phases/04-config-table-architecture/04-01-SUMMARY.md
@spacetimedb/src/index.ts
@spacetimedb/src/data/ability_catalog.ts
@spacetimedb/src/data/combat_scaling.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate ability consumers from ABILITIES constant to database lookups</name>
  <files>spacetimedb/src/index.ts, spacetimedb/src/data/combat_scaling.ts</files>
  <action>
Systematically replace every `ABILITIES[abilityKey ...]` lookup in index.ts with `ctx.db.abilityTemplate.by_key.find(abilityKey)` database lookups. There are ~6 call sites to migrate.

**CRITICAL: by_key is a btree index, not a unique constraint. Use `.filter()` not `.find()`.** Since by_key is a btree index on a non-unique column, access pattern is:
```typescript
const rows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
const abilityRow = rows[0];
```
Or if ensureAbilityTemplates guarantees uniqueness (it deduplicates), this will always return 0 or 1 rows, so `rows[0]` is safe.

**Migration targets (grep for `ABILITIES[` in index.ts):**

1. **`abilityCooldownMicros` (line ~1698)**: Currently reads `ABILITIES[abilityKey]`. This function takes only `abilityKey` as param — it needs `ctx` added to read from DB. Change signature to `abilityCooldownMicros(ctx: any, abilityKey: string)` and update all callers to pass `ctx`.

2. **`abilityCastMicros` (line ~1705)**: Same as above — add `ctx` param, read from DB. Update all callers.

3. **`executeAbility` (line ~1894)**: Replace `ABILITIES[abilityKey as keyof typeof ABILITIES]` with DB lookup. The function already has `ctx` param. Replace with:
   ```typescript
   const abilityRows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
   const ability = abilityRows[0];
   if (!ability) throw new SenderError('Unknown ability');
   ```
   Then update all field accesses: `ability.power` is now `ability.power ?? 0n`, `ability.damageType` is now `ability.damageType ?? 'none'`, etc. All new optional fields need null coalescing.

4. **Damage calculation block (line ~2069)**: Replace `ABILITIES[abilityKey as keyof typeof ABILITIES]` with the ability row already fetched in executeAbility (pass it down or use the same variable scope). Key fields:
   - `abilityEntry.power` → `ability.power ?? 0n`
   - `abilityEntry.castSeconds` → `ability.castSeconds`
   - `abilityEntry.cooldownSeconds` → `ability.cooldownSeconds`
   - `abilityEntry.dotPowerSplit` → `ability.dotPowerSplit ?? undefined`

5. **Healing block (line ~2307)**: Replace `ABILITIES[abilityKey as keyof typeof ABILITIES]` with the same ability row. Fields: `hotPowerSplit`, `hotDuration`, `name`.

6. **Any other ABILITIES references**: Search exhaustively. If any remain, migrate them the same way.

**Migrate getAbilityStatScaling in combat_scaling.ts:**

The `getAbilityStatScaling` function (line ~279 in combat_scaling.ts) currently reads from `ABILITY_STAT_SCALING[abilityKey]`. Modify it to accept an optional `statScaling` string parameter directly instead of looking up from the constant:

Change signature from:
```typescript
export function getAbilityStatScaling(characterStats, abilityKey, className): bigint
```
To:
```typescript
export function getAbilityStatScaling(characterStats, abilityKey, className, statScalingOverride?: string): bigint
```

Inside the function, use `statScalingOverride` if provided, otherwise fall back to `ABILITY_STAT_SCALING[abilityKey]` (keep fallback during transition). Then in index.ts callers, pass `ability.statScaling` from the DB row.

**Update callers of getAbilityStatScaling in index.ts:**

Find the call at line ~2070 and add the DB row's statScaling:
```typescript
const statScaling = getAbilityStatScaling(
  { str: character.str, ... },
  abilityKey,
  character.className,
  ability.statScaling ?? undefined
);
```

**IMPORTANT null-safety rules for optional DB fields:**
- `ability.power ?? 0n` (default zero power)
- `ability.damageType ?? 'none'` (default no damage type)
- `ability.statScaling ?? 'none'` (default no scaling)
- `ability.dotPowerSplit ?? undefined` (undefined means no DoT)
- Keep `?` optional chaining for DoT/HoT/debuff fields since they may be undefined
  </action>
  <verify>Module compiles. Grep for `ABILITIES[` in index.ts returns zero results (only import statement remains). All ability metadata reads go through ctx.db.abilityTemplate.</verify>
  <done>All 6+ ABILITIES constant lookups in index.ts replaced with ctx.db.abilityTemplate database lookups. getAbilityStatScaling accepts statScaling from DB row.</done>
</task>

<task type="auto">
  <name>Task 2: Remove eliminated constants, clean up, regenerate bindings, and publish</name>
  <files>spacetimedb/src/index.ts, spacetimedb/src/data/combat_scaling.ts</files>
  <action>
**Step 1: Remove legacyDescriptions from ensureAbilityTemplates**

In ensureAbilityTemplates (line ~4334), delete the entire `legacyDescriptions` object (lines 4334-4418) and the `resolveDescription` helper. Replace the description resolution with:
```typescript
const description = (entry as any).description ?? entry.name;
```
The descriptions are now already seeded in the DB from ABILITIES entries (which have description fields populated). The legacy fallback is no longer needed.

NOTE: Check that every ability in ABILITIES has a `description` field. If any are missing, add them from the legacyDescriptions content before removing legacyDescriptions. If all abilities have descriptions in ability_catalog.ts, safe to remove.

**Step 2: Remove ABILITY_STAT_SCALING from combat_scaling.ts**

Delete the `ABILITY_STAT_SCALING` constant (lines 130-222 in combat_scaling.ts). Update the `getAbilityStatScaling` function to REQUIRE the `statScaling` parameter (no longer optional, no fallback to deleted constant):

```typescript
export function getAbilityStatScaling(
  characterStats: { str: bigint; dex: bigint; cha: bigint; wis: bigint; int: bigint },
  abilityKey: string,
  className: string,
  statScaling: string
): bigint {
  if (!statScaling || statScaling === 'none') return 0n;
  if (statScaling === 'hybrid') {
    return (characterStats.str + characterStats.int) * 1n;
  }
  return characterStats[statScaling as keyof typeof characterStats] * ABILITY_STAT_SCALING_PER_POINT;
}
```

Remove the `ABILITY_STAT_SCALING_PER_POINT` constant ONLY if it's no longer used by anything else. If it's still used (check other callers), keep it.

**Step 3: Verify no remaining ABILITIES references in execution code**

Grep index.ts for `ABILITIES[` — should find ZERO in execution code. The only remaining references to ABILITIES should be in `ensureAbilityTemplates` (the seeding function) and the import statement. The ABILITIES constant in ability_catalog.ts is still needed for seeding — do NOT delete it.

**Step 4: Regenerate client bindings**

Run: `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb`

This regenerates client bindings to include the new AbilityTemplate columns (power, damageType, statScaling, etc.) so the client can read ability metadata from the table.

**Step 5: Publish module**

Run: `spacetime publish uwr --project-path spacetimedb`

Use the default server (should be maincloud or local, whatever is configured). If --clear-database is needed (migration fails), warn the user before proceeding — schema migration should work since all new columns are optional.
  </action>
  <verify>
1. `grep -r "ABILITY_STAT_SCALING" spacetimedb/src/data/combat_scaling.ts` returns no constant definition (only the function remains)
2. `grep "legacyDescriptions" spacetimedb/src/index.ts` returns zero results
3. Module publishes successfully
4. Client bindings include new AbilityTemplate fields (check src/module_bindings/ for power, statScaling)
  </verify>
  <done>
- legacyDescriptions block (80+ lines) removed from index.ts
- ABILITY_STAT_SCALING constant (90+ lines) removed from combat_scaling.ts
- getAbilityStatScaling reads statScaling from DB row parameter
- Client bindings regenerated with new AbilityTemplate columns
- Module published successfully
- No hardcoded ability constants remain except ABILITIES (used only for seeding) and executeAbility switch cases
  </done>
</task>

</tasks>

<verification>
1. Module compiles and publishes without errors
2. Grep for `ABILITIES[` in index.ts execution code returns zero matches (seeding-only references ok)
3. Grep for `legacyDescriptions` in index.ts returns zero matches
4. Grep for `ABILITY_STAT_SCALING` constant definition in combat_scaling.ts returns zero matches
5. Client bindings in src/module_bindings/ contain `power`, `damageType`, `statScaling` fields on AbilityTemplate type
6. All combat scenarios work identically (existing abilities function correctly)
</verification>

<success_criteria>
- Zero ABILITIES constant lookups in execution code (only in seeding function)
- legacyDescriptions removed (80+ hardcoded descriptions eliminated)
- ABILITY_STAT_SCALING constant removed (90+ ability-to-stat mappings eliminated)
- Client can read ability power/cooldown/description/statScaling from AbilityTemplate table
- Module published and functional on server
</success_criteria>

<output>
After completion, create `.planning/phases/04-config-table-architecture/04-02-SUMMARY.md`
</output>
