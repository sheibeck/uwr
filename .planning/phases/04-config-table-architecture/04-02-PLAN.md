---
phase: 04-config-table-architecture
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - spacetimedb/src/index.ts
  - spacetimedb/src/data/combat_scaling.ts
autonomous: false
must_haves:
  truths:
    - "abilityCooldownMicros and abilityCastMicros read cooldown/cast from ctx.db.abilityTemplate.by_key.filter() instead of ABILITIES constant"
    - "executeAbility fetches ability row from ctx.db.abilityTemplate.by_key.filter() and uses it for all metadata (power, damageType, DoT/HoT/debuff fields)"
    - "getAbilityStatScaling reads statScaling from DB row parameter instead of ABILITY_STAT_SCALING constant"
    - "legacyDescriptions block removed from ensureAbilityTemplates"
    - "ABILITY_STAT_SCALING constant removed from combat_scaling.ts"
    - "All 5 ABILITIES[ call sites in index.ts migrated to DB lookups (lines ~1698, ~1705, ~1894, ~2069, ~2307); ENEMY_ABILITIES[ references are out of scope"
    - "Combat flows produce identical results: direct damage abilities deal same damage, DoT abilities tick for same amounts, HoT abilities heal same amounts, debuffs apply same magnitude/duration"
    - "Client bindings regenerated to expose new AbilityTemplate columns"
  artifacts:
    - path: "spacetimedb/src/index.ts"
      provides: "Database-driven ability execution"
      contains: "ctx.db.abilityTemplate.by_key"
    - path: "spacetimedb/src/data/combat_scaling.ts"
      provides: "Combat scaling without ABILITY_STAT_SCALING constant"
    - path: "src/module_bindings/"
      provides: "Regenerated client bindings with new AbilityTemplate columns"
  key_links:
    - from: "spacetimedb/src/index.ts (executeAbility)"
      to: "spacetimedb/src/index.ts (AbilityTemplate table)"
      via: "ctx.db.abilityTemplate.by_key.filter() lookup"
      pattern: "ctx\\.db\\.abilityTemplate\\.by_key\\.filter"
    - from: "spacetimedb/src/index.ts (abilityCooldownMicros)"
      to: "spacetimedb/src/index.ts (AbilityTemplate table)"
      via: "ctx parameter for db access"
      pattern: "ctx\\.db\\.abilityTemplate\\.by_key\\.filter"
    - from: "spacetimedb/src/index.ts (getAbilityStatScaling caller)"
      to: "spacetimedb/src/data/combat_scaling.ts (getAbilityStatScaling)"
      via: "ability.statScaling passed from DB row"
      pattern: "ability\\.statScaling"
---

<objective>
Migrate all ability metadata consumers from hardcoded constants (ABILITIES, ABILITY_STAT_SCALING, legacyDescriptions) to reading from the AbilityTemplate database table. Remove the eliminated constants. Regenerate client bindings and publish the module.

Purpose: Complete the single-source-of-truth migration. After this plan, all ability metadata lives in the database and the 3-file fragmentation is eliminated.

Output: Database-driven ability execution, removed constants, regenerated client bindings, published module.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-config-table-architecture/04-RESEARCH.md
@.planning/phases/04-config-table-architecture/04-01-SUMMARY.md
@spacetimedb/src/index.ts
@spacetimedb/src/data/ability_catalog.ts
@spacetimedb/src/data/combat_scaling.ts
</context>

<tasks>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 0: Verify Plan 01 seeding completed successfully</name>
  <files></files>
  <action>
Present seeding verification to user and wait for approval before proceeding with migration.

What was built:
Plan 01 extended AbilityTemplate table with 11 metadata columns and updated ensureAbilityTemplates to seed them from ABILITIES constant and ABILITY_STAT_SCALING.

How to verify:
1. Check database has ability rows with populated metadata. Run: `spacetime sql uwr "SELECT key, power, damage_type, stat_scaling FROM ability_template LIMIT 10"`
2. Verify power is populated (not all NULL): at least 80% of rows should have a non-NULL power value
3. Verify damageType is populated: rows should show 'physical', 'magic', or 'none'
4. Verify statScaling is populated: rows should show 'str', 'dex', 'int', 'wis', 'cha', 'hybrid', or 'none'
5. If any of power/damageType/statScaling are all NULL, Plan 01 seeding failed — do NOT proceed. Re-run Plan 01 or debug the seeding function first.

Resume signal: Type "approved" if ability rows have power, damageType, and statScaling populated. Otherwise describe what's missing.
  </action>
  <verify>User confirms ability rows have power, damageType, and statScaling populated in database.</verify>
  <done>Seeding verified: AbilityTemplate rows have power, damageType, and statScaling populated. Safe to proceed with constant-to-DB migration.</done>
</task>

<task type="auto">
  <name>Task 1a: Migrate helper functions (abilityCooldownMicros, abilityCastMicros) to database lookups</name>
  <files>spacetimedb/src/index.ts</files>
  <action>
Migrate the two helper functions from ABILITIES constant to database lookups.

**CRITICAL: by_key is a btree index, not a unique constraint. Use `.filter()` not `.find()`.** The access pattern for ALL database lookups in this plan MUST be:
```typescript
const rows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
const abilityRow = rows[0];
```
Since ensureAbilityTemplates guarantees key uniqueness (it deduplicates), this always returns 0 or 1 rows, so `rows[0]` is safe. NEVER use `.find()` on by_key.

**Migration target 1: `abilityCooldownMicros` (line ~1697)**

Current:
```typescript
function abilityCooldownMicros(abilityKey: string) {
  const ability = ABILITIES[abilityKey as keyof typeof ABILITIES];
```

Change to:
```typescript
function abilityCooldownMicros(ctx: any, abilityKey: string) {
  const rows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
  const ability = rows[0];
```

Update ALL callers of `abilityCooldownMicros` to pass `ctx` as first argument. Search for `abilityCooldownMicros(` to find all callers.

**Migration target 2: `abilityCastMicros` (line ~1704)**

Current:
```typescript
function abilityCastMicros(abilityKey: string) {
  const ability = ABILITIES[abilityKey as keyof typeof ABILITIES];
```

Change to:
```typescript
function abilityCastMicros(ctx: any, abilityKey: string) {
  const rows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
  const ability = rows[0];
```

Update ALL callers of `abilityCastMicros` to pass `ctx` as first argument. Search for `abilityCastMicros(` to find all callers.

NOTE: `enemyAbilityCastMicros` and `enemyAbilityCooldownMicros` use ENEMY_ABILITIES — these are OUT OF SCOPE for this plan. Do NOT modify them.
  </action>
  <verify>Module compiles. `abilityCooldownMicros` and `abilityCastMicros` both have `ctx` as first parameter and use `ctx.db.abilityTemplate.by_key.filter()`. No callers still pass the old single-argument signature.</verify>
  <done>abilityCooldownMicros and abilityCastMicros migrated from ABILITIES constant to ctx.db.abilityTemplate.by_key.filter() database lookups. All callers updated to pass ctx.</done>
</task>

<task type="auto">
  <name>Task 1b: Migrate executeAbility, damage calculation, healing block, and combat_scaling to database lookups</name>
  <files>spacetimedb/src/index.ts, spacetimedb/src/data/combat_scaling.ts</files>
  <action>
Migrate the remaining 3 ABILITIES[ call sites in index.ts and update getAbilityStatScaling in combat_scaling.ts.

**REMINDER: by_key is a btree index. ALL database lookups MUST use `.filter()` pattern:**
```typescript
const rows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
const ability = rows[0];
```

**Migration target 3: `executeAbility` (line ~1894)**

Current:
```typescript
const ability = ABILITIES[abilityKey as keyof typeof ABILITIES];
if (!ability) throw new SenderError('Unknown ability');
```

Replace with:
```typescript
const abilityRows = [...ctx.db.abilityTemplate.by_key.filter(abilityKey)];
const ability = abilityRows[0];
if (!ability) throw new SenderError('Unknown ability');
```

The function already has `ctx` param — no signature change needed. Then update field accesses throughout executeAbility to use null coalescing for optional DB fields:
- `ability.power ?? 0n` (default zero power)
- `ability.damageType ?? 'none'` (default no damage type)
- `ability.dotPowerSplit ?? undefined` (undefined means no DoT)
- Keep `?.` optional chaining for DoT/HoT/debuff fields since they may be undefined

**Migration target 4: Damage calculation block (line ~2069)**

Current:
```typescript
const abilityEntry = ABILITIES[abilityKey as keyof typeof ABILITIES];
const statScaling = getAbilityStatScaling(
  { str: character.str, dex: character.dex, ... },
  abilityKey,
  character.className
);
const abilityMultiplier = abilityEntry
  ? getAbilityMultiplier(abilityEntry.castSeconds, abilityEntry.cooldownSeconds)
  : 100n;
```

Replace with (reuse the `ability` variable already fetched at the top of executeAbility — it's in the same function scope):
```typescript
// Remove the redundant ABILITIES lookup — use the `ability` row fetched earlier
const statScaling = getAbilityStatScaling(
  { str: character.str, dex: character.dex, cha: character.cha, wis: character.wis, int: character.int },
  abilityKey,
  character.className,
  ability.statScaling ?? 'none'
);
const abilityMultiplier = ability
  ? getAbilityMultiplier(ability.castSeconds, ability.cooldownSeconds)
  : 100n;
```

Also update any references to `abilityEntry.power` in the damage block to use `ability.power ?? 0n`, and `abilityEntry.dotPowerSplit` to `ability.dotPowerSplit ?? undefined`, etc.

**Migration target 5: Healing block (line ~2307)**

Current:
```typescript
const abilityEntry = ABILITIES[abilityKey as keyof typeof ABILITIES];
const directHealFraction = abilityEntry?.hotPowerSplit ? 1.0 - abilityEntry.hotPowerSplit : 1.0;
```

Replace with (reuse the `ability` variable from executeAbility scope):
```typescript
// Remove the redundant ABILITIES lookup — use the `ability` row fetched earlier
const directHealFraction = ability?.hotPowerSplit ? 1.0 - ability.hotPowerSplit : 1.0;
```

Update all subsequent `abilityEntry.` references in the healing block to `ability.` with appropriate null coalescing:
- `abilityEntry?.hotPowerSplit` → `ability?.hotPowerSplit`
- `abilityEntry?.hotDuration` → `ability?.hotDuration`
- `abilityEntry?.name` → `ability?.name`

**Exhaustive search step:** After migrating targets 3-5, run `grep "ABILITIES\[" spacetimedb/src/index.ts` and verify the results. Expected: should find ONLY references in `ensureAbilityTemplates` (the seeding function) and possibly the import statement. There should be 5 ABILITIES[ references total to migrate (lines ~1698, ~1705, ~1894, ~2069, ~2307). There are also 3 ENEMY_ABILITIES[ references (lines ~1711, ~1717, ~3183) — these are OUT OF SCOPE. If any additional ABILITIES[ references exist beyond these 8 total, migrate them using the same .filter() pattern.

**Migrate getAbilityStatScaling in combat_scaling.ts:**

The `getAbilityStatScaling` function (line ~279 in combat_scaling.ts) currently reads from `ABILITY_STAT_SCALING[abilityKey]`. Modify it to accept an optional `statScaling` string parameter directly:

Change signature from:
```typescript
export function getAbilityStatScaling(characterStats, abilityKey, className): bigint
```
To:
```typescript
export function getAbilityStatScaling(characterStats, abilityKey, className, statScalingOverride?: string): bigint
```

Inside the function, use `statScalingOverride` if provided, otherwise fall back to `ABILITY_STAT_SCALING[abilityKey]` (keep fallback during transition — Task 2 removes the constant entirely).

**IMPORTANT null-safety rules for optional DB fields:**
- `ability.power ?? 0n` (default zero power)
- `ability.damageType ?? 'none'` (default no damage type)
- `ability.statScaling ?? 'none'` (default no scaling)
- `ability.dotPowerSplit ?? undefined` (undefined means no DoT)
- Keep `?.` optional chaining for DoT/HoT/debuff fields since they may be undefined
  </action>
  <verify>
1. Module compiles without errors
2. `grep "ABILITIES\[" spacetimedb/src/index.ts` returns ZERO matches in execution code (only matches in ensureAbilityTemplates seeding function and import)
3. Verify exactly 5 ABILITIES[ references were migrated and 3 ENEMY_ABILITIES[ references remain untouched
4. getAbilityStatScaling in combat_scaling.ts accepts statScalingOverride parameter
5. All callers of getAbilityStatScaling pass ability.statScaling from DB row
  </verify>
  <done>All 5 ABILITIES[ constant lookups in index.ts execution code replaced with ctx.db.abilityTemplate.by_key.filter() database lookups. Damage calculation, healing, and stat scaling all read from DB row. getAbilityStatScaling accepts statScaling from DB row.</done>
</task>

<task type="auto">
  <name>Task 2: Remove eliminated constants, clean up, regenerate bindings, and publish</name>
  <files>spacetimedb/src/index.ts, spacetimedb/src/data/combat_scaling.ts</files>
  <action>
**Step 1: Remove legacyDescriptions from ensureAbilityTemplates**

In ensureAbilityTemplates (line ~4334), delete the entire `legacyDescriptions` object (lines 4334-4418) and the `resolveDescription` helper. Replace the description resolution with:
```typescript
const description = (entry as any).description ?? entry.name;
```
The descriptions are now already seeded in the DB from ABILITIES entries (which have description fields populated). The legacy fallback is no longer needed.

NOTE: Check that every ability in ABILITIES has a `description` field. If any are missing, add them from the legacyDescriptions content before removing legacyDescriptions. If all abilities have descriptions in ability_catalog.ts, safe to remove.

**Step 2: Remove ABILITY_STAT_SCALING from combat_scaling.ts**

Delete the `ABILITY_STAT_SCALING` constant (lines 130-222 in combat_scaling.ts). Update the `getAbilityStatScaling` function to REQUIRE the `statScaling` parameter (no longer optional, no fallback to deleted constant):

```typescript
export function getAbilityStatScaling(
  characterStats: { str: bigint; dex: bigint; cha: bigint; wis: bigint; int: bigint },
  abilityKey: string,
  className: string,
  statScaling: string
): bigint {
  if (!statScaling || statScaling === 'none') return 0n;
  if (statScaling === 'hybrid') {
    return (characterStats.str + characterStats.int) * 1n;
  }
  return characterStats[statScaling as keyof typeof characterStats] * ABILITY_STAT_SCALING_PER_POINT;
}
```

Remove the `ABILITY_STAT_SCALING_PER_POINT` constant ONLY if it's no longer used by anything else. If it's still used (check other callers), keep it.

**Step 3: Verify no remaining ABILITIES references in execution code**

Grep index.ts for `ABILITIES[` — should find ZERO in execution code. The only remaining references to ABILITIES should be in `ensureAbilityTemplates` (the seeding function) and the import statement. The ABILITIES constant in ability_catalog.ts is still needed for seeding — do NOT delete it.

**Step 4: Regenerate client bindings**

Run: `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb`

This regenerates client bindings to include the new AbilityTemplate columns (power, damageType, statScaling, etc.) so the client can read ability metadata from the table.

**Step 5: Publish module**

Run: `spacetime publish uwr --project-path spacetimedb`

Use the default server (should be maincloud or local, whatever is configured). If --clear-database is needed (migration fails), warn the user before proceeding — schema migration should work since all new columns are optional.
  </action>
  <verify>
1. `grep -r "ABILITY_STAT_SCALING" spacetimedb/src/data/combat_scaling.ts` returns no constant definition (only the function remains)
2. `grep "legacyDescriptions" spacetimedb/src/index.ts` returns zero results
3. Module publishes successfully
4. Client bindings include new AbilityTemplate fields (check src/module_bindings/ for power, statScaling)
  </verify>
  <done>
- legacyDescriptions block (80+ lines) removed from index.ts
- ABILITY_STAT_SCALING constant (90+ lines) removed from combat_scaling.ts
- getAbilityStatScaling reads statScaling from DB row parameter (required, no fallback)
- Client bindings regenerated with new AbilityTemplate columns
- Module published successfully
- No hardcoded ability constants remain except ABILITIES (used only for seeding) and executeAbility switch cases
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify combat flows work identically with database-driven abilities</name>
  <files></files>
  <action>
Present combat verification scenarios to user and wait for approval.

What was built:
All ability metadata consumers migrated from ABILITIES/ABILITY_STAT_SCALING constants to AbilityTemplate database lookups. Constants removed. Module published.

How to verify (test at least 3 combat scenarios):

1. **Direct damage ability:** Use a physical damage ability (e.g., warrior Strike or similar). Verify damage numbers in combat log are reasonable (not 0, not NaN, not dramatically different from before).

2. **DoT ability:** Use an ability with a damage-over-time component (e.g., a bleed or poison). Verify the initial hit lands AND the DoT ticks appear in the combat log with expected values.

3. **Healing ability:** Use a healing ability (e.g., cleric heal). Verify the heal amount is reasonable. If the ability has a HoT component, verify HoT ticks appear.

4. **Check for errors:** Open browser console and check for any "Unknown ability" errors or SpacetimeDB reducer errors during combat.

5. **Debuff ability (if easily testable):** Use an ability that applies a debuff. Verify the debuff appears in the target's status.

If any ability produces 0 damage, NaN values, or "Unknown ability" errors, the migration has a bug.

Resume signal: Type "approved" if combat flows work correctly. Otherwise describe which ability/scenario fails and what the incorrect behavior is.
  </action>
  <verify>User confirms direct damage, DoT, and healing abilities produce correct values in combat.</verify>
  <done>Combat flows verified working identically with database-driven abilities. Direct damage, DoT, and healing all produce correct values.</done>
</task>

</tasks>

<verification>
1. Module compiles and publishes without errors
2. Grep for `ABILITIES[` in index.ts execution code returns zero matches (seeding-only references ok)
3. Grep for `legacyDescriptions` in index.ts returns zero matches
4. Grep for `ABILITY_STAT_SCALING` constant definition in combat_scaling.ts returns zero matches
5. Client bindings in src/module_bindings/ contain `power`, `damageType`, `statScaling` fields on AbilityTemplate type
6. Human-verified: direct damage, DoT, and healing abilities produce correct values in combat
</verification>

<success_criteria>
- Zero ABILITIES constant lookups in execution code (only in seeding function)
- legacyDescriptions removed (80+ hardcoded descriptions eliminated)
- ABILITY_STAT_SCALING constant removed (90+ ability-to-stat mappings eliminated)
- Client can read ability power/cooldown/description/statScaling from AbilityTemplate table
- Module published and functional on server
- Combat flows verified: damage, DoT, healing all produce correct values
</success_criteria>

<output>
After completion, create `.planning/phases/04-config-table-architecture/04-02-SUMMARY.md`
</output>
