---
phase: 11-death-corpse-system
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - src/components/LocationGrid.vue
  - src/composables/useGameData.ts
  - src/App.vue
  - src/ui/styles.ts
autonomous: false

must_haves:
  truths:
    - "Corpses appear in Points of Interest section in LocationGrid"
    - "Only corpses belonging to online players are visible"
    - "Right-click context menu on own corpse shows Loot Corpse and Loot All options"
    - "Other players' corpses show name but no loot option"
    - "Resurrection confirmation prompt appears when cleric initiates resurrect"
    - "Corpse Summon confirmation prompt appears when cleric initiates summon"
    - "Accepting/declining confirmation works and shows appropriate feedback"
    - "Corpse disappears from UI immediately after fully looting"
  artifacts:
    - path: "src/components/LocationGrid.vue"
      provides: "Points of Interest section with corpse rendering and context menu"
    - path: "src/composables/useGameData.ts"
      provides: "Subscriptions to Corpse, CorpseItem, PendingResurrect, PendingCorpseSummon tables"
    - path: "src/App.vue"
      provides: "Corpse data wiring, confirmation dialog, reducer calls"
  key_links:
    - from: "src/components/LocationGrid.vue"
      to: "src/App.vue"
      via: "corpse loot/resurrect/summon emit events"
      pattern: "emit.*loot-corpse|emit.*accept-resurrect"
    - from: "src/App.vue"
      to: "src/module_bindings"
      via: "reducer calls for corpse operations"
      pattern: "conn\\.reducers\\.lootCorpseItem|conn\\.reducers\\.lootAllCorpse"
    - from: "src/composables/useGameData.ts"
      to: "src/module_bindings"
      via: "useTable subscriptions for corpse tables"
      pattern: "useTable\\(tables\\.corpse"
---

<objective>
Frontend UI for the death and corpse system: corpse visibility in the location panel, context menu for looting, and confirmation dialogs for resurrection and corpse summon.

Purpose: Provides the player-facing interface for interacting with corpses, accepting resurrections, and managing corpse summons.
Output: Players see corpses in the "Points of Interest" section, can right-click to loot their own corpses, and receive confirmation prompts for resurrect/summon actions.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-CONTEXT.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-01-SUMMARY.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-02-SUMMARY.md
@src/components/LocationGrid.vue
@src/composables/useGameData.ts
@src/App.vue
@src/ui/styles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Corpse subscriptions and Points of Interest section in LocationGrid</name>
  <files>
    src/composables/useGameData.ts
    src/components/LocationGrid.vue
    src/ui/styles.ts
  </files>
  <action>
  **In `src/composables/useGameData.ts`:**

  Add subscriptions to the new tables (following the existing pattern of public tables with client-side filtering):
  - `const [corpses, corpsesLoading] = useTable(tables.corpse)`
  - `const [corpseItems, corpseItemsLoading] = useTable(tables.corpseItem)`
  - `const [pendingResurrects, pendingResurrectsLoading] = useTable(tables.pendingResurrect)`
  - `const [pendingCorpseSummons, pendingCorpseSummonsLoading] = useTable(tables.pendingCorpseSummon)`
  - Add all four to the returned object from useGameData

  Also add these tables to the SQL subscription query string so they are included in the subscription builder. Look for the existing subscription builder pattern (subscriptionBuilder().subscribe([...])) and add:
  - 'SELECT * FROM corpse'
  - 'SELECT * FROM corpse_item'
  - 'SELECT * FROM pending_resurrect'
  - 'SELECT * FROM pending_corpse_summon'

  **In `src/components/LocationGrid.vue`:**

  Add a new prop `corpsesHere` to the component props:
  ```typescript
  corpsesHere: {
    id: bigint;
    characterName: string;
    characterId: bigint;
    isOwn: boolean;
    itemCount: number;
  }[];
  ```

  Add a new section AFTER NPCS and BEFORE the ContextMenu, labeled "POINTS OF INTEREST":
  ```html
  <!-- Points of Interest (Corpses) -->
  <div v-if="corpsesHere.length > 0">
    <div :style="styles.gridSectionLabel">POINTS OF INTEREST</div>
    <div :style="styles.gridWrap">
      <div
        v-for="corpse in corpsesHere"
        :key="corpse.id.toString()"
        :style="styles.gridTileCorpse"
        @contextmenu.prevent="openCorpseContextMenu($event, corpse)"
      >
        <span>{{ corpse.characterName }}'s corpse</span>
        <span v-if="corpse.isOwn && corpse.itemCount > 0"
          :style="{ fontSize: '0.75rem', opacity: 0.6, marginLeft: '0.3rem' }">
          ({{ corpse.itemCount }} items)
        </span>
      </div>
    </div>
  </div>
  ```

  Add context menu handler `openCorpseContextMenu(event, corpse)`:
  - If corpse.isOwn and corpse.itemCount > 0:
    - Show context menu with title "[characterName]'s corpse", items:
      - "Loot All" -> emit('loot-all-corpse', corpse.id)
      - "Loot Item" -> emit('loot-corpse-item', corpse.id) (for future item-by-item, or just use Loot All for now)
  - If not own: show context menu with title "[characterName]'s corpse", items: (empty or just "Examine" with no action)

  Add emit declarations:
  ```typescript
  const emit = defineEmits<{
    // ... existing emits ...
    (e: 'loot-all-corpse', corpseId: bigint): void;
  }>();
  ```

  Also update the empty state check at the top to include corpses:
  ```
  v-if="enemySpawns.length === 0 && resourceNodes.length === 0 && npcsHere.length === 0 && corpsesHere.length === 0"
  ```

  **In `src/ui/styles.ts`:**

  Add `gridTileCorpse` style object (similar to gridTile but with a slightly different color to distinguish):
  ```typescript
  gridTileCorpse: {
    ...gridTile base styles...,
    borderColor: 'rgba(180, 140, 100, 0.3)',  // Brownish tint for corpses
    background: 'rgba(80, 60, 40, 0.15)',
  },
  ```
  </action>
  <verify>
  `npx tsc --noEmit` passes at project root.
  LocationGrid has Points of Interest section with corpse tiles.
  Context menu shows Loot All for own corpses.
  useGameData returns corpse/corpseItem subscriptions.
  </verify>
  <done>
  Corpse subscriptions active. LocationGrid displays corpses in Points of Interest section with owner name and item count. Right-click context menu on own corpses offers Loot All. Other players' corpses visible but not lootable.
  </done>
</task>

<task type="auto">
  <name>Task 2: App.vue wiring, confirmation dialogs, reducer calls</name>
  <files>
    src/App.vue
  </files>
  <action>
  **In `src/App.vue`:**

  1. **Import and use corpse data from useGameData:**
     - Destructure `corpses, corpseItems, pendingResurrects, pendingCorpseSummons` from useGameData
     - Import CorpseRow, CorpseItemRow, PendingResurrectRow, PendingCorpseSummonRow types from module_bindings

  2. **Compute corpsesHere for LocationGrid:**
     Create a computed property:
     ```typescript
     const corpsesHere = computed(() => {
       if (!selectedCharacter.value || !corpses.value) return [];
       const locationId = selectedCharacter.value.locationId;

       // Get all active player user IDs (online check)
       const activePlayerUserIds = new Set<bigint>();
       for (const player of players.value ?? []) {
         if (player.activeCharacterId) {
           const char = characters.value?.find(c => c.id === player.activeCharacterId);
           if (char) activePlayerUserIds.add(char.ownerUserId);
         }
       }

       return corpses.value
         .filter(c => c.locationId === locationId)
         .filter(c => {
           // Only show corpses for online players
           const corpseChar = characters.value?.find(ch => ch.id === c.characterId);
           return corpseChar && activePlayerUserIds.has(corpseChar.ownerUserId);
         })
         .map(c => {
           const corpseChar = characters.value?.find(ch => ch.id === c.characterId);
           const itemCount = (corpseItems.value ?? []).filter(ci => ci.corpseId === c.id).length;
           return {
             id: c.id,
             characterName: corpseChar?.name ?? 'Unknown',
             characterId: c.characterId,
             isOwn: c.characterId === selectedCharacter.value!.id,
             itemCount,
           };
         });
     });
     ```

  3. **Pass corpsesHere to LocationGrid component:**
     Find the LocationGrid component in the template and add `:corpses-here="corpsesHere"` prop.
     Add `@loot-all-corpse="onLootAllCorpse"` event handler.

  4. **Implement loot handlers:**
     ```typescript
     const onLootAllCorpse = (corpseId: bigint) => {
       if (!conn.isActive || !selectedCharacter.value) return;
       conn.reducers.lootAllCorpse({ characterId: selectedCharacter.value.id, corpseId });
     };
     ```

  5. **Confirmation dialog for resurrection/corpse summon:**
     Add a reactive ref for pending prompts:
     ```typescript
     const pendingPrompt = ref<{
       type: 'resurrect' | 'corpse_summon';
       pendingId: bigint;
       casterName: string;
       message: string;
     } | null>(null);
     ```

     Watch pendingResurrects and pendingCorpseSummons for entries targeting the selected character:
     ```typescript
     watch([pendingResurrects, pendingCorpseSummons, selectedCharacter], () => {
       if (!selectedCharacter.value) { pendingPrompt.value = null; return; }
       const charId = selectedCharacter.value.id;

       // Check for pending resurrect
       const rez = (pendingResurrects.value ?? []).find(p => p.targetCharacterId === charId);
       if (rez) {
         const caster = characters.value?.find(c => c.id === rez.casterCharacterId);
         pendingPrompt.value = {
           type: 'resurrect',
           pendingId: rez.id,
           casterName: caster?.name ?? 'A cleric',
           message: `${caster?.name ?? 'A cleric'} wants to resurrect you. Accept?`,
         };
         return;
       }

       // Check for pending corpse summon
       const summon = (pendingCorpseSummons.value ?? []).find(p => p.targetCharacterId === charId);
       if (summon) {
         const caster = characters.value?.find(c => c.id === summon.casterCharacterId);
         pendingPrompt.value = {
           type: 'corpse_summon',
           pendingId: summon.id,
           casterName: caster?.name ?? 'Someone',
           message: `${caster?.name ?? 'Someone'} wants to summon your corpses to their location. Accept?`,
         };
         return;
       }

       pendingPrompt.value = null;
     }, { deep: true });
     ```

  6. **Render confirmation dialog in template:**
     Add a confirmation overlay (similar to the cross-region travel confirmation dialog pattern from Phase 10):
     ```html
     <!-- Corpse Action Confirmation -->
     <div v-if="pendingPrompt" :style="styles.confirmOverlay">
       <div :style="styles.confirmDialog">
         <div :style="styles.confirmTitle">{{ pendingPrompt.type === 'resurrect' ? 'Resurrect' : 'Corpse Summon' }}</div>
         <div :style="styles.confirmMessage">{{ pendingPrompt.message }}</div>
         <div :style="styles.confirmButtons">
           <button @click="acceptPendingAction" :style="styles.confirmAcceptBtn">Accept</button>
           <button @click="declinePendingAction" :style="styles.confirmDeclineBtn">Decline</button>
         </div>
       </div>
     </div>
     ```

  7. **Implement accept/decline handlers:**
     ```typescript
     const acceptPendingAction = () => {
       if (!conn.isActive || !selectedCharacter.value || !pendingPrompt.value) return;
       const charId = selectedCharacter.value.id;
       const pendingId = pendingPrompt.value.pendingId;
       if (pendingPrompt.value.type === 'resurrect') {
         conn.reducers.acceptResurrect({ characterId: charId, pendingId });
       } else {
         conn.reducers.acceptCorpseSummon({ characterId: charId, pendingId });
       }
       pendingPrompt.value = null;
     };

     const declinePendingAction = () => {
       if (!conn.isActive || !selectedCharacter.value || !pendingPrompt.value) return;
       const charId = selectedCharacter.value.id;
       const pendingId = pendingPrompt.value.pendingId;
       if (pendingPrompt.value.type === 'resurrect') {
         conn.reducers.declineResurrect({ characterId: charId, pendingId });
       } else {
         conn.reducers.declineCorpseSummon({ characterId: charId, pendingId });
       }
       pendingPrompt.value = null;
     };
     ```

  8. **Check the confirm dialog styles:**
     Look for existing `confirmOverlay`, `confirmDialog`, `confirmTitle`, etc. styles in styles.ts from the cross-region travel confirmation (Phase 10 / quick-84). Reuse those same styles. If they don't exist, create them in styles.ts.

  Note: The initiate_resurrect and initiate_corpse_summon calls come from the caster's UI. For the caster side:
  - Resurrect: Caster right-clicks a corpse in Points of Interest -> "Resurrect" option (only if caster is cleric level 6+)
  - Corpse Summon: Caster right-clicks a player in the PLAYERS section -> "Summon Corpses" option (only if caster is cleric level 7+ and target has corpses)

  Add these context menu options:
  - In LocationGrid, update openCorpseContextMenu to add "Resurrect" option when the viewer is a cleric level 6+ and the corpse belongs to someone else:
    emit('initiate-resurrect', corpse.id)
  - Add event handler in App.vue: `onInitiateResurrect(corpseId)` -> `conn.reducers.initiateResurrect({ casterCharacterId: selectedCharacter.value.id, corpseId })`

  For Corpse Summon (targeting a character):
  - This is a more advanced feature. For now, implement it as a context menu option on player tiles in LocationGrid. Add a "Summon Corpses" option when viewer is cleric level 7+ and the target character has corpses (check corpses list). OR, simpler: add it as an ability the cleric can use from the hotbar targeting another player. Since hotbar targeting other players is complex, use the player context menu approach.
  - Add handleCharacterClick context menu "Summon Corpses" option for cleric level 7+ viewing another player who has corpses
  - emit('initiate-corpse-summon', targetCharacterId)
  - App.vue handler: `conn.reducers.initiateCorpseSummon({ casterCharacterId: selectedCharacter.value.id, targetCharacterId })`
  </action>
  <verify>
  `npx tsc --noEmit` passes.
  Corpses render in Points of Interest section of location panel.
  Right-click on own corpse shows "Loot All".
  Right-click on other's corpse shows "Resurrect" if viewer is cleric 6+.
  Confirmation dialog appears for pending resurrect/summon.
  Accept/Decline buttons work.
  </verify>
  <done>
  Frontend fully wired: corpse subscriptions, Points of Interest display with online-player filtering, loot context menu, resurrect context menu for clerics, confirmation dialogs for resurrect/summon, and all reducer calls connected.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end Death and Corpse System verification</name>
  <action>
  Complete Death and Corpse System built across all 3 plans: corpse creation on death for level 5+ characters, inventory items drop to corpse, equipped items and gold stay, corpse looting via context menu, Points of Interest section in location panel, cleric Resurrect ability (level 6), Corpse Summon ability (level 7), confirmation prompts for both, 30-day corpse decay, multiple corpse support with same-location combining.

  Verification steps:
  1. Create a level 5+ character (or use existing one)
  2. Ensure character has some inventory items (buy from vendor or craft)
  3. Enter combat and intentionally die (fight a high-level enemy)
  4. Verify: Character respawns at bind point with message about corpse location
  5. Verify: Equipped items still on character, inventory items gone
  6. Travel to death location
  7. Verify: Corpse appears in "Points of Interest" section as "[Name]'s corpse (N items)"
  8. Right-click corpse -> "Loot All" -> verify items return to inventory
  9. Verify: Corpse disappears after looting
  10. Test with level 1-4 character: die and verify NO corpse created
  11. If you have a cleric level 6+: test Resurrect by right-clicking another player's corpse
  12. Verify confirmation dialog appears for the dead player
  13. Test accept and decline flows
  </action>
  <verify>All 13 verification steps pass as described above.</verify>
  <done>User has confirmed that the death and corpse system works end-to-end: corpse creation, item dropping, looting, resurrection confirmation, and all edge cases verified.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (both spacetimedb and root)
2. Corpses visible in location panel Points of Interest section
3. Only online players' corpses shown (offline corpses hidden)
4. Own corpse has "Loot All" context menu option
5. Other players' corpses show name but no loot option
6. Confirmation dialog for resurrect/summon: title, message, Accept, Decline buttons
7. Looting all items removes corpse from UI
8. No ghost mechanics in UI (no ghost banner, no ghost restrictions)
9. Corpse count shown for own corpses
10. Cleric level 6+ sees "Resurrect" option on other players' corpses
</verification>

<success_criteria>
- Points of Interest section renders corpses at current location
- Only corpses of online players visible
- Right-click own corpse -> Loot All retrieves items
- Corpse disappears after full loot
- Resurrection confirmation prompt appears with Accept/Decline
- Corpse Summon confirmation prompt appears with Accept/Decline
- Accept triggers the server-side action
- Decline cancels without cost
- Level 1-4 deaths create no corpse
- Level 5+ deaths create corpse with inventory items
- Human verifies end-to-end flow
</success_criteria>

<output>
After completion, create `.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-03-SUMMARY.md`
</output>
