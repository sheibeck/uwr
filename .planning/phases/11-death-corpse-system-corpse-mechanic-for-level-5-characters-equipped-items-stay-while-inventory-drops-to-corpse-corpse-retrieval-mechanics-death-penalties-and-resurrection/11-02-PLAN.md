---
phase: 11-death-corpse-system
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/data/abilities/cleric_abilities.ts
  - spacetimedb/src/data/ability_catalog.ts
  - spacetimedb/src/reducers/corpse.ts
  - spacetimedb/src/helpers/corpse.ts
  - spacetimedb/src/index.ts
  - spacetimedb/src/seeding/ensure_items.ts
autonomous: true

must_haves:
  truths:
    - "Cleric has Resurrect ability at level 6 (out-of-combat, targets corpse)"
    - "Cleric/Necromancer has Corpse Summon ability (out-of-combat, targets character with corpses)"
    - "Resurrect prompts dead player for confirmation before casting"
    - "Corpse Summon prompts target player for confirmation before casting"
    - "Resurrect teleports dead character to corpse location and restores 50% HP/mana"
    - "Corpse Summon merges all target corpses to caster location"
    - "Declined confirmation cancels cast and refunds mana"
    - "Confirmation auto-declines after 30 seconds"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "PendingResurrect and PendingCorpseSummon tables"
      contains: "PendingResurrect"
    - path: "spacetimedb/src/data/abilities/cleric_abilities.ts"
      provides: "cleric_resurrect and cleric_corpse_summon ability definitions"
    - path: "spacetimedb/src/reducers/corpse.ts"
      provides: "Resurrect and corpse summon reducers with confirmation flow"
    - path: "spacetimedb/src/helpers/corpse.ts"
      provides: "executeResurrect and executeCorpseSummon helpers"
  key_links:
    - from: "spacetimedb/src/reducers/corpse.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "PendingResurrect/PendingCorpseSummon table access"
      pattern: "ctx\\.db\\.pendingResurrect"
    - from: "spacetimedb/src/reducers/corpse.ts"
      to: "spacetimedb/src/helpers/corpse.ts"
      via: "executeResurrect/executeCorpseSummon calls"
      pattern: "executeResurrect|executeCorpseSummon"
---

<objective>
Resurrection and Corpse Summon abilities with confirmation prompt system. Cleric gains Resurrect (level 6) that teleports a dead character to their corpse location, and Corpse Summon (level 7) that merges all of a target's corpses to the caster's location.

Purpose: Provides organized group play rewards - clerics can help party members recover from death without corpse runs. Confirmation prompts prevent unwanted teleportation.
Output: Working resurrection and corpse summon mechanics with server-side confirmation tables, timeout cleanup, and ability definitions.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-CONTEXT.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-01-SUMMARY.md
@spacetimedb/src/schema/tables.ts
@spacetimedb/src/data/abilities/cleric_abilities.ts
@spacetimedb/src/reducers/corpse.ts
@spacetimedb/src/helpers/corpse.ts
@spacetimedb/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pending action tables and ability definitions</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/data/abilities/cleric_abilities.ts
    spacetimedb/src/data/ability_catalog.ts
    spacetimedb/src/seeding/ensure_items.ts
    spacetimedb/src/index.ts
  </files>
  <action>
  **In `spacetimedb/src/schema/tables.ts`:**

  1. Add `PendingResurrect` table (public, indexes: by_target btree on targetCharacterId, by_caster btree on casterCharacterId):
     - id: t.u64().primaryKey().autoInc()
     - casterCharacterId: t.u64()
     - targetCharacterId: t.u64()
     - corpseId: t.u64()
     - createdAtMicros: t.u64()  (use micros for easy timeout comparison)

  2. Add `PendingCorpseSummon` table (public, indexes: by_target btree on targetCharacterId, by_caster btree on casterCharacterId):
     - id: t.u64().primaryKey().autoInc()
     - casterCharacterId: t.u64()
     - targetCharacterId: t.u64()
     - createdAtMicros: t.u64()

  3. Add both to the `schema()` call.

  **In `spacetimedb/src/data/abilities/cleric_abilities.ts`:**

  Add two new abilities:

  ```typescript
  cleric_resurrect: {
    name: 'Resurrect',
    description: 'Channels divine power to restore life to a fallen ally. Targets a corpse at the cleric\'s location. The dead character is teleported to the corpse and restored to 50% health and mana.',
    className: 'cleric',
    resource: 'mana',
    level: 6n,
    power: 0n,
    cooldownSeconds: 600n,  // 10 minute cooldown
    castSeconds: 0n,  // Instant cast (confirmation + cast time handled by pending action)
    damageType: 'none' as DamageType,
    combatState: 'out_of_combat',
  },
  cleric_corpse_summon: {
    name: 'Corpse Summon',
    description: 'Summons all of a target character\'s corpses to the caster\'s location, merging them into one. The target must confirm before the summon proceeds.',
    className: 'cleric',
    resource: 'mana',
    level: 7n,
    power: 0n,
    cooldownSeconds: 900n,  // 15 minute cooldown
    castSeconds: 0n,  // Handled by pending action
    damageType: 'none' as DamageType,
    combatState: 'out_of_combat',
  },
  ```

  Note: Check if `combatState` field exists in the AbilityMetadata type. If not, omit it and handle combat state checking in the reducer. Based on prior work (quick-6), `combatState` is already a field on AbilityTemplate.

  **In `spacetimedb/src/data/ability_catalog.ts`:**

  Verify the new abilities are picked up by the ABILITIES export. The cleric_abilities.ts should already be imported and spread into ABILITIES. If not, add the import and spread.

  **In `spacetimedb/src/seeding/ensure_items.ts`:**

  Verify ensureAbilityTemplates seeds the new abilities. Since it reads from ABILITIES constant and seeds all entries, new entries should be picked up automatically. No changes needed unless the seeding function filters by known keys.

  **In `spacetimedb/src/index.ts`:**

  Import `PendingResurrect, PendingCorpseSummon` from './schema/tables' (add to existing import).
  Add to `reducerDeps` object: `PendingResurrect, PendingCorpseSummon`.
  </action>
  <verify>
  `cd spacetimedb && npx tsc --noEmit` compiles without errors.
  Both new ability entries exist in CLERIC_ABILITIES.
  PendingResurrect and PendingCorpseSummon tables defined in schema.
  </verify>
  <done>
  PendingResurrect and PendingCorpseSummon tables defined with proper indexes. Cleric Resurrect (level 6) and Corpse Summon (level 7) ability definitions added with out-of-combat state, long cooldowns, and appropriate descriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Resurrection and Corpse Summon reducers with confirmation flow</name>
  <files>
    spacetimedb/src/reducers/corpse.ts
    spacetimedb/src/helpers/corpse.ts
  </files>
  <action>
  **In `spacetimedb/src/reducers/corpse.ts`:**

  Add the following reducers to the existing `registerCorpseReducers(deps)` function:

  CONFIRMATION_TIMEOUT = 30_000_000n (30 seconds in microseconds)

  1. `initiate_resurrect` reducer: `{ casterCharacterId: t.u64(), corpseId: t.u64() }`
     - requireCharacterOwnedBy for caster
     - Verify caster is not in combat (activeCombatIdForCharacter check)
     - Find the corpse: ctx.db.corpse.id.find(corpseId)
     - Verify corpse exists, verify caster is at same location as corpse
     - Find the target character (corpse.characterId): ctx.db.character.id.find(corpse.characterId)
     - Verify target exists
     - Verify caster has Resurrect ability: check ability template by key 'cleric_resurrect', verify caster class is cleric and level >= 6
     - Check mana cost: use abilityResourceCost or hardcode a reasonable mana cost (e.g., 4n + 6n * 2n + 0n = 16n mana based on level 6, power 0)
     - Verify caster has enough mana
     - Clean up any expired pending actions first: iterate PendingResurrect, delete any where nowMicros - createdAtMicros > CONFIRMATION_TIMEOUT
     - Check for existing pending resurrect for this target (prevent duplicates)
     - Create PendingResurrect row: { casterCharacterId, targetCharacterId: corpse.characterId, corpseId, createdAtMicros: nowMicros }
     - appendPrivateEvent to caster: "Awaiting [targetName]'s response to resurrect..."
     - appendPrivateEvent to target: "[casterName] wants to resurrect you at [locationName]. Type /accept_resurrect to accept."
     - NOTE: Since this is a server-side game, the accept/decline is done via reducer call from client, not chat command. The client UI will show a prompt.

  2. `accept_resurrect` reducer: `{ characterId: t.u64(), pendingId: t.u64() }`
     - requireCharacterOwnedBy for characterId (this is the target accepting)
     - Find PendingResurrect row by id
     - Verify the pending action belongs to this character (targetCharacterId === characterId)
     - Verify not expired: nowMicros - pending.createdAtMicros <= CONFIRMATION_TIMEOUT
     - Find the corpse (it might have been looted/decayed in the meantime)
     - Find the caster character (verify still exists and online)
     - Deduct mana from caster (re-verify mana availability)
     - Execute resurrection: call deps.executeResurrect(ctx, caster, target, corpse)
     - Delete the PendingResurrect row
     - Apply ability cooldown for cleric_resurrect on caster

  3. `decline_resurrect` reducer: `{ characterId: t.u64(), pendingId: t.u64() }`
     - requireCharacterOwnedBy for characterId
     - Find and verify PendingResurrect row
     - Delete it
     - appendPrivateEvent to caster: "[targetName] declined the resurrect."
     - appendPrivateEvent to target: "You declined the resurrect."
     - No mana consumed

  4. `initiate_corpse_summon` reducer: `{ casterCharacterId: t.u64(), targetCharacterId: t.u64() }`
     - requireCharacterOwnedBy for caster
     - Verify caster not in combat
     - Find target character, verify exists
     - Verify target has at least one corpse: [...ctx.db.corpse.by_character.filter(targetCharacterId)]
     - Verify caster has Corpse Summon ability (cleric_corpse_summon, class cleric, level >= 7)
     - Check mana cost
     - Clean up expired PendingCorpseSummon rows
     - Check for existing pending summon for target
     - Create PendingCorpseSummon row
     - Notify both characters

  5. `accept_corpse_summon` reducer: `{ characterId: t.u64(), pendingId: t.u64() }`
     - Similar to accept_resurrect flow
     - Deduct mana from caster
     - Execute corpse summon: call deps.executeCorpseSummon(ctx, caster, target)
     - Delete PendingCorpseSummon row
     - Apply cooldown

  6. `decline_corpse_summon` reducer: `{ characterId: t.u64(), pendingId: t.u64() }`
     - Similar to decline_resurrect
     - No mana consumed

  **In `spacetimedb/src/helpers/corpse.ts`:**

  Add two new exported functions:

  `executeResurrect(ctx, caster, target, corpse)`:
  - Teleport target to corpse location: update target's locationId to corpse.locationId
  - Restore target to 50% HP and mana: `hp = target.maxHp / 2n`, `mana = target.maxMana / 2n`
  - Update character row with new locationId, hp, mana
  - Corpse REMAINS (player must loot it separately per CONTEXT.md)
  - appendPrivateEvent to target: "[casterName] has resurrected you at [locationName]!"
  - appendPrivateEvent to caster: "You have resurrected [targetName]."
  - appendLocationEvent at corpse location: "[targetName] has been resurrected."

  `executeCorpseSummon(ctx, caster, target)`:
  - Find ALL corpses belonging to target: [...ctx.db.corpse.by_character.filter(target.id)]
  - If no corpses, return (shouldn't happen due to validation, but safety check)
  - Merge all corpses into ONE corpse at caster's current location:
    - Create one new corpse at caster.locationId (or reuse the first one and update its locationId)
    - For all other corpses: transfer their CorpseItem rows to the surviving corpse, then delete the old corpse
    - Update the surviving corpse's locationId to caster.locationId and createdAt to ctx.timestamp
  - appendPrivateEvent to target: "Your corpses have been summoned to [locationName]."
  - appendPrivateEvent to caster: "You have summoned [targetName]'s corpses."
  </action>
  <verify>
  `cd spacetimedb && npx tsc --noEmit` compiles without errors.
  All 6 reducers (initiate/accept/decline for both resurrect and corpse summon) are registered.
  executeResurrect teleports character and restores HP/mana.
  executeCorpseSummon merges all corpses to caster location.
  </verify>
  <done>
  Full confirmation flow for Resurrect and Corpse Summon: initiate creates pending row, target accepts/declines, accept executes the action and deducts mana, decline cancels with no cost. 30-second timeout with expired row cleanup. Resurrect teleports dead character to corpse location at 50% HP/mana. Corpse Summon merges all target corpses to caster location.
  </done>
</task>

<task type="auto">
  <name>Task 3: Publish module and regenerate bindings</name>
  <files>
    src/module_bindings/
  </files>
  <action>
  1. Publish: `spacetime publish uwr --clear-database -y --project-path spacetimedb`
  2. Regenerate: `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb`
  3. Verify generated bindings include:
     - PendingResurrect table type
     - PendingCorpseSummon table type
     - initiate_resurrect, accept_resurrect, decline_resurrect reducers
     - initiate_corpse_summon, accept_corpse_summon, decline_corpse_summon reducers
     - cleric_resurrect and cleric_corpse_summon in AbilityTemplate data
  4. Run `npx tsc --noEmit` at project root to verify client compilation
  </action>
  <verify>
  Module publishes. Bindings generated with all new tables and reducers. Client types compile.
  </verify>
  <done>
  Module published with PendingResurrect/PendingCorpseSummon tables and all resurrection/summon reducers. Client bindings include full type information for Plan 03 frontend integration.
  </done>
</task>

</tasks>

<verification>
1. `cd spacetimedb && npx tsc --noEmit` passes
2. Module publishes without errors
3. Resurrect ability defined: cleric level 6, out-of-combat, 10min cooldown
4. Corpse Summon ability defined: cleric level 7, out-of-combat, 15min cooldown
5. Confirmation flow: initiate -> pending row -> accept/decline -> execute or cancel
6. Resurrect teleports character to corpse location, restores 50% HP/mana
7. Corpse Summon merges all corpses to caster location
8. Declined actions don't consume mana
9. 30-second timeout on pending actions
10. No ghost mechanics (no isGhost field anywhere)
</verification>

<success_criteria>
- PendingResurrect and PendingCorpseSummon tables exist
- Cleric Resurrect ability (level 6) and Corpse Summon (level 7) defined in ability catalog
- initiate_resurrect creates pending row and notifies both players
- accept_resurrect teleports target to corpse, restores 50% HP/mana, deducts caster mana
- decline_resurrect cancels without mana cost
- initiate_corpse_summon creates pending row for character with corpses
- accept_corpse_summon merges all corpses to caster location
- decline_corpse_summon cancels without mana cost
- Expired pending actions cleaned up (30-second timeout)
- Module published and bindings regenerated
</success_criteria>

<output>
After completion, create `.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-02-SUMMARY.md`
</output>
