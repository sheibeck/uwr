---
phase: 11-death-corpse-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/helpers/corpse.ts
  - spacetimedb/src/reducers/corpse.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/characters.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Level 5+ character dying in combat creates a corpse at death location"
    - "Level 1-4 character dying creates no corpse"
    - "Equipped items stay on character after death; only inventory items drop to corpse"
    - "Gold stays on character after death"
    - "Dying in same location as existing corpse combines into one corpse"
    - "Multiple corpses at different locations remain separate"
    - "Character can loot individual items from their own corpse"
    - "Fully looted corpse auto-deletes"
    - "Corpses older than 30 days are cleaned up"
    - "Character respawns at bind point with message about corpse location"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "Corpse and CorpseItem table definitions"
      contains: "Corpse"
    - path: "spacetimedb/src/helpers/corpse.ts"
      provides: "createCorpse helper, cleanupDecayedCorpses helper"
    - path: "spacetimedb/src/reducers/corpse.ts"
      provides: "loot_corpse_item, loot_all_corpse reducers"
      exports: ["registerCorpseReducers"]
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Corpse creation hook in defeat handling"
    - path: "spacetimedb/src/reducers/characters.ts"
      provides: "Modified respawn with corpse awareness"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/corpse.ts"
      via: "createCorpse call in defeat section"
      pattern: "createCorpse\\(ctx"
    - from: "spacetimedb/src/reducers/corpse.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "Corpse/CorpseItem table access"
      pattern: "ctx\\.db\\.corpse"
    - from: "spacetimedb/src/reducers/characters.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "Corpse check in respawn for messaging"
      pattern: "ctx\\.db\\.corpse\\.by_character"
---

<objective>
Backend foundation for the death and corpse system: tables, corpse creation on death, item transfer mechanics, corpse looting, and decay cleanup.

Purpose: Establishes the core data model and server-side mechanics for corpse persistence. When a level 5+ character dies, their inventory items transfer to a corpse at the death location while equipped items and gold stay on the character.
Output: Working backend where death creates corpses, characters can loot their corpses, and decayed corpses are cleaned up.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-CONTEXT.md
@spacetimedb/src/schema/tables.ts
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/reducers/characters.ts
@spacetimedb/src/reducers/index.ts
@spacetimedb/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Corpse and CorpseItem tables + createCorpse helper</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/helpers/corpse.ts
  </files>
  <action>
  **In `spacetimedb/src/schema/tables.ts`:**

  1. Add `Corpse` table (public, indexes: by_character btree on characterId, by_location btree on locationId):
     - id: t.u64().primaryKey().autoInc()
     - characterId: t.u64()
     - locationId: t.u64()
     - createdAt: t.timestamp()

  2. Add `CorpseItem` table (public, indexes: by_corpse btree on corpseId):
     - id: t.u64().primaryKey().autoInc()
     - corpseId: t.u64()
     - itemInstanceId: t.u64()

  3. Add both tables to the `schema()` call at the bottom of the file, alongside existing tables.

  **Create `spacetimedb/src/helpers/corpse.ts`:**

  Export function `createCorpse(ctx, character)`:
  - If `character.level < 5n`, return null (no corpse for low levels). Note: the existing XP penalty uses `<= 5n` but CONTEXT.md says "level 5+" so use `< 5n` which means level 5 and above create corpses.
  - WAIT - re-read CONTEXT.md: "Level 5+ characters create corpses on death" means level >= 5. The existing applyDeathXpPenalty uses `character.level <= 5n` to skip penalty for levels 1-5. For corpse: skip if `character.level < 5n` (levels 1-4 skip, level 5+ creates corpse).
  - Check for existing corpse at SAME location: `[...ctx.db.corpse.by_character.filter(character.id)]` then find one where `locationId === character.locationId`
  - If existing corpse at same location found: reuse it (don't create new one), update createdAt to current timestamp
  - If no existing corpse at this location: create new corpse with `ctx.db.corpse.insert({ id: 0n, characterId: character.id, locationId: character.locationId, createdAt: ctx.timestamp })`
  - Transfer inventory items to corpse: iterate `ctx.db.itemInstance.by_owner.filter(character.id)`, for each item where `!item.equippedSlot` (not equipped), insert a `ctx.db.corpseItem.insert({ id: 0n, corpseId: corpse.id, itemInstanceId: item.id })`. Skip items already in this corpse (check by_corpse to avoid duplicates when combining).
  - Return the corpse row.

  Export function `cleanupDecayedCorpses(ctx)`:
  - 30-day decay: `const CORPSE_DECAY_MICROS = 30n * 24n * 60n * 60n * 1_000_000n`
  - Iterate all corpses via `ctx.db.corpse.iter()`
  - For each corpse, check if `ctx.timestamp.microsSinceUnixEpoch - corpse.createdAt.microsSinceUnixEpoch > CORPSE_DECAY_MICROS`
  - If expired: delete all CorpseItem rows for this corpse (iterate by_corpse), then delete the ItemInstance rows for those items (permanent loss), then delete the corpse itself
  - Log a private event to the corpse owner character if they exist: "Your corpse at [locationName] has decayed. Items lost."

  Export function `deleteCorpseAndItems(ctx, corpse)`:
  - Delete all CorpseItem rows for corpse via `ctx.db.corpseItem.by_corpse.filter(corpse.id)`
  - Delete the corresponding ItemInstance rows (the items are permanently lost when corpse decays or is empty)
  - WAIT: On decay, items should be deleted. On loot, items should NOT be deleted (they go back to player). So this helper is for decay only. Name it `decayCorpse(ctx, corpse)`:
    - For each corpseItem in by_corpse.filter(corpse.id): delete the ItemInstance row, then delete the CorpseItem row
    - Delete the Corpse row

  Export function `removeCorpseIfEmpty(ctx, corpseId)`:
  - Check if any CorpseItem rows remain for this corpse: `[...ctx.db.corpseItem.by_corpse.filter(corpseId)]`
  - If length === 0, delete the Corpse row. Return true if deleted, false if items remain.

  Import `appendPrivateEvent` from `./events` for logging. Import Corpse, CorpseItem from schema if needed for types.
  </action>
  <verify>
  TypeScript compiles without errors: `cd spacetimedb && npx tsc --noEmit`
  Tables exist in schema export. Helper functions export correctly.
  </verify>
  <done>
  Corpse and CorpseItem tables defined with proper indexes. createCorpse helper handles level gating, same-location combining, and inventory-to-corpse transfer. cleanupDecayedCorpses handles 30-day expiry. removeCorpseIfEmpty auto-deletes empty corpses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Death hook in combat, respawn modification, corpse looting reducers</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/characters.ts
    spacetimedb/src/reducers/corpse.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/index.ts
  </files>
  <action>
  **In `spacetimedb/src/reducers/combat.ts`:**

  In the defeat section (around line 2460-2473), after `clearCombatArtifacts` and combat state set to 'resolved', and BEFORE the XP penalty loop, add corpse creation for each dead character:
  ```
  for (const p of participants) {
    const character = ctx.db.character.id.find(p.characterId);
    if (character && character.hp === 0n) {
      deps.createCorpse(ctx, character);
    }
  }
  ```
  This must happen AFTER combat is resolved so items are properly transferred. The `createCorpse` function handles level gating internally.

  Also add corpse creation in the mixed victory/defeat section (around line 2106-2125) where dead characters get XP penalty. Before the XP penalty, call `deps.createCorpse(ctx, character)` for each dead character.

  The `deps` object needs `createCorpse` added. It is passed from index.ts.

  **In `spacetimedb/src/reducers/characters.ts`:**

  Modify the `respawn_character` reducer:
  - After respawning (setting hp to 1, mana to 1, moving to bind point), check if character has any corpses: `const corpses = [...ctx.db.corpse.by_character.filter(character.id)]`
  - If corpses exist, build a message listing corpse locations:
    ```
    if (corpses.length > 0) {
      const locationNames = corpses.map(c => {
        const loc = ctx.db.location.id.find(c.locationId);
        return loc?.name ?? 'unknown';
      });
      const unique = [...new Set(locationNames)];
      appendPrivateEvent(ctx, character.id, character.ownerUserId, 'system',
        `You have ${corpses.length} corpse(s) containing your belongings at: ${unique.join(', ')}.`);
    }
    ```
  - Also run opportunistic corpse decay cleanup: `deps.cleanupDecayedCorpses(ctx)` (only on respawn to avoid overhead)
  - Add `cleanupDecayedCorpses` to the deps destructuring at the top of registerCharacterReducers

  Also modify `delete_character` reducer to clean up any corpses belonging to the deleted character:
  - After existing cleanup loops, add: iterate `ctx.db.corpse.by_character.filter(characterId)`, for each corpse delete all CorpseItem rows then delete the corpse.

  **Create `spacetimedb/src/reducers/corpse.ts`:**

  Export `registerCorpseReducers(deps)`:

  1. `loot_corpse_item` reducer: `{ characterId: t.u64(), corpseItemId: t.u64() }`
     - requireCharacterOwnedBy(ctx, characterId)
     - Find the CorpseItem row by id: `ctx.db.corpseItem.id.find(corpseItemId)`
     - If not found, throw SenderError('Item not found in corpse')
     - Find the Corpse row: `ctx.db.corpse.id.find(corpseItem.corpseId)`
     - If not found, throw SenderError('Corpse not found')
     - Verify character owns this corpse: `corpse.characterId !== character.id` -> throw SenderError('This is not your corpse')
     - Verify character is at the same location: `character.locationId !== corpse.locationId` -> throw SenderError('You must be at the corpse location')
     - Delete the CorpseItem row: `ctx.db.corpseItem.id.delete(corpseItem.id)`
     - The ItemInstance already has ownerCharacterId set to character.id (it was never changed), so the item returns to inventory automatically.
     - Get item template for message: find ItemInstance, then ItemTemplate
     - appendPrivateEvent: "You retrieve [itemName] from your corpse."
     - Check if corpse is now empty and auto-delete: `deps.removeCorpseIfEmpty(ctx, corpse.id)` - if true, appendPrivateEvent: "Your corpse crumbles to dust."

  2. `loot_all_corpse` reducer: `{ characterId: t.u64(), corpseId: t.u64() }`
     - requireCharacterOwnedBy(ctx, characterId)
     - Find the Corpse row: `ctx.db.corpse.id.find(corpseId)`
     - If not found, throw SenderError('Corpse not found')
     - Verify ownership: `corpse.characterId !== character.id` -> SenderError
     - Verify location: `character.locationId !== corpse.locationId` -> SenderError
     - Iterate all CorpseItem rows for this corpse, delete each one
     - Count items retrieved, appendPrivateEvent: "You retrieve N items from your corpse."
     - Delete the corpse: `ctx.db.corpse.id.delete(corpse.id)`
     - appendPrivateEvent: "Your corpse crumbles to dust."

  **In `spacetimedb/src/reducers/index.ts`:**
  - Import `registerCorpseReducers` from './corpse'
  - Add `registerCorpseReducers(deps)` call in `registerReducers`

  **In `spacetimedb/src/index.ts`:**
  - Import `Corpse, CorpseItem` from './schema/tables' (add to existing import)
  - Import `createCorpse, cleanupDecayedCorpses, removeCorpseIfEmpty` from './helpers/corpse'
  - Add these to the `reducerDeps` object:
    - `createCorpse`
    - `cleanupDecayedCorpses`
    - `removeCorpseIfEmpty`
    - `Corpse` (if needed for type references)
    - `CorpseItem` (if needed for type references)
  </action>
  <verify>
  Run `cd spacetimedb && npx tsc --noEmit` - must compile without errors.
  Verify createCorpse is called in both defeat paths in combat.ts.
  Verify respawn_character lists corpse locations.
  Verify loot_corpse_item and loot_all_corpse reducers exist.
  </verify>
  <done>
  Death in combat creates corpse for level 5+ characters. Respawn message lists corpse locations. Characters can loot individual or all items from their corpse. Empty corpses auto-delete. Character deletion cleans up corpses. Decay cleanup runs opportunistically on respawn.
  </done>
</task>

<task type="auto">
  <name>Task 3: Publish module and regenerate client bindings</name>
  <files>
    src/module_bindings/
  </files>
  <action>
  1. Publish the module: `spacetime publish uwr --clear-database -y --project-path spacetimedb`
     - Use --clear-database because new tables (Corpse, CorpseItem) are being added
     - Check the default server with `spacetime server list` first to confirm target

  2. Regenerate client bindings: `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb`

  3. Verify the generated bindings include:
     - corpse_table.ts with CorpseRow type
     - corpse_item_table.ts with CorpseItemRow type
     - loot_corpse_item_reducer.ts
     - loot_all_corpse_reducer.ts
     - Updated tables export with corpse and corpseItem

  4. Run `npx tsc --noEmit` in the project root to verify client types compile
  </action>
  <verify>
  Module publishes successfully. Client bindings regenerated. `npx tsc --noEmit` passes in root.
  Generated bindings include Corpse, CorpseItem types and loot reducers.
  </verify>
  <done>
  Module published with Corpse/CorpseItem tables. Client bindings generated with all new types and reducer signatures available for Plan 02 and 03.
  </done>
</task>

</tasks>

<verification>
1. Compile check: `cd spacetimedb && npx tsc --noEmit` passes
2. Module publishes without errors
3. Client bindings include Corpse, CorpseItem tables and loot reducers
4. No ghost mechanics anywhere (no isGhost field, no ghost references)
5. Level gating: createCorpse checks `character.level < 5n` to skip levels 1-4
6. Equipped items preserved: createCorpse only transfers items where `!item.equippedSlot`
7. Gold preserved: no gold manipulation in createCorpse
8. Same-location combining: createCorpse finds existing corpse at same locationId
</verification>

<success_criteria>
- Corpse and CorpseItem tables exist in schema with proper indexes
- Death in combat creates corpse for level 5+ characters at death location
- Only inventory items (not equipped) transfer to corpse
- Dying in same location combines corpses
- Multiple corpses at different locations kept separate
- loot_corpse_item retrieves single item from own corpse at same location
- loot_all_corpse retrieves all items from own corpse at same location
- Empty corpse auto-deletes after looting
- 30-day decay cleanup removes expired corpses and their items
- Respawn message lists corpse locations
- Character deletion cleans up corpses
- Module published and bindings regenerated
</success_criteria>

<output>
After completion, create `.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-01-SUMMARY.md`
</output>
