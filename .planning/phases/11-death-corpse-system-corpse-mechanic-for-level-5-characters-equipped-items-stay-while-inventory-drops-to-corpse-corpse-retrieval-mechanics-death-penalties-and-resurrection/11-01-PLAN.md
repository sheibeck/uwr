---
phase: 11-death-corpse-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/helpers/corpse.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/characters.ts
  - spacetimedb/src/reducers/corpse.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/movement.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Level 5+ characters who die in combat create a corpse at the death location containing their inventory items"
    - "Equipped items stay on the character after death, only unequipped inventory drops to corpse"
    - "Respawning at bind point sets the character to ghost state if a corpse exists"
    - "Ghost characters can travel to their corpse location and retrieve items"
    - "Ghost characters can summon their corpse at a bind stone location"
    - "Ghost characters cannot enter combat or take damage"
    - "Level 1-5 characters die and respawn normally with no corpse"
    - "Gold stays on character, never drops to corpse"
    - "Dying with an existing corpse merges items into the existing corpse at the new death location"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "Corpse and CorpseItem table definitions, isGhost field on Character"
      contains: "export const Corpse"
    - path: "spacetimedb/src/helpers/corpse.ts"
      provides: "createCorpse and retrieveCorpse helper functions"
      exports: ["createCorpse", "retrieveCorpse"]
    - path: "spacetimedb/src/reducers/corpse.ts"
      provides: "retrieve_corpse and summon_corpse reducers"
      exports: ["registerCorpseReducers"]
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Death hook calling createCorpse"
      contains: "createCorpse"
    - path: "spacetimedb/src/reducers/characters.ts"
      provides: "Modified respawn with ghost state, corpse cleanup on delete"
      contains: "isGhost"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/corpse.ts"
      via: "import createCorpse"
      pattern: "createCorpse\\(ctx"
    - from: "spacetimedb/src/reducers/characters.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "isGhost field on Character update"
      pattern: "isGhost"
    - from: "spacetimedb/src/reducers/corpse.ts"
      to: "spacetimedb/src/helpers/corpse.ts"
      via: "import retrieveCorpse"
      pattern: "retrieveCorpse"
---

<objective>
Backend infrastructure for death and corpse system: tables, helpers, reducers, and guards.

Purpose: When level 5+ characters die, their inventory items drop to a corpse at the death location. Characters respawn as ghosts at their bind point and must travel back to retrieve items. Ghosts are immune to combat. This creates meaningful death consequences while keeping equipped gear safe.

Output: Corpse/CorpseItem tables, isGhost on Character, createCorpse/retrieveCorpse helpers, retrieve_corpse/summon_corpse reducers, ghost immunity guards in combat and movement, published module with regenerated bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-RESEARCH.md
@spacetimedb/src/schema/tables.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/reducers/characters.ts
@spacetimedb/src/reducers/index.ts
@spacetimedb/src/reducers/movement.ts
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Corpse tables and isGhost field, create corpse helper</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/helpers/corpse.ts
  </files>
  <action>
    1. In `spacetimedb/src/schema/tables.ts`:
       - Add `isGhost: t.bool()` field to the Character table definition (add at end of columns, before the closing brace). Set no default - existing characters will get false.
       - Add Corpse table definition:
         ```
         export const Corpse = table(
           { name: 'corpse', public: true,
             indexes: [
               { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
               { name: 'by_location', algorithm: 'btree', columns: ['locationId'] },
             ]
           },
           { id: t.u64().primaryKey().autoInc(), characterId: t.u64(), locationId: t.u64(), createdAt: t.timestamp() }
         );
         ```
       - Add CorpseItem table definition:
         ```
         export const CorpseItem = table(
           { name: 'corpse_item', public: true,
             indexes: [{ name: 'by_corpse', algorithm: 'btree', columns: ['corpseId'] }]
           },
           { id: t.u64().primaryKey().autoInc(), corpseId: t.u64(), itemInstanceId: t.u64() }
         );
         ```
       - Add Corpse and CorpseItem to the schema() call at the bottom of the file.

    2. Create `spacetimedb/src/helpers/corpse.ts` with two exported functions:

       `createCorpse(ctx, character)`:
       - If `character.level <= 5n`, return null (no corpse for low levels).
       - Check for existing corpse: `[...ctx.db.corpse.by_character.filter(character.id)][0]`.
       - If existing corpse found: update its locationId to `character.locationId` and createdAt to `ctx.timestamp`. Clear existing CorpseItem entries for this corpse (they reference items no longer in inventory since previous death). Then add current inventory items.
       - If no existing corpse: insert new Corpse row with `{ id: 0n, characterId: character.id, locationId: character.locationId, createdAt: ctx.timestamp }`.
       - Transfer inventory items: iterate `ctx.db.itemInstance.by_owner.filter(character.id)`, skip items with `equippedSlot` (equipped items stay). For each unequipped item, insert CorpseItem `{ id: 0n, corpseId: corpse.id, itemInstanceId: item.id }`.
       - Return the corpse row.

       `retrieveCorpse(ctx, character, corpse)`:
       - Delete all CorpseItem entries for the corpse: `for (const ci of ctx.db.corpseItem.by_corpse.filter(corpse.id)) { ctx.db.corpseItem.id.delete(ci.id); }`.
       - Delete the corpse: `ctx.db.corpse.id.delete(corpse.id)`.
       - Update character: `ctx.db.character.id.update({ ...character, isGhost: false })`.

       Import SenderError from 'spacetimedb/server'. Follow the existing helper pattern (see helpers/combat.ts, helpers/events.ts for style).
  </action>
  <verify>
    TypeScript compiles without errors: `cd spacetimedb && npx tsc --noEmit` (or equivalent check).
    tables.ts has Corpse, CorpseItem in schema() call.
    Character table has isGhost field.
    helpers/corpse.ts exports createCorpse and retrieveCorpse.
  </verify>
  <done>
    Corpse and CorpseItem tables defined with correct indexes.
    Character table has isGhost boolean field.
    createCorpse helper correctly skips level <=5, handles existing corpse merge, transfers only unequipped inventory items.
    retrieveCorpse helper cleans up CorpseItem entries, deletes corpse, clears isGhost.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire corpse creation into combat death, modify respawn, add corpse reducers, add ghost guards</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/characters.ts
    spacetimedb/src/reducers/corpse.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/reducers/movement.ts
    spacetimedb/src/index.ts
  </files>
  <action>
    1. **Combat death hook** (`spacetimedb/src/reducers/combat.ts`):
       - Add `createCorpse` to the deps destructuring in `registerCombatReducers`.
       - In `markParticipantDead` function (around line 243), AFTER `clearCharacterEffectsOnDeath(ctx, character)` and the death log message, add: `createCorpse(ctx, character);`.
       - This is the ONLY place corpse creation happens - when a character is marked dead in combat.

    2. **Modified respawn** (`spacetimedb/src/reducers/characters.ts`):
       - In the `respawn_character` reducer:
         - After the combat check and effect cleanup, check for corpse: `const corpseRows = [...ctx.db.corpse.by_character.filter(character.id)]; const hasCorpse = corpseRows.length > 0;`
         - Update the character update to include `isGhost: hasCorpse`: change the update to `{ ...character, locationId: nextLocationId, hp: 1n, mana: ..., stamina: ..., isGhost: hasCorpse }`.
         - Update the event message: if `hasCorpse`, say `'You awaken as a ghost at ${respawnLocation}. Return to your corpse to reclaim your belongings.'`, else keep existing message.
       - In `delete_character` reducer: add cleanup for Corpse and CorpseItem entries. Before deleting the character, iterate `ctx.db.corpse.by_character.filter(characterId)`, delete all CorpseItem entries for each corpse, then delete the corpse.
       - In `create_character` reducer: ensure `isGhost: false` is included in the character insert (add to the insert object).

    3. **New corpse reducers** (create `spacetimedb/src/reducers/corpse.ts`):
       - Export `registerCorpseReducers(deps)` following the same pattern as other reducer files.
       - Destructure needed deps: `spacetimedb, t, SenderError, requireCharacterOwnedBy, appendPrivateEvent, retrieveCorpse` (retrieveCorpse from helpers/corpse.ts - but since deps are passed from index.ts, it needs to be in deps).

       **retrieve_corpse reducer** `{ characterId: t.u64() }`:
       - `const character = requireCharacterOwnedBy(ctx, characterId);`
       - If `!character.isGhost`, throw SenderError `'You are not a ghost.'`.
       - Find corpse: `const corpse = [...ctx.db.corpse.by_character.filter(character.id)][0];`
       - If no corpse, throw SenderError `'No corpse found.'`.
       - Proximity check: if `character.locationId !== corpse.locationId`, find corpse location name and throw `'Your corpse is at ${locationName}. Travel there to retrieve it.'`.
       - Call `retrieveCorpse(ctx, character, corpse)`.
       - Append private event: `'You reclaim your belongings and return to the living.'`.

       **summon_corpse reducer** `{ characterId: t.u64() }`:
       - `const character = requireCharacterOwnedBy(ctx, characterId);`
       - If `!character.isGhost`, throw SenderError `'You are not a ghost.'`.
       - Check bind stone: `const location = ctx.db.location.id.find(character.locationId);` if `!location?.bindStone`, throw `'You must be at a bind stone to summon your corpse.'`.
       - Find corpse. If no corpse, throw `'No corpse to summon.'`.
       - Move corpse to character location: `ctx.db.corpse.id.update({ ...corpse, locationId: character.locationId });`.
       - Then call retrieveCorpse to complete the retrieval.
       - Append private event: `'Your corpse materializes before you. You reclaim your belongings.'`.

    4. **Register corpse reducers** (`spacetimedb/src/reducers/index.ts`):
       - Import `registerCorpseReducers` from `'./corpse'`.
       - Add `registerCorpseReducers(deps);` call in the `registerReducers` function.

    5. **Ghost guards** (`spacetimedb/src/reducers/movement.ts`):
       - In the `move_character` reducer, ghosts CAN move (they need to travel to their corpse). No guard needed here for movement.
       - However, check the pull/combat start flow. Find where combat is initiated (likely in combat.ts or via pull resolution). In `start_combat` or `start_pull` or equivalent, add a guard: if `character.isGhost`, throw SenderError `'Ghosts cannot enter combat.'`.

    6. **Ghost guard in combat.ts**:
       - In the combat loop's auto-attack section: skip characters where `character.isGhost === true` (they shouldn't be in combat, but defensive check).
       - In the `use_ability` reducer (if it exists in combat.ts), add guard: if character.isGhost, throw SenderError.
       - In `start_pull` or equivalent pull initiation: if character.isGhost, throw SenderError `'Ghosts cannot engage enemies.'`.

    7. **Wire deps in index.ts** (`spacetimedb/src/index.ts`):
       - Import `createCorpse, retrieveCorpse` from `'./helpers/corpse'`.
       - Import `Corpse, CorpseItem` from `'./schema/tables'` (add to existing import).
       - Add `createCorpse`, `retrieveCorpse`, `Corpse`, `CorpseItem` to the deps object passed to registerReducers.

    8. **Publish and regenerate bindings**:
       - Run `spacetime publish uwr --clear-database -y --project-path spacetimedb` (clear needed for schema change adding isGhost column).
       - Run `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb`.
  </action>
  <verify>
    - `spacetime publish` succeeds without errors.
    - `spacetime generate` produces updated bindings including Corpse, CorpseItem tables and updated Character type with isGhost.
    - Check `spacetime logs uwr` for any runtime errors.
    - Grep for `createCorpse` in combat.ts to confirm it's wired into markParticipantDead.
    - Grep for `isGhost` in characters.ts to confirm respawn sets ghost state.
    - Grep for `registerCorpseReducers` in reducers/index.ts to confirm registration.
  </verify>
  <done>
    Combat death calls createCorpse for level 5+ characters.
    Respawn sets isGhost=true when corpse exists, false otherwise.
    retrieve_corpse reducer transfers items back and clears ghost state (requires same location as corpse).
    summon_corpse reducer moves corpse to character's bind stone location then retrieves.
    Ghost characters cannot initiate combat/pulls.
    Character deletion cleans up corpse data.
    Module published and bindings regenerated with new tables and isGhost field.
  </done>
</task>

</tasks>

<verification>
- Module publishes successfully with Corpse, CorpseItem tables and isGhost on Character.
- Client bindings include corpse_table, corpse_item_table, and updated character_type with isGhost.
- `spacetime logs uwr` shows no errors after publish.
- Death flow: when character HP reaches 0 in combat, createCorpse is called (level 5+ only).
- Respawn flow: respawn_character sets isGhost based on corpse existence.
- Retrieval flow: retrieve_corpse validates location match, deletes corpse items and corpse, clears isGhost.
- Summon flow: summon_corpse validates bind stone, moves corpse to current location, then retrieves.
- Ghost guards prevent combat initiation.
</verification>

<success_criteria>
- Corpse and CorpseItem tables exist in published module.
- Character table has isGhost field.
- Level 5+ death creates corpse with unequipped inventory items.
- Level 1-5 death creates no corpse (existing behavior preserved).
- Respawn sets ghost state when corpse exists.
- retrieve_corpse and summon_corpse reducers are callable.
- Ghost characters blocked from combat.
- Module compiles, publishes, and bindings regenerate cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/11-death-corpse-system-corpse-mechanic-for-level-5-characters-equipped-items-stay-while-inventory-drops-to-corpse-corpse-retrieval-mechanics-death-penalties-and-resurrection/11-01-SUMMARY.md`
</output>
