---
phase: 18-world-events-system-expansion
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - spacetimedb/src/reducers/world_events.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/movement.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can fire a world event via fire_world_event reducer (guarded by ADMIN_IDENTITIES check)"
    - "Non-admin callers are rejected by fire_world_event with SenderError"
    - "Admin can resolve a world event via resolve_world_event reducer specifying outcome"
    - "Combat kills of event enemies increment EventContribution count for the killing character"
    - "Characters entering a region with an active event automatically get an EventContribution row with count=0"
    - "collect_event_item reducer lets players collect event-spawned items and increments contribution"
    - "despawn_event_content scheduled reducer deletes EnemySpawn, EnemySpawnMember, EventSpawnEnemy, EventSpawnItem, EventObjective rows for the event"
    - "increment_event_counter reducer updates threshold race counters and auto-resolves when threshold hit"
    - "Module publishes and client bindings regenerate successfully"
    - "One-time events cannot be fired again after resolution"
    - "Combat kills call incrementWorldStat('total_enemies_killed', 1n) to satisfy REQ-032 threshold-triggered event firing"
    - "Quest completions call incrementWorldStat('total_quests_completed', 1n) to satisfy REQ-032 threshold-triggered event firing"
  artifacts:
    - path: "spacetimedb/src/reducers/world_events.ts"
      provides: "fire_world_event, resolve_world_event, collect_event_item, increment_event_counter reducers, despawn_event_content scheduled reducer"
      contains: "fire_world_event"
    - path: "spacetimedb/src/reducers/index.ts"
      provides: "registerWorldEventReducers import and call"
      contains: "registerWorldEventReducers"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Event enemy kill contribution hook, incrementWorldStat hook for total_enemies_killed"
      contains: "eventSpawnEnemy"
    - path: "spacetimedb/src/reducers/movement.ts"
      provides: "Region entry auto-registration for active world events"
      contains: "eventContribution"
  key_links:
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "fireWorldEvent, resolveWorldEvent imports"
      pattern: "fireWorldEvent|resolveWorldEvent"
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/data/world_event_data.ts"
      via: "ADMIN_IDENTITIES import for admin guard"
      pattern: "ADMIN_IDENTITIES"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "EventSpawnEnemy table lookup after kill to detect event enemies"
      pattern: "eventSpawnEnemy"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "incrementWorldStat import for REQ-032 stat tracking"
      pattern: "incrementWorldStat"
    - from: "spacetimedb/src/reducers/movement.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "WorldEvent and EventContribution tables for auto-registration"
      pattern: "worldEvent"
---

<objective>
Wire the world event system into the game loop: create world event reducers (fire, resolve, collect, counter increment, despawn), hook combat kills to credit event contribution and increment world stat trackers (REQ-032), hook region entry in movement to auto-register participants, publish module and regenerate client bindings.

Purpose: Make the world event system functional end-to-end on the backend — events can be fired, participated in, contributed to, resolved with tiered rewards, and cleaned up after linger. Threshold-triggered events (REQ-032) are wired via incrementWorldStat calls in combat and quest hooks.
Output: Working reducers, combat/movement hooks with stat tracking, published module, regenerated client bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-CONTEXT.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-RESEARCH.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-01-SUMMARY.md

Key existing files:
@spacetimedb/src/reducers/index.ts — DI deps pattern, registerXxxReducers calls
@spacetimedb/src/reducers/combat.ts — Kill loop where grantFactionStandingForKill is called
@spacetimedb/src/reducers/movement.ts — move_character reducer, region crossing detection
@spacetimedb/src/index.ts — syncAllContent seeding, spacetimedb.init
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create world event reducers with admin guard and despawn</name>
  <files>
    spacetimedb/src/reducers/world_events.ts
    spacetimedb/src/reducers/index.ts
  </files>
  <action>
**CRITICAL CONTEXT DECISIONS:**
- Joining is automatic on region entry (handled in Task 2 via movement hook)
- Rewards only if contributed (count > 0) — enforced by helpers from Plan 01
- Admin guard uses ADMIN_IDENTITIES set (ctx.sender.toHexString())
- despawn_event_content cleans up EnemySpawn + EnemySpawnMember BEFORE EventSpawnEnemy (prevent ghost spawns)

**Create `spacetimedb/src/reducers/world_events.ts`:**

Follow the established registerXxxReducers(deps) pattern from other reducer files.

```typescript
export function registerWorldEventReducers(deps: any) {
  const { spacetimedb, t, SenderError, ScheduleAt } = deps;
```

Register these reducers inside the function:

1. **fire_world_event** reducer — Admin fires event by eventKey:
   - Parameters: `{ eventKey: t.string() }`
   - Admin guard: `if (!ADMIN_IDENTITIES.has(ctx.sender.toHexString())) throw new SenderError('Admin only');`
   - Import and call `fireWorldEvent(ctx, eventKey, deps)` from helpers
   - fireWorldEvent already handles one-time event guard, spawning, and log entry

2. **resolve_world_event** reducer — Admin resolves an active event:
   - Parameters: `{ worldEventId: t.u64(), outcome: t.string() }`
   - Admin guard same as above
   - Validate outcome is 'success' or 'failure'
   - Look up event by id, validate status === 'active'
   - Call `resolveWorldEvent(ctx, event, outcome, deps)` from helpers

3. **collect_event_item** reducer — Player collects an event-spawned item:
   - Parameters: `{ eventSpawnItemId: t.u64(), characterId: t.u64() }`
   - Validate character ownership via ctx.sender
   - Find EventSpawnItem row, validate not already collected
   - Validate character is at the item's locationId
   - Mark collected=true, set collectedByCharacterId
   - Increment EventContribution count for this character + eventId
   - Check if all event items collected or objective hit, potentially auto-resolve for objective events

4. **increment_event_counter** reducer — Used by combat/objective hooks for threshold race:
   - Parameters: `{ eventId: t.u64(), side: t.string(), amount: t.u64() }`
   - side must be 'success' or 'failure'
   - Look up WorldEvent, validate active
   - Increment successCounter or failureCounter
   - Check if threshold hit: if successCounter >= successThreshold, resolve as success; if failureCounter >= failureThreshold, resolve as failure
   - First threshold hit wins (check both after increment)

5. **despawn_event_content** scheduled reducer — Cleans up event spawns after 2-minute linger:
   - Parameters: `{ arg: EventDespawnTick.rowType }` (following scheduled reducer pattern)
   - For each EventSpawnEnemy with eventId: collect spawnId, delete EnemySpawnMember rows via by_spawn index, delete EnemySpawn row, then delete EventSpawnEnemy row
   - IMPORTANT: If any spawn has an active CombatEncounter at its location, check if combat involves that spawn. If combat is active, either skip that spawn or force-resolve. Safer to skip and let combat resolve naturally.
   - Delete all EventSpawnItem rows for eventId
   - Delete all EventObjective rows for eventId
   - Delete all EventContribution rows for eventId (cleanup)

**In `spacetimedb/src/reducers/index.ts`:**

1. Add import: `import { registerWorldEventReducers } from './world_events';`
2. Add the EventDespawnTick scheduled table to the deps object (it needs to be passed for the scheduled reducer)
3. Add call: `registerWorldEventReducers(deps);` after existing reducer registrations
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — no errors. Confirm world_events.ts exports registerWorldEventReducers. Confirm index.ts imports and calls it. Confirm fire_world_event has ADMIN_IDENTITIES guard. Confirm despawn_event_content deletes in correct order (EnemySpawnMember -> EnemySpawn -> EventSpawnEnemy, then EventSpawnItem, EventObjective).
  </verify>
  <done>
5 world event reducers registered: fire_world_event (admin-guarded), resolve_world_event (admin-guarded), collect_event_item (player), increment_event_counter (internal), despawn_event_content (scheduled). All follow DI pattern. Admin guard uses ADMIN_IDENTITIES set. Despawn cleans up in safe order.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook combat kills and movement for event participation, wire incrementWorldStat, publish module</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/movement.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**CRITICAL CONTEXT DECISIONS:**
- Participation is automatic on region entry — character in region while event is active gets EventContribution row
- Rewards only if interacted (count > 0) — region entry creates row with count=0
- Combat kills of event-specific enemies increment contribution count
- REQ-032: incrementWorldStat must be called on combat kills and quest completions for threshold-triggered event firing

**In `spacetimedb/src/reducers/combat.ts`:**

**CRITICAL: spawnId pre-capture before deletion block.** The combat victory section at ~line 2162 deletes EnemySpawn rows. The kill template loop at ~line 2180 iterates `enemies` and `enemyTemplates` for XP/loot/standing awards. The `enemies` array (collected at ~line 1528 via `ctx.db.combatEnemy.by_combat.filter(combat.id)`) contains `combatEnemy` rows, each of which has a `spawnId` field. However, the spawn rows are DELETED in the block at lines 2162-2178 BEFORE the kill template loop at 2180.

**Pre-capture step:** BEFORE the spawn deletion block (~line 2162), build a `Map<bigint, bigint>` mapping each combatEnemy's `spawnId` to itself:
```typescript
// Pre-capture spawnId -> spawnId map BEFORE spawn deletion block
// enemies array has combatEnemy rows with .spawnId field
const enemySpawnIds = new Map<bigint, bigint>();
for (const enemyRow of enemies) {
  enemySpawnIds.set(enemyRow.id, enemyRow.spawnId);
}
```

Then in the kill template loop (~line 2180), after `grantFactionStandingForKill`, add event contribution tracking using the pre-captured map:
```typescript
// World event contribution: check if killed enemy was an event spawn
// Use pre-captured spawnId since EnemySpawn rows are already deleted above
const capturedSpawnId = enemySpawnIds.get(enemies.find(e => e.enemyTemplateId === template.id)?.id ?? 0n);
if (capturedSpawnId) {
  for (const eventEnemy of ctx.db.eventSpawnEnemy.by_spawn.filter(capturedSpawnId)) {
    // This was an event enemy — increment contribution for this character
    for (const contrib of ctx.db.eventContribution.by_character.filter(character.id)) {
      if (contrib.eventId === eventEnemy.eventId) {
        ctx.db.eventContribution.id.update({
          ...contrib,
          count: contrib.count + 1n,
        });
        break;
      }
    }
    // Also increment kill_count objectives for this event
    for (const obj of ctx.db.eventObjective.by_event.filter(eventEnemy.eventId)) {
      if (obj.objectiveType === 'kill_count') {
        ctx.db.eventObjective.id.update({
          ...obj,
          currentCount: obj.currentCount + 1n,
        });
      }
    }
  }
}
```

**REQ-032: incrementWorldStat for combat kills.** Also in the kill template loop, after the event contribution code above, call:
```typescript
// REQ-032: Increment world stat tracker for threshold-triggered events
incrementWorldStat(ctx, 'total_enemies_killed', 1n, deps);
```
Import `incrementWorldStat` from `../helpers/world_events` at the top of the combat reducer file (or pass via deps).

**REQ-032: incrementWorldStat for quest completions.** In the quest completion handler (wherever `updateQuestProgressForKill` or equivalent marks a quest as complete), add:
```typescript
incrementWorldStat(ctx, 'total_quests_completed', 1n, deps);
```
If quest completion is in a separate reducer file, add the call there. The key is that any quest completion triggers this stat increment.

Also add a time-based event expiry check: after combat resolves, if the character is in a region with an active time-based event, call checkTimeBasedExpiry from the helper.

**In `spacetimedb/src/reducers/movement.ts`:**

In the move_character reducer, after the character's locationId is updated and region crossing is detected, add auto-registration for active world events:

```typescript
// Auto-register for active world events in destination region
const destRegionId = toLocation.regionId;
for (const event of ctx.db.worldEvent.by_region.filter(destRegionId)) {
  if (event.status !== 'active') continue;
  // Check if character already has a contribution row for this event
  let alreadyRegistered = false;
  for (const contrib of ctx.db.eventContribution.by_character.filter(character.id)) {
    if (contrib.eventId === event.id) {
      alreadyRegistered = true;
      break;
    }
  }
  if (!alreadyRegistered) {
    ctx.db.eventContribution.insert({
      id: 0n,
      eventId: event.id,
      characterId: character.id,
      count: 0n,  // zero until they interact with event content
      regionEnteredAt: ctx.timestamp,
    });
  }
}
```

This should run for ALL movement (not just cross-region) since an event might be active in the character's current region. The check for `by_region.filter(destRegionId)` handles scoping. The locationId on the destination is used to resolve regionId via the location row.

**In `spacetimedb/src/index.ts`:**

No new seeding functions needed (events are admin-fired, not pre-seeded). But ensure the new tables from Plan 01 are imported into schema correctly — the schema() export should already include them from Plan 01's task. Verify this.

**Publish and generate bindings:**

After all code changes compile:
```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```

Use `--clear-database` because new non-optional tables are being added.
  </action>
  <verify>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. `spacetime publish uwr --clear-database -y --project-path spacetimedb` succeeds
3. `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb` succeeds
4. Verify `src/module_bindings/` contains bindings for world_event, event_contribution, event_spawn_enemy, event_spawn_item, event_objective, event_despawn_tick, world_stat_tracker tables
5. Verify bindings contain fire_world_event, resolve_world_event, collect_event_item, increment_event_counter reducers
6. `spacetime logs uwr` shows no errors
7. Client compiles: `npx tsc --noEmit` (from project root)
8. Verify incrementWorldStat is called in combat kill loop with 'total_enemies_killed'
9. Verify spawnId pre-capture map is built BEFORE the spawn deletion block
  </verify>
  <done>
Combat kills of event enemies increment EventContribution count and kill_count objectives using pre-captured spawnId map (avoids stale reference after spawn deletion). Combat kills call incrementWorldStat('total_enemies_killed') for REQ-032. Quest completions call incrementWorldStat('total_quests_completed') for REQ-032. Region entry auto-registers characters for active events with count=0. Module published with --clear-database. Client bindings regenerated with all new tables (including world_stat_tracker) and reducers. One-time event guard, zero-contribution filtering, and tier-based rewards all functional through helper layer.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. Module publishes successfully to SpacetimeDB
3. Client bindings contain all 7 new table types (including world_stat_tracker) and all 5 reducer bindings
4. fire_world_event reducer rejects non-admin callers with SenderError
5. Combat kill loop checks EventSpawnEnemy.by_spawn using pre-captured spawnId map and increments contribution
6. Combat kill loop calls incrementWorldStat('total_enemies_killed', 1n) for REQ-032
7. move_character inserts EventContribution with count=0 for active events in region
8. despawn_event_content deletes spawns in correct order (members -> spawns -> event references -> items -> objectives)
9. increment_event_counter auto-resolves when threshold hit (success or failure)
10. collect_event_item marks items collected and increments contribution
11. Client TypeScript compiles
</verification>

<success_criteria>
World event system fully functional on the backend: events can be fired (admin-only), participated in (auto on region entry), contributed to (combat kills + item collection), counter-incremented (threshold race), and resolved with tiered rewards. Threshold-triggered events (REQ-032) wired via incrementWorldStat in combat kills and quest completions. Despawn scheduled for 2-minute linger. Module published and bindings generated. Ready for Plan 03 client UI.
</success_criteria>

<output>
After completion, create `.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-02-SUMMARY.md`
</output>
