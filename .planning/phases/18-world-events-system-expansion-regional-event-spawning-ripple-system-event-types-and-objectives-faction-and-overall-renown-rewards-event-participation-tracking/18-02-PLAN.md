---
phase: 18-world-events-system-expansion
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - spacetimedb/src/reducers/world_events.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/quests.ts
  - spacetimedb/src/index.ts
  - spacetimedb/src/data/world_event_data.ts
autonomous: true

must_haves:
  truths:
    - "Admin can fire a world event via fire_world_event reducer (guarded by ADMIN_IDENTITY check)"
    - "Non-admin callers are rejected by fire_world_event with SenderError"
    - "Characters can join an active world event via join_world_event reducer"
    - "Admin can manually resolve a world event via resolve_world_event reducer"
    - "Combat kills increment total_enemies_killed stat tracker (auto-fires events at threshold)"
    - "Combat kills in event regions credit event contribution for joined participants"
    - "Quest completions increment total_quests_completed stat tracker"
    - "Region adjacency and stat trackers are seeded on module init via syncAllContent"
    - "generate_event_consequence stub procedure compiles and returns placeholder text (REQ-034)"
    - "Module publishes and client bindings regenerate successfully"
  artifacts:
    - path: "spacetimedb/src/reducers/world_events.ts"
      provides: "fire_world_event (admin-guarded), join_world_event, resolve_world_event reducers, generate_event_consequence stub procedure"
      contains: "ADMIN_IDENTITY"
    - path: "spacetimedb/src/reducers/index.ts"
      provides: "registerWorldEventReducers import and call"
      contains: "registerWorldEventReducers"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "incrementWorldStat and creditEventContribution hooks after kill"
      contains: "incrementWorldStat"
    - path: "spacetimedb/src/reducers/quests.ts"
      provides: "incrementWorldStat hook after quest completion"
      contains: "incrementWorldStat"
    - path: "spacetimedb/src/data/world_event_data.ts"
      provides: "ADMIN_IDENTITY constant for admin guard"
      contains: "ADMIN_IDENTITY"
  key_links:
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "fireWorldEvent, resolveWorldEvent imports"
      pattern: "fireWorldEvent|resolveWorldEvent"
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/data/world_event_data.ts"
      via: "ADMIN_IDENTITY import for admin guard"
      pattern: "ADMIN_IDENTITY"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "incrementWorldStat, creditEventContribution imports"
      pattern: "incrementWorldStat|creditEventContribution"
    - from: "spacetimedb/src/reducers/quests.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "incrementWorldStat import"
      pattern: "incrementWorldStat"
---

<objective>
Wire the world event system into the game loop: create world event reducers (fire, join, resolve), hook combat kills and quest completions into stat tracking and event contribution, call seeding functions on module init, publish module and regenerate client bindings.

Purpose: Make the world event system functional end-to-end on the backend — events can be fired, joined, contributed to, and resolved with rewards.
Output: Working reducers, combat/quest hooks, published module, regenerated client bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-RESEARCH.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create world event reducers with admin guard and register them</name>
  <files>
    spacetimedb/src/reducers/world_events.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/data/world_event_data.ts
  </files>
  <action>
**Add ADMIN_IDENTITY constant to `spacetimedb/src/data/world_event_data.ts`:**

Append this constant at the end of the file (after the existing exports from Plan 01):

```typescript
// Admin identity hex — set to the admin player's identity (from `spacetime identity list`)
// Update this value per deployment environment.
export const ADMIN_IDENTITY = 'YOUR_ADMIN_IDENTITY_HEX_HERE';
```

The executor should run `spacetime identity list` and replace the placeholder with the actual default identity hex string.

**Create `spacetimedb/src/reducers/world_events.ts`:**

Follow the established reducer pattern from `spacetimedb/src/reducers/renown.ts` (registerXxxReducers function that takes deps).

```typescript
import { SenderError, t } from 'spacetimedb/server';
import { fireWorldEvent, resolveWorldEvent } from '../helpers/world_events';
import { EVENT_STATUS, ADMIN_IDENTITY } from '../data/world_event_data';

export function registerWorldEventReducers(deps: any) {
  const { spacetimedb } = deps;

  // REQ-031: Admin-triggered world events — guarded by ADMIN_IDENTITY check
  spacetimedb.reducer('fire_world_event', {
    eventType: t.string(),
    targetId: t.string(),
    regionName: t.string().optional(),
    objectiveTarget: t.u64().optional(),
    rewardRenown: t.u64().optional(),
    rewardFactionId: t.u64().optional(),
    rewardFactionStanding: t.i64().optional(),
  }, (ctx: any, args: any) => {
    // REQ-031: Admin guard — reject non-admin callers
    if (ctx.sender.toHex() !== ADMIN_IDENTITY) {
      throw new SenderError('Admin only');
    }

    // Resolve region name to ID if provided
    let regionId: bigint | undefined;
    if (args.regionName) {
      for (const region of ctx.db.region.iter()) {
        if (region.name === args.regionName) {
          regionId = region.id;
          break;
        }
      }
      if (!regionId) throw new SenderError(`Region not found: ${args.regionName}`);
    }

    fireWorldEvent(ctx, args.eventType, args.targetId, 'admin', regionId, {
      objectiveTarget: args.objectiveTarget,
      rewardRenown: args.rewardRenown,
      rewardFactionId: args.rewardFactionId,
      rewardFactionStanding: args.rewardFactionStanding,
    });
  });

  // Join an active world event
  spacetimedb.reducer('join_world_event', {
    worldEventId: t.u64(),
    characterId: t.u64(),
  }, (ctx: any, args: any) => {
    const event = ctx.db.worldEvent.id.find(args.worldEventId);
    if (!event) throw new SenderError('Event not found');
    if (event.status !== EVENT_STATUS.FIRED) throw new SenderError('Event is not active');

    const character = ctx.db.character.id.find(args.characterId);
    if (!character) throw new SenderError('Character not found');

    // Verify ownership
    const player = ctx.db.player.id.find(ctx.sender);
    if (!player || character.ownerUserId !== player.userId) {
      throw new SenderError('Not your character');
    }

    // Check if already joined (use by_character index + manual filter)
    for (const p of ctx.db.worldEventParticipant.by_character.filter(args.characterId)) {
      if (p.worldEventId === args.worldEventId) {
        throw new SenderError('Already joined this event');
      }
    }

    ctx.db.worldEventParticipant.insert({
      id: 0n,
      worldEventId: args.worldEventId,
      characterId: args.characterId,
      joinedAt: ctx.timestamp,
      contribution: 0n,
    });
  });

  // Manually resolve a world event (admin or testing)
  spacetimedb.reducer('resolve_world_event', {
    worldEventId: t.u64(),
  }, (ctx: any, args: any) => {
    const event = ctx.db.worldEvent.id.find(args.worldEventId);
    if (!event) throw new SenderError('Event not found');
    if (event.status !== EVENT_STATUS.FIRED) throw new SenderError('Event already resolved');
    resolveWorldEvent(ctx, event);
  });
}
```

**In `spacetimedb/src/reducers/index.ts`:**

Add import and registration call following the existing pattern:

1. Add import: `import { registerWorldEventReducers } from './world_events';`
2. Add call inside `registerReducers`: `registerWorldEventReducers(deps);`

Place both after the existing `registerRenownReducers` line.
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — no errors. Confirm `world_events.ts` exports `registerWorldEventReducers`. Confirm `index.ts` imports and calls it. Confirm `world_event_data.ts` exports `ADMIN_IDENTITY`. Confirm `fire_world_event` reducer body contains the admin guard check.
  </verify>
  <done>
3 world event reducers registered (fire_world_event, join_world_event, resolve_world_event). ADMIN_IDENTITY constant added to world_event_data.ts. fire_world_event guarded by ctx.sender.toHex() !== ADMIN_IDENTITY check (REQ-031). Reducer registration follows established pattern. Admin fire uses region name resolution (not hardcoded IDs). Join validates ownership and prevents duplicate participation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook combat and quest reducers, wire seeding, publish module</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/quests.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**In `spacetimedb/src/reducers/combat.ts`:**

Add two hooks in the combat victory kill loop — the section where `grantFactionStandingForKill` is called (after XP grant, for each living participant per killed enemy). Find the existing `grantFactionStandingForKill(ctx, character, template.id);` call site.

1. Add import at top: `import { incrementWorldStat, creditEventContribution } from '../helpers/world_events';`

2. Add two lines immediately after the existing `grantFactionStandingForKill` call:
```typescript
// World event hooks
incrementWorldStat(ctx, 'total_enemies_killed', 1n);
// Credit event contribution if character is in an active event in this region
const charLocation = ctx.db.location.id.find(character.locationId);
if (charLocation) {
  creditEventContribution(ctx, character.id, charLocation.regionId, 1n);
}
```

Note: `character.locationId` must be resolved to `Location.regionId` via a lookup. The location lookup is necessary because the combat reducer has access to character (which has locationId) but not regionId directly.

**In `spacetimedb/src/reducers/quests.ts`:**

Add stat tracking hook in the quest completion path. Find where quest completion rewards are granted (the section that awards XP and completes the quest).

1. Add import at top: `import { incrementWorldStat } from '../helpers/world_events';`

2. After the quest completion XP/reward grant, add:
```typescript
// World event stat tracking
incrementWorldStat(ctx, 'total_quests_completed', 1n);
```

Place this call ONCE in the completion path, not per quest type. The quest completion function that updates quest status to 'completed' is the right location.

**In `spacetimedb/src/index.ts`:**

Add calls to the new seeding functions in `syncAllContent` (the function called on module init that invokes all ensure/seed functions).

1. Add import: `import { seedRegionAdjacency, ensureWorldStatTrackers } from './seeding/ensure_world';`
   (If this import path already partially exists, extend it.)

2. Add calls at the end of `syncAllContent` (after existing seeding calls):
```typescript
seedRegionAdjacency(ctx);
ensureWorldStatTrackers(ctx);
```

**Publish and generate bindings:**

After all code changes compile:
```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```

Use `--clear-database` because new non-optional tables are being added (WorldEvent, WorldStatTracker, WorldEventParticipant, RegionAdjacency).
  </action>
  <verify>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. `spacetime publish uwr --clear-database -y --project-path spacetimedb` succeeds
3. `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb` succeeds
4. Verify `src/module_bindings/` contains `world_event_table.ts`, `world_stat_tracker_table.ts`, `world_event_participant_table.ts`, `region_adjacency_table.ts`
5. Verify `spacetime logs uwr` shows no errors and seedRegionAdjacency/ensureWorldStatTrackers ran
6. Client compiles: `npx tsc --noEmit` (from project root)
  </verify>
  <done>
Combat kills increment total_enemies_killed stat tracker and credit event contribution. Quest completions increment total_quests_completed. Region adjacency and stat trackers seeded on module init. Module published with --clear-database. Client bindings regenerated with all 4 new tables and 3 new reducers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register generate_event_consequence stub procedure (REQ-034)</name>
  <files>
    spacetimedb/src/reducers/world_events.ts
  </files>
  <action>
**In `spacetimedb/src/reducers/world_events.ts`:**

Add the `generate_event_consequence` stub procedure inside the `registerWorldEventReducers` function, after the existing reducer registrations. This is a SpacetimeDB procedure (not a reducer) because REQ-034 requires LLM-generated text which needs HTTP access. For now, stub with a static placeholder string to validate the procedure API compiles and publishes.

```typescript
  // REQ-034: LLM-generated consequence text (stub — returns placeholder)
  // Procedures can make HTTP calls; reducers cannot. Stub validates the API.
  // Replace with real LLM call in a follow-up task.
  spacetimedb.procedure(
    'generate_event_consequence',
    { worldEventId: t.u64() },
    t.string(),
    (ctx: any, { worldEventId }: any) => {
      const placeholder = `The world trembles as event ${worldEventId} reshapes fate.`;
      ctx.withTx((tx: any) => {
        // Append the consequence text as a world event log entry
        const { appendWorldEvent } = require('../helpers/events');
        appendWorldEvent(tx, 'world_event', placeholder);
      });
      return placeholder;
    }
  );
```

**Important implementation note:** If `spacetimedb.procedure` is not available on the `spacetimedb` object passed via `deps`, register the procedure at the module level using the imported `spacetimedb` from `schema.ts` instead. Check the pattern used in `src/index.ts` for how the spacetimedb instance is accessed. The procedure should be registered alongside reducers but may need to use the schema-level spacetimedb export directly.

**Alternative if `require` doesn't work in procedure context:** Import `appendWorldEvent` at the top of the file (already imported in the planned code) and use it inside `ctx.withTx`:

```typescript
  spacetimedb.procedure(
    'generate_event_consequence',
    { worldEventId: t.u64() },
    t.string(),
    (ctx: any, { worldEventId }: any) => {
      const placeholder = `The world trembles as event ${worldEventId} reshapes fate.`;
      return placeholder;
    }
  );
```

Use the simpler version (no DB write) if `ctx.withTx` causes issues. The key requirement is that the procedure compiles, publishes, and returns the placeholder string.

**Republish and regenerate after adding the procedure:**

```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```
  </action>
  <verify>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. `spacetime publish uwr --clear-database -y --project-path spacetimedb` succeeds
3. `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb` succeeds
4. Verify `spacetime logs uwr` shows no procedure registration errors
5. Client bindings include `generate_event_consequence` procedure binding
  </verify>
  <done>
generate_event_consequence stub procedure registered, compiles, publishes, and returns placeholder text. REQ-034 covered with stub-first approach per RESEARCH.md recommendation. Ready for real LLM wiring in a follow-up phase.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. Module publishes successfully to SpacetimeDB
3. Client bindings contain world_event, world_stat_tracker, world_event_participant, region_adjacency tables
4. Client bindings contain fire_world_event, join_world_event, resolve_world_event reducers
5. Client bindings contain generate_event_consequence procedure
6. `spacetime logs uwr` shows seeding ran without errors and no procedure registration errors
7. Client TypeScript compiles
8. fire_world_event reducer rejects non-admin callers with SenderError
9. ADMIN_IDENTITY constant exists in world_event_data.ts
</verification>

<success_criteria>
World event system fully functional on the backend: events can be fired (admin-only, guarded by ADMIN_IDENTITY), joined (players), contributed to (via combat kills in event regions), and resolved (auto via objective or manual). Stat trackers increment on combat/quest completion and auto-fire events at thresholds. Ripple cascading works. generate_event_consequence stub procedure compiles and returns placeholder text (REQ-034). Module published and bindings generated. Ready for Plan 03 client UI.
</success_criteria>

<output>
After completion, create `.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-02-SUMMARY.md`
</output>
