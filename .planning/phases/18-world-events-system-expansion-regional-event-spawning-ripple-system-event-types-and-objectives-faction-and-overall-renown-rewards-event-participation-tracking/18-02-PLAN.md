---
phase: 18-world-events-system-expansion
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - spacetimedb/src/reducers/world_events.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/movement.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can fire a world event via fire_world_event reducer (guarded by ADMIN_IDENTITIES check)"
    - "Non-admin callers are rejected by fire_world_event with SenderError"
    - "Admin can resolve a world event via resolve_world_event reducer specifying outcome"
    - "Combat kills of event enemies increment EventContribution count for the killing character"
    - "Characters entering a region with an active event automatically get an EventContribution row with count=0"
    - "collect_event_item reducer lets players collect event-spawned items and increments contribution"
    - "despawn_event_content scheduled reducer deletes EnemySpawn, EnemySpawnMember, EventSpawnEnemy, EventSpawnItem, EventObjective rows for the event"
    - "increment_event_counter reducer updates threshold race counters and auto-resolves when threshold hit"
    - "Module publishes and client bindings regenerate successfully"
    - "One-time events cannot be fired again after resolution"
  artifacts:
    - path: "spacetimedb/src/reducers/world_events.ts"
      provides: "fire_world_event, resolve_world_event, collect_event_item, increment_event_counter reducers, despawn_event_content scheduled reducer"
      contains: "fire_world_event"
    - path: "spacetimedb/src/reducers/index.ts"
      provides: "registerWorldEventReducers import and call"
      contains: "registerWorldEventReducers"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "Event enemy kill contribution hook"
      contains: "eventSpawnEnemy"
    - path: "spacetimedb/src/reducers/movement.ts"
      provides: "Region entry auto-registration for active world events"
      contains: "eventContribution"
  key_links:
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "fireWorldEvent, resolveWorldEvent imports"
      pattern: "fireWorldEvent|resolveWorldEvent"
    - from: "spacetimedb/src/reducers/world_events.ts"
      to: "spacetimedb/src/data/world_event_data.ts"
      via: "ADMIN_IDENTITIES import for admin guard"
      pattern: "ADMIN_IDENTITIES"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "EventSpawnEnemy table lookup after kill to detect event enemies"
      pattern: "eventSpawnEnemy"
    - from: "spacetimedb/src/reducers/movement.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "WorldEvent and EventContribution tables for auto-registration"
      pattern: "worldEvent"
---

<objective>
Wire the world event system into the game loop: create world event reducers (fire, resolve, collect, counter increment, despawn), hook combat kills to credit event contribution, hook region entry in movement to auto-register participants, publish module and regenerate client bindings.

Purpose: Make the world event system functional end-to-end on the backend — events can be fired, participated in, contributed to, resolved with tiered rewards, and cleaned up after linger.
Output: Working reducers, combat/movement hooks, published module, regenerated client bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-CONTEXT.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-RESEARCH.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-01-SUMMARY.md

Key existing files:
@spacetimedb/src/reducers/index.ts — DI deps pattern, registerXxxReducers calls
@spacetimedb/src/reducers/combat.ts — Kill loop where grantFactionStandingForKill is called
@spacetimedb/src/reducers/movement.ts — move_character reducer, region crossing detection
@spacetimedb/src/index.ts — syncAllContent seeding, spacetimedb.init
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create world event reducers with admin guard and despawn</name>
  <files>
    spacetimedb/src/reducers/world_events.ts
    spacetimedb/src/reducers/index.ts
  </files>
  <action>
**CRITICAL CONTEXT DECISIONS:**
- Joining is automatic on region entry (handled in Task 2 via movement hook)
- Rewards only if contributed (count > 0) — enforced by helpers from Plan 01
- Admin guard uses ADMIN_IDENTITIES set (ctx.sender.toHexString())
- despawn_event_content cleans up EnemySpawn + EnemySpawnMember BEFORE EventSpawnEnemy (prevent ghost spawns)

**Create `spacetimedb/src/reducers/world_events.ts`:**

Follow the established registerXxxReducers(deps) pattern from other reducer files.

```typescript
export function registerWorldEventReducers(deps: any) {
  const { spacetimedb, t, SenderError, ScheduleAt } = deps;
```

Register these reducers inside the function:

1. **fire_world_event** reducer — Admin fires event by eventKey:
   - Parameters: `{ eventKey: t.string() }`
   - Admin guard: `if (!ADMIN_IDENTITIES.has(ctx.sender.toHexString())) throw new SenderError('Admin only');`
   - Import and call `fireWorldEvent(ctx, eventKey, deps)` from helpers
   - fireWorldEvent already handles one-time event guard, spawning, and log entry

2. **resolve_world_event** reducer — Admin resolves an active event:
   - Parameters: `{ worldEventId: t.u64(), outcome: t.string() }`
   - Admin guard same as above
   - Validate outcome is 'success' or 'failure'
   - Look up event by id, validate status === 'active'
   - Call `resolveWorldEvent(ctx, event, outcome, deps)` from helpers

3. **collect_event_item** reducer — Player collects an event-spawned item:
   - Parameters: `{ eventSpawnItemId: t.u64(), characterId: t.u64() }`
   - Validate character ownership via ctx.sender
   - Find EventSpawnItem row, validate not already collected
   - Validate character is at the item's locationId
   - Mark collected=true, set collectedByCharacterId
   - Increment EventContribution count for this character + eventId
   - Check if all event items collected or objective hit, potentially auto-resolve for objective events

4. **increment_event_counter** reducer — Used by combat/objective hooks for threshold race:
   - Parameters: `{ eventId: t.u64(), side: t.string(), amount: t.u64() }`
   - side must be 'success' or 'failure'
   - Look up WorldEvent, validate active
   - Increment successCounter or failureCounter
   - Check if threshold hit: if successCounter >= successThreshold, resolve as success; if failureCounter >= failureThreshold, resolve as failure
   - First threshold hit wins (check both after increment)

5. **despawn_event_content** scheduled reducer — Cleans up event spawns after 2-minute linger:
   - Parameters: `{ arg: EventDespawnTick.rowType }` (following scheduled reducer pattern)
   - For each EventSpawnEnemy with eventId: collect spawnId, delete EnemySpawnMember rows via by_spawn index, delete EnemySpawn row, then delete EventSpawnEnemy row
   - IMPORTANT: If any spawn has an active CombatEncounter at its location, check if combat involves that spawn. If combat is active, either skip that spawn or force-resolve. Safer to skip and let combat resolve naturally.
   - Delete all EventSpawnItem rows for eventId
   - Delete all EventObjective rows for eventId
   - Delete all EventContribution rows for eventId (cleanup)

**In `spacetimedb/src/reducers/index.ts`:**

1. Add import: `import { registerWorldEventReducers } from './world_events';`
2. Add the EventDespawnTick scheduled table to the deps object (it needs to be passed for the scheduled reducer)
3. Add call: `registerWorldEventReducers(deps);` after existing reducer registrations
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — no errors. Confirm world_events.ts exports registerWorldEventReducers. Confirm index.ts imports and calls it. Confirm fire_world_event has ADMIN_IDENTITIES guard. Confirm despawn_event_content deletes in correct order (EnemySpawnMember -> EnemySpawn -> EventSpawnEnemy, then EventSpawnItem, EventObjective).
  </verify>
  <done>
5 world event reducers registered: fire_world_event (admin-guarded), resolve_world_event (admin-guarded), collect_event_item (player), increment_event_counter (internal), despawn_event_content (scheduled). All follow DI pattern. Admin guard uses ADMIN_IDENTITIES set. Despawn cleans up in safe order.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook combat kills and movement for event participation, publish module</name>
  <files>
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/movement.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**CRITICAL CONTEXT DECISIONS:**
- Participation is automatic on region entry — character in region while event is active gets EventContribution row
- Rewards only if interacted (count > 0) — region entry creates row with count=0
- Combat kills of event-specific enemies increment contribution count

**In `spacetimedb/src/reducers/combat.ts`:**

Add event enemy kill contribution tracking in the combat victory kill loop — the section where `grantFactionStandingForKill` is called, for each killed enemy per living participant.

After the existing faction standing call, add:
```typescript
// World event contribution: check if killed enemy was an event spawn
for (const eventEnemy of ctx.db.eventSpawnEnemy.by_spawn.filter(/* the killed enemy's spawnId */)) {
  // This was an event enemy — increment contribution for the killing character
  for (const contrib of ctx.db.eventContribution.by_character.filter(character.id)) {
    if (contrib.eventId === eventEnemy.eventId) {
      ctx.db.eventContribution.id.update({
        ...contrib,
        count: contrib.count + 1n,
      });
      break;
    }
  }
  // Also increment kill_count objectives for this event
  for (const obj of ctx.db.eventObjective.by_event.filter(eventEnemy.eventId)) {
    if (obj.objectiveType === 'kill_count') {
      ctx.db.eventObjective.id.update({
        ...obj,
        currentCount: obj.currentCount + 1n,
      });
    }
  }
}
```

The key challenge: identifying the spawnId for the killed enemy. In the combat kill loop, find the spawnId by looking at the CombatEncounter or EnemySpawn rows for the killed enemy. Check the existing combat code to find how the enemy spawn is tracked — likely via combatEnemy.spawnId or similar. Use the available spawn reference to query EventSpawnEnemy.by_spawn.

Also add a time-based event expiry check: after combat resolves, if the character is in a region with an active time-based event, call checkTimeBasedExpiry from the helper.

**In `spacetimedb/src/reducers/movement.ts`:**

In the move_character reducer, after the character's locationId is updated and region crossing is detected, add auto-registration for active world events:

```typescript
// Auto-register for active world events in destination region
const destRegionId = toLocation.regionId;
for (const event of ctx.db.worldEvent.by_region.filter(destRegionId)) {
  if (event.status !== 'active') continue;
  // Check if character already has a contribution row for this event
  let alreadyRegistered = false;
  for (const contrib of ctx.db.eventContribution.by_character.filter(character.id)) {
    if (contrib.eventId === event.id) {
      alreadyRegistered = true;
      break;
    }
  }
  if (!alreadyRegistered) {
    ctx.db.eventContribution.insert({
      id: 0n,
      eventId: event.id,
      characterId: character.id,
      count: 0n,  // zero until they interact with event content
      regionEnteredAt: ctx.timestamp,
    });
  }
}
```

This should run for ALL movement (not just cross-region) since an event might be active in the character's current region. The check for `by_region.filter(destRegionId)` handles scoping. The locationId on the destination is used to resolve regionId via the location row.

**In `spacetimedb/src/index.ts`:**

No new seeding functions needed (events are admin-fired, not pre-seeded). But ensure the new tables from Plan 01 are imported into schema correctly — the schema() export should already include them from Plan 01's task. Verify this.

**Publish and generate bindings:**

After all code changes compile:
```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```

Use `--clear-database` because new non-optional tables are being added.
  </action>
  <verify>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. `spacetime publish uwr --clear-database -y --project-path spacetimedb` succeeds
3. `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb` succeeds
4. Verify `src/module_bindings/` contains bindings for world_event, event_contribution, event_spawn_enemy, event_spawn_item, event_objective, event_despawn_tick tables
5. Verify bindings contain fire_world_event, resolve_world_event, collect_event_item, increment_event_counter reducers
6. `spacetime logs uwr` shows no errors
7. Client compiles: `npx tsc --noEmit` (from project root)
  </verify>
  <done>
Combat kills of event enemies increment EventContribution count and kill_count objectives. Region entry auto-registers characters for active events with count=0. Module published with --clear-database. Client bindings regenerated with all new tables and reducers. One-time event guard, zero-contribution filtering, and tier-based rewards all functional through helper layer.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes
2. Module publishes successfully to SpacetimeDB
3. Client bindings contain all 6 new table types and all 5 reducer bindings
4. fire_world_event reducer rejects non-admin callers with SenderError
5. Combat kill loop checks EventSpawnEnemy.by_spawn and increments contribution
6. move_character inserts EventContribution with count=0 for active events in region
7. despawn_event_content deletes spawns in correct order (members -> spawns -> event references -> items -> objectives)
8. increment_event_counter auto-resolves when threshold hit (success or failure)
9. collect_event_item marks items collected and increments contribution
10. Client TypeScript compiles
</verification>

<success_criteria>
World event system fully functional on the backend: events can be fired (admin-only), participated in (auto on region entry), contributed to (combat kills + item collection), counter-incremented (threshold race), and resolved with tiered rewards. Despawn scheduled for 2-minute linger. Module published and bindings generated. Ready for Plan 03 client UI.
</success_criteria>

<output>
After completion, create `.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-02-SUMMARY.md`
</output>
