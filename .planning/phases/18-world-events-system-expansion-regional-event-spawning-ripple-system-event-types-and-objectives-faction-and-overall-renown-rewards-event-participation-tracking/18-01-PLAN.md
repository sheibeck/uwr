---
phase: 18-world-events-system-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/schema/scheduled_tables.ts
  - spacetimedb/src/data/world_event_data.ts
  - spacetimedb/src/helpers/world_events.ts
autonomous: true

must_haves:
  truths:
    - "WorldEvent table stores persistent event records with both successConsequenceType AND failureConsequenceType"
    - "EventContribution table tracks per-character engagement count for Bronze/Silver/Gold tier determination"
    - "EventSpawnEnemy and EventSpawnItem tables hold event-exclusive spawned content tagged with eventId"
    - "EventObjective table tracks event objectives (protect_npc, kill_count, explore)"
    - "EventDespawnTick scheduled table enables 2-minute post-resolve content linger"
    - "World event data constants define at least 2 events with tier thresholds, success/failure rewards, and consequence types"
    - "resolveWorldEvent helper awards tiered rewards (Bronze/Silver/Gold) immediately on resolve"
    - "Zero-contribution participants receive no rewards"
    - "applyConsequence handles both success and failure consequences via switch on consequenceType"
    - "One-time events are permanently locked after resolution (cannot fire again)"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "WorldEvent, EventContribution, EventSpawnEnemy, EventSpawnItem, EventObjective table definitions"
      contains: "world_event"
    - path: "spacetimedb/src/schema/scheduled_tables.ts"
      provides: "EventDespawnTick scheduled table definition"
      contains: "event_despawn_tick"
    - path: "spacetimedb/src/data/world_event_data.ts"
      provides: "WORLD_EVENT_DEFINITIONS, ADMIN_IDENTITIES, RewardSpec, TierSpec, WorldEventDefinition types"
      contains: "WORLD_EVENT_DEFINITIONS"
    - path: "spacetimedb/src/helpers/world_events.ts"
      provides: "fireWorldEvent, resolveWorldEvent, applyConsequence, awardEventRewards, spawnEventContent helpers"
      contains: "resolveWorldEvent"
  key_links:
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/renown.ts"
      via: "awardRenown import for tiered renown rewards"
      pattern: "awardRenown"
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/economy.ts"
      via: "mutateStanding import for faction standing rewards"
      pattern: "mutateStanding"
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/events.ts"
      via: "appendWorldEvent import for log entries"
      pattern: "appendWorldEvent"
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/data/world_event_data.ts"
      via: "WORLD_EVENT_DEFINITIONS import for event firing"
      pattern: "WORLD_EVENT_DEFINITIONS"
---

<objective>
Build the backend foundation for the World Events System: 6 new database tables (WorldEvent, EventContribution, EventSpawnEnemy, EventSpawnItem, EventObjective, EventDespawnTick), event data constants with Bronze/Silver/Gold tier reward specs and success/failure consequence types, and helper functions for the full event lifecycle (fire, resolve, reward, consequence, spawn, despawn scheduling).

Purpose: Provide the data layer and business logic that reducers and combat/travel hooks will wire into in Plan 02.
Output: Tables defined in schema, helpers exported and callable, data constants with at least 2 event definitions.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-CONTEXT.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-RESEARCH.md

Key existing files:
@spacetimedb/src/schema/tables.ts — Add 5 new tables, include in schema() export
@spacetimedb/src/schema/scheduled_tables.ts — Add EventDespawnTick, include in schema() export
@spacetimedb/src/helpers/events.ts — appendWorldEvent, appendPrivateEvent helpers
@spacetimedb/src/helpers/renown.ts — awardRenown(ctx, character, points, reason) for tiered renown
@spacetimedb/src/helpers/economy.ts — mutateStanding(ctx, characterId, factionId, delta) for faction standing
@spacetimedb/src/helpers/items.ts — addItemToInventory for event loot rewards
@spacetimedb/src/data/renown_data.ts — RENOWN_GAIN constants
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define 6 new tables and create event data constants</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/schema/scheduled_tables.ts
    spacetimedb/src/data/world_event_data.ts
  </files>
  <action>
**CRITICAL CONTEXT DECISIONS (from 18-CONTEXT.md — honor exactly):**
- "Ripple" = permanent world state consequences on resolve, NOT geographic cascade
- NO RegionAdjacency table (wrong design from prior plans)
- Events are self-contained with exclusive spawned content (EventSpawnEnemy, EventSpawnItem)
- Every event has BOTH successConsequenceType AND failureConsequenceType
- Contribution tiers: Bronze/Silver/Gold with fixed rewards per tier
- Failure darkens the world but NEVER breaks playability
- One-time events locked permanently after resolve
- Failure conditions: time-based OR two-sided threshold race
- Event spawns linger ~2 minutes after resolve (EventDespawnTick)

**In `spacetimedb/src/schema/tables.ts`:**

Add 5 new tables BEFORE the `schema()` export call. Follow existing table definition patterns.

1. **WorldEvent** table — persistent event lifecycle record with dual consequence types:
```typescript
export const WorldEvent = table(
  {
    name: 'world_event',
    public: true,
    indexes: [
      { name: 'by_status', algorithm: 'btree', columns: ['status'] },
      { name: 'by_region', algorithm: 'btree', columns: ['regionId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventKey: t.string(),                    // data constant key, e.g. 'ashen_awakening'
    name: t.string(),                        // display name
    regionId: t.u64(),                       // region this event is scoped to
    status: t.string(),                      // 'active' | 'success' | 'failed'
    isRecurring: t.bool(),                   // one-time (default) vs recurring
    firedAt: t.timestamp(),
    resolvedAt: t.timestamp().optional(),

    // Failure condition type
    failureConditionType: t.string(),        // 'time' | 'threshold_race'

    // Time-based failure: event deadline as microseconds since epoch
    deadlineAtMicros: t.u64().optional(),

    // Two-sided threshold race counters
    successThreshold: t.u64().optional(),    // e.g. players must save 10 villagers
    failureThreshold: t.u64().optional(),    // e.g. enemies kill 5 villagers
    successCounter: t.u64().optional(),      // current success-side count
    failureCounter: t.u64().optional(),      // current failure-side count

    // Consequences — BOTH success AND failure (locked decision)
    successConsequenceType: t.string(),      // 'race_unlock' | 'enemy_composition_change' | 'faction_standing_bonus' | 'none'
    successConsequencePayload: t.string(),   // JSON or key string
    failureConsequenceType: t.string(),      // same types as success
    failureConsequencePayload: t.string(),

    // Reward specs per tier as JSON: { bronze: {...}, silver: {...}, gold: {...} }
    rewardTiersJson: t.string(),

    // Consequence text (written at resolve time)
    consequenceText: t.string().optional(),
  }
);
```

2. **EventContribution** table — per-character engagement for Bronze/Silver/Gold tier:
```typescript
export const EventContribution = table(
  {
    name: 'event_contribution',
    public: true,
    indexes: [
      { name: 'by_event', algorithm: 'btree', columns: ['eventId'] },
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventId: t.u64(),
    characterId: t.u64(),
    count: t.u64(),                 // meaningful interactions count; 0 = registered but no reward
    regionEnteredAt: t.timestamp(),
  }
);
```

3. **EventSpawnEnemy** table — event-exclusive enemies tagged with eventId:
```typescript
export const EventSpawnEnemy = table(
  {
    name: 'event_spawn_enemy',
    public: true,
    indexes: [
      { name: 'by_event', algorithm: 'btree', columns: ['eventId'] },
      { name: 'by_spawn', algorithm: 'btree', columns: ['spawnId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventId: t.u64(),
    spawnId: t.u64(),      // FK to EnemySpawn.id
    locationId: t.u64(),
  }
);
```

4. **EventSpawnItem** table — event-exclusive collectible items:
```typescript
export const EventSpawnItem = table(
  {
    name: 'event_spawn_item',
    public: true,
    indexes: [
      { name: 'by_event', algorithm: 'btree', columns: ['eventId'] },
      { name: 'by_location', algorithm: 'btree', columns: ['locationId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventId: t.u64(),
    locationId: t.u64(),
    name: t.string(),
    collected: t.bool(),
    collectedByCharacterId: t.u64().optional(),
  }
);
```

5. **EventObjective** table — protect/explore/kill-count objectives:
```typescript
export const EventObjective = table(
  {
    name: 'event_objective',
    public: true,
    indexes: [
      { name: 'by_event', algorithm: 'btree', columns: ['eventId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventId: t.u64(),
    objectiveType: t.string(),   // 'protect_npc' | 'explore' | 'kill_count'
    locationId: t.u64(),
    name: t.string(),
    targetCount: t.u64(),
    currentCount: t.u64(),
    isAlive: t.bool().optional(), // for protect_npc objectives
  }
);
```

Add ALL 5 tables to the `schema()` export call at the bottom of tables.ts.

**In `spacetimedb/src/schema/scheduled_tables.ts`:**

Add EventDespawnTick scheduled table (follows existing PullTick/ResourceGatherTick pattern):
```typescript
export const EventDespawnTick = table(
  {
    name: 'event_despawn_tick',
    scheduled: 'despawn_event_content',
  },
  {
    scheduledId: t.u64().primaryKey().autoInc(),
    scheduledAt: t.scheduleAt(),
    eventId: t.u64(),
  }
);
```

Add EventDespawnTick to the schema() export at the bottom of scheduled_tables.ts.

**Create new file `spacetimedb/src/data/world_event_data.ts`:**

Define types, admin guard, and at least 2 event definitions with full tier reward specs:

```typescript
// Types
export type RewardSpec = {
  renown: number;
  gold: number;
  factionId: number | null;
  factionAmount: number;
  itemTemplateKey: string | null;
};

export type TierSpec = {
  threshold: number;       // contribution count needed for this tier
  success: RewardSpec;
  failure: RewardSpec;     // consolation reward for participants in failed event
};

export type WorldEventDefinition = {
  name: string;
  regionKey: string;              // region name for ID resolution at fire time
  isRecurring: boolean;
  failureConditionType: 'time' | 'threshold_race';
  durationMicros?: bigint;          // for time-based failure
  successThreshold?: bigint;        // for threshold_race
  failureThreshold?: bigint;
  successConsequenceType: string;
  successConsequencePayload: string;
  failureConsequenceType: string;
  failureConsequencePayload: string;
  rewardTiers: { bronze: TierSpec; silver: TierSpec; gold: TierSpec };
  contentLocations: Array<{
    locationKey: string;            // location name for ID resolution
    enemies: Array<{ enemyTemplateKey: string; count: number }>;
    items: Array<{ name: string; count: number }>;
  }>;
};

// Admin identity hex strings — set to admin player identities
// Run: spacetime identity list — to find your hex
export const ADMIN_IDENTITIES = new Set<string>([
  // Add admin identity hex strings here
]);

// Event definitions
export const WORLD_EVENT_DEFINITIONS: Record<string, WorldEventDefinition> = {
  ashen_awakening: {
    name: 'The Ashen Awakening',
    regionKey: 'Embermarch Depths',
    isRecurring: false,
    failureConditionType: 'time',
    durationMicros: 3_600_000_000n, // 1 hour
    successConsequenceType: 'race_unlock',
    successConsequencePayload: 'Hollowed',
    failureConsequenceType: 'enemy_composition_change',
    failureConsequencePayload: JSON.stringify({ regionKey: 'Embermarch Depths', note: 'Darker enemies spawn' }),
    rewardTiers: {
      bronze: {
        threshold: 1,
        success: { renown: 50, gold: 100, factionId: null, factionAmount: 0, itemTemplateKey: null },
        failure: { renown: 10, gold: 20, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
      silver: {
        threshold: 5,
        success: { renown: 150, gold: 300, factionId: 3, factionAmount: 25, itemTemplateKey: null },
        failure: { renown: 25, gold: 50, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
      gold: {
        threshold: 15,
        success: { renown: 400, gold: 750, factionId: 3, factionAmount: 75, itemTemplateKey: null },
        failure: { renown: 60, gold: 100, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
    },
    contentLocations: [
      {
        locationKey: 'Charred Basin',
        enemies: [{ enemyTemplateKey: 'Ash Jackal', count: 3 }],
        items: [{ name: 'Ashen Shard', count: 4 }],
      },
    ],
  },

  hollowmere_siege: {
    name: 'The Hollowmere Siege',
    regionKey: 'Hollowmere Vale',
    isRecurring: false,
    failureConditionType: 'threshold_race',
    successThreshold: 20n,   // players must kill 20 invaders
    failureThreshold: 10n,   // enemies kill 10 villagers (tracked via EventObjective)
    successConsequenceType: 'faction_standing_bonus',
    successConsequencePayload: JSON.stringify({ factionId: 1, amount: 50 }),
    failureConsequenceType: 'none',
    failureConsequencePayload: '',
    rewardTiers: {
      bronze: {
        threshold: 1,
        success: { renown: 30, gold: 75, factionId: 1, factionAmount: 10, itemTemplateKey: null },
        failure: { renown: 5, gold: 15, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
      silver: {
        threshold: 8,
        success: { renown: 100, gold: 200, factionId: 1, factionAmount: 30, itemTemplateKey: null },
        failure: { renown: 15, gold: 30, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
      gold: {
        threshold: 20,
        success: { renown: 250, gold: 500, factionId: 1, factionAmount: 75, itemTemplateKey: null },
        failure: { renown: 40, gold: 75, factionId: null, factionAmount: 0, itemTemplateKey: null },
      },
    },
    contentLocations: [
      {
        locationKey: 'Bogfen Hollow',
        enemies: [{ enemyTemplateKey: 'Bog Lurker', count: 4 }],
        items: [{ name: 'Siege Supply Crate', count: 3 }],
      },
    ],
  },
};
```
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — no type errors in tables.ts, scheduled_tables.ts, or world_event_data.ts. Confirm all 5 tables + EventDespawnTick appear in their respective `schema()` calls. Confirm WorldEvent table has BOTH successConsequenceType AND failureConsequenceType columns. Confirm NO RegionAdjacency table exists anywhere.
  </verify>
  <done>
6 new tables defined (WorldEvent with dual consequence types, EventContribution with count for tier tracking, EventSpawnEnemy, EventSpawnItem, EventObjective, EventDespawnTick scheduled). Event data constants file exists with types, admin guard, and 2 event definitions (time-based and threshold-race) with Bronze/Silver/Gold tier reward specs and both success/failure consequences. No RegionAdjacency table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create world event helper functions for full lifecycle</name>
  <files>
    spacetimedb/src/helpers/world_events.ts
  </files>
  <action>
**Create new file `spacetimedb/src/helpers/world_events.ts`:**

This is the core business logic for the world event lifecycle. Import from existing helpers — do NOT re-implement renown, standing, or item logic. Uses the DI pattern where ctx is passed through.

The helpers MUST honor these locked decisions:
- resolveWorldEvent MUST apply BOTH success AND failure consequences via applyConsequence switch
- awardEventRewards MUST use Bronze/Silver/Gold tiers with fixed per-tier rewards
- Zero-contribution (count === 0n) participants MUST receive NO rewards
- Success rewards are larger; failure rewards are consolation (both specified in data)
- One-time events (isRecurring === false) MUST be checked before re-firing
- Event spawns get a 2-minute despawn schedule via EventDespawnTick

Implement these exported functions:

1. **fireWorldEvent(ctx, eventKey, deps)** — Look up eventKey in WORLD_EVENT_DEFINITIONS. Resolve regionKey to regionId via `ctx.db.region.iter()` name match. Check one-time event guard (reject if same eventKey already exists with status 'success' or 'failed' and isRecurring is false). Insert WorldEvent row. Call spawnEventContent. Append world event log via appendWorldEvent. Return inserted row.

2. **spawnEventContent(ctx, eventId, eventDef, deps)** — For each contentLocation in eventDef: resolve locationKey to locationId via ctx.db.location.iter() name match. For each enemy: look up EnemyTemplate by name via iter, call deps.spawnEnemyWithTemplate or insert EnemySpawn + EnemySpawnMember rows manually, then insert EventSpawnEnemy row linking eventId to the new spawnId. For each item: insert EventSpawnItem row with collected=false. Optionally create EventObjective rows per the event's failure condition type (kill_count objective for kill targets, protect_npc for threshold_race events).

3. **resolveWorldEvent(ctx, eventRow, outcome: 'success' | 'failure', deps)** — Guard: if eventRow.status !== 'active' return (prevent double-resolve). Update WorldEvent status to outcome, set resolvedAt. Call applyConsequence(ctx, eventRow, outcome). Call awardEventRewards(ctx, eventRow, outcome, deps). Append world event log. Schedule EventDespawnTick at ctx.timestamp + 120_000_000n (2 minutes).

4. **applyConsequence(ctx, eventRow, outcome)** — Read consequenceType and payload based on outcome ('success' or 'failure'). Switch on consequenceType:
   - 'race_unlock': iterate ctx.db.race.iter(), find by name === payload, update unlocked=true
   - 'faction_standing_bonus': parse JSON {factionId, amount}, award to ALL contributors via EventContribution
   - 'enemy_composition_change': log the change (actual spawn modification deferred to future)
   - 'none': no-op
   - 'system_unlock': log the unlock (actual mechanic unlock deferred)

5. **awardEventRewards(ctx, eventRow, outcome, deps)** — Parse rewardTiersJson. Iterate EventContribution.by_event for eventRow.id. For each contributor: if count === 0n, SKIP (zero contribution = no reward). Determine tier: count >= gold.threshold -> 'gold', >= silver.threshold -> 'silver', else 'bronze'. Look up tier reward for the outcome (success or failure). Award renown via deps.awardRenown. Award gold via character update. Award faction standing via deps.mutateStanding. Award items via deps.addItemToInventory if itemTemplateKey set. Append private event for the character.

6. **checkTimeBasedExpiry(ctx, eventRow, deps)** — If failureConditionType === 'time' and status === 'active' and ctx.timestamp.microsSinceUnixEpoch >= deadlineAtMicros, call resolveWorldEvent with outcome 'failure'. This will be called from a periodic check or from contribution hooks.

Import existing helpers at the top:
```typescript
import { WORLD_EVENT_DEFINITIONS } from '../data/world_event_data';
```

Use `any` typed ctx and deps parameters following the existing helper pattern in this codebase.
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — confirm no type errors. Verify world_events.ts exports all 6 functions: fireWorldEvent, spawnEventContent, resolveWorldEvent, applyConsequence, awardEventRewards, checkTimeBasedExpiry. Verify zero-contribution guard exists in awardEventRewards (if count === 0n continue). Verify applyConsequence reads from both successConsequenceType and failureConsequenceType based on outcome parameter.
  </verify>
  <done>
World event helper module exists with 6 exported functions. resolveWorldEvent handles both success and failure paths. awardEventRewards implements Bronze/Silver/Gold tiers with fixed per-tier rewards and zero-contribution guard. applyConsequence switches on consequence type for both outcomes. EventDespawnTick scheduled at 2-minute post-resolve. One-time event guard prevents re-firing. All imports reference existing helpers — no duplicated logic.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes with no errors
2. tables.ts contains WorldEvent (with successConsequenceType AND failureConsequenceType), EventContribution, EventSpawnEnemy, EventSpawnItem, EventObjective — NO RegionAdjacency
3. scheduled_tables.ts contains EventDespawnTick with scheduled: 'despawn_event_content'
4. All 6 tables are included in their respective schema() export calls
5. world_event_data.ts exists with WORLD_EVENT_DEFINITIONS (2+ events), ADMIN_IDENTITIES, types
6. world_events.ts exists with 6 exported lifecycle functions
7. awardEventRewards skips count === 0n participants (zero contribution = no reward)
8. Each event definition has both successConsequenceType and failureConsequenceType
9. Both time-based and threshold_race failure conditions are supported in data model
10. rewardTiers have bronze/silver/gold with separate success/failure RewardSpec
</verification>

<success_criteria>
Backend foundation complete: 6 new tables defined (WorldEvent with dual consequences, EventContribution for tiered tracking, EventSpawnEnemy/Item for self-contained event content, EventObjective, EventDespawnTick), event data constants with 2 event definitions using Bronze/Silver/Gold tiers, and helper functions covering the full event lifecycle. TypeScript compiles without errors. Ready for Plan 02 to wire reducers and hooks.
</success_criteria>

<output>
After completion, create `.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-01-SUMMARY.md`
</output>
