---
phase: 18-world-events-system-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/data/world_event_data.ts
  - spacetimedb/src/helpers/world_events.ts
  - spacetimedb/src/seeding/ensure_world.ts
autonomous: true

must_haves:
  truths:
    - "WorldEvent table stores persistent event records with status lifecycle (fired/resolved)"
    - "WorldStatTracker table tracks server-wide counters with threshold-triggered events"
    - "WorldEventParticipant table tracks which characters joined events and their contribution"
    - "RegionAdjacency table defines bidirectional neighbor links between all 3 regions"
    - "fireWorldEvent helper inserts a WorldEvent row AND appends an EventWorld log entry"
    - "incrementWorldStat helper auto-fires events when thresholds are crossed"
    - "resolveWorldEvent helper awards renown and faction standing to participants"
    - "Ripple system spawns follow-up events in neighboring regions on resolution"
    - "Region adjacency seeded for Hollowmere Vale <-> Embermarch Fringe <-> Embermarch Depths"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "WorldEvent, WorldStatTracker, WorldEventParticipant, RegionAdjacency table definitions"
      contains: "world_event"
    - path: "spacetimedb/src/data/world_event_data.ts"
      provides: "Event type constants, threshold configs, WORLD_STAT_TRACKER_SEEDS"
    - path: "spacetimedb/src/helpers/world_events.ts"
      provides: "fireWorldEvent, incrementWorldStat, resolveWorldEvent, rippleToNeighbors, creditEventContribution, applyEventConsequence"
    - path: "spacetimedb/src/seeding/ensure_world.ts"
      provides: "seedRegionAdjacency function, ensureWorldStatTrackers function"
  key_links:
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/events.ts"
      via: "appendWorldEvent import for log entries"
      pattern: "appendWorldEvent"
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/renown.ts"
      via: "awardRenown import for participant rewards"
      pattern: "awardRenown"
    - from: "spacetimedb/src/helpers/world_events.ts"
      to: "spacetimedb/src/helpers/economy.ts"
      via: "mutateStanding import for faction rewards"
      pattern: "mutateStanding"
    - from: "spacetimedb/src/seeding/ensure_world.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "RegionAdjacency table for seeding"
      pattern: "regionAdjacency"
---

<objective>
Build the backend foundation for the World Events System: 4 new database tables (WorldEvent, WorldStatTracker, WorldEventParticipant, RegionAdjacency), event data constants, helper functions for the full event lifecycle (fire, join, contribute, resolve, ripple), and seeding for region adjacency and stat trackers.

Purpose: Provide the data layer and business logic that reducers and combat hooks will wire into in Plan 02.
Output: Tables defined in schema, helpers exported and callable, seeding functions ready to be invoked.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-RESEARCH.md

Key existing files:
@spacetimedb/src/schema/tables.ts — Add 4 new tables at end, include in schema() export
@spacetimedb/src/helpers/events.ts — appendWorldEvent helper (line 66) for event log entries
@spacetimedb/src/helpers/renown.ts — awardRenown (line 4) for participant rewards
@spacetimedb/src/helpers/economy.ts — mutateStanding (line 6) for faction standing rewards
@spacetimedb/src/data/renown_data.ts — RENOWN_GAIN.EVENT_PARTICIPATION_BASE (100n) for base reward
@spacetimedb/src/seeding/ensure_world.ts — ensureWorldLayout with 3 regions (Hollowmere Vale, Embermarch Fringe, Embermarch Depths)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define 4 new tables and create event data constants</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/data/world_event_data.ts
  </files>
  <action>
**In `spacetimedb/src/schema/tables.ts`:**

Add 4 new tables BEFORE the `schema()` export call at the bottom of the file. Follow the existing table definition pattern (see WorldState, Region, etc. for reference).

1. **WorldEvent** table — persistent event lifecycle record (DISTINCT from EventWorld log table):
```typescript
export const WorldEvent = table(
  {
    name: 'world_event',
    public: true,
    indexes: [
      { name: 'by_status', algorithm: 'btree', columns: ['status'] },
      { name: 'by_region', algorithm: 'btree', columns: ['regionId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    eventType: t.string(),           // 'race_unlock', 'invasion', 'ritual', 'defense'
    targetId: t.string(),            // Polymorphic: race name, region name, etc.
    triggerCondition: t.string(),     // 'admin' | 'kills_threshold' | 'quests_threshold' | 'ripple'
    status: t.string(),              // 'fired' | 'resolved'
    regionId: t.u64().optional(),    // null = global event, set = regional event
    firedAt: t.timestamp(),
    resolvedAt: t.timestamp().optional(),
    objectiveTarget: t.u64().optional(),       // e.g., kill 50 enemies during event
    objectiveCurrent: t.u64().optional(),      // progress counter
    rewardRenown: t.u64().optional(),          // renown per participant on resolve
    rewardFactionId: t.u64().optional(),       // faction to reward standing to
    rewardFactionStanding: t.i64().optional(), // standing delta per participant
  }
);
```

2. **WorldStatTracker** table — server-wide stat counters for threshold-triggered events:
```typescript
export const WorldStatTracker = table(
  {
    name: 'world_stat_tracker',
    public: true,
  },
  {
    id: t.u64().primaryKey().autoInc(),
    statKey: t.string(),       // 'total_enemies_killed', 'total_quests_completed'
    currentValue: t.u64(),
    nextThreshold: t.u64(),    // fire event when currentValue >= nextThreshold
    eventType: t.string(),     // event type to fire on threshold cross
    targetId: t.string(),      // targetId for the fired event
    thresholdStep: t.u64(),    // increment nextThreshold by this after each fire
  }
);
```

3. **WorldEventParticipant** table — per-character event participation tracking:
```typescript
export const WorldEventParticipant = table(
  {
    name: 'world_event_participant',
    public: true,
    indexes: [
      { name: 'by_event', algorithm: 'btree', columns: ['worldEventId'] },
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    worldEventId: t.u64(),
    characterId: t.u64(),
    joinedAt: t.timestamp(),
    contribution: t.u64(),     // incremented by kills/actions during the event
  }
);
```

4. **RegionAdjacency** table — bidirectional neighbor links for ripple system:
```typescript
export const RegionAdjacency = table(
  {
    name: 'region_adjacency',
    public: true,
    indexes: [{ name: 'by_region', algorithm: 'btree', columns: ['regionId'] }],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    regionId: t.u64(),
    neighborRegionId: t.u64(),
  }
);
```

Add all 4 tables to the `schema()` export call at the bottom of the file. Place them after `SearchResult` in the argument list:
```
  SearchResult,
  WorldEvent,
  WorldStatTracker,
  WorldEventParticipant,
  RegionAdjacency
);
```

**In new file `spacetimedb/src/data/world_event_data.ts`:**

Create event data constants:

```typescript
// World event type constants
export const WORLD_EVENT_TYPES = {
  INVASION: 'invasion',
  RITUAL: 'ritual',
  DEFENSE: 'defense',
  RACE_UNLOCK: 'race_unlock',
} as const;

// Trigger condition constants
export const TRIGGER_CONDITIONS = {
  ADMIN: 'admin',
  KILLS_THRESHOLD: 'kills_threshold',
  QUESTS_THRESHOLD: 'quests_threshold',
  RIPPLE: 'ripple',
} as const;

// Event status constants
export const EVENT_STATUS = {
  FIRED: 'fired',
  RESOLVED: 'resolved',
} as const;

// Stat tracker seeds — defines what triggers what
export const WORLD_STAT_TRACKER_SEEDS = [
  {
    statKey: 'total_enemies_killed',
    nextThreshold: 500n,
    thresholdStep: 500n,
    eventType: WORLD_EVENT_TYPES.INVASION,
    targetId: 'Embermarch Fringe',
  },
  {
    statKey: 'total_quests_completed',
    nextThreshold: 25n,
    thresholdStep: 25n,
    eventType: WORLD_EVENT_TYPES.RITUAL,
    targetId: 'global',
  },
] as const;

// Default event parameters by type
export const EVENT_DEFAULTS: Record<string, {
  objectiveTarget?: bigint;
  rewardRenown?: bigint;
  rewardFactionStanding?: bigint;
  rippleEventType?: string;
}> = {
  [WORLD_EVENT_TYPES.INVASION]: {
    objectiveTarget: 50n,
    rewardRenown: 100n,
    rippleEventType: WORLD_EVENT_TYPES.DEFENSE,
  },
  [WORLD_EVENT_TYPES.RITUAL]: {
    objectiveTarget: 20n,
    rewardRenown: 75n,
  },
  [WORLD_EVENT_TYPES.DEFENSE]: {
    objectiveTarget: 30n,
    rewardRenown: 80n,
  },
  [WORLD_EVENT_TYPES.RACE_UNLOCK]: {
    rewardRenown: 200n,
  },
};

// Region adjacency seed definitions (by name for ID stability)
export const REGION_ADJACENCY_SEEDS = [
  { a: 'Hollowmere Vale', b: 'Embermarch Fringe' },
  { a: 'Embermarch Fringe', b: 'Embermarch Depths' },
];
```
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — no type errors in tables.ts or world_event_data.ts. Confirm all 4 tables appear in the `schema()` call.
  </verify>
  <done>
4 new tables defined in tables.ts with correct indexes (single-column only), all included in schema() export. Event data constants file exists with type definitions, tracker seeds, event defaults, and region adjacency seeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create world event helpers and add seeding functions</name>
  <files>
    spacetimedb/src/helpers/world_events.ts
    spacetimedb/src/seeding/ensure_world.ts
  </files>
  <action>
**Create new file `spacetimedb/src/helpers/world_events.ts`:**

This is the core business logic for the world event lifecycle. Import from existing helpers — do NOT re-implement renown or standing logic.

```typescript
import { appendWorldEvent, appendSystemMessage } from './events';
import { awardRenown } from './renown';
import { mutateStanding } from './economy';
import { RENOWN_GAIN } from '../data/renown_data';
import { EVENT_STATUS, EVENT_DEFAULTS } from '../data/world_event_data';

/**
 * Fire a new world event — inserts WorldEvent row and appends EventWorld log entry.
 * Returns the inserted event row.
 */
export function fireWorldEvent(
  ctx: any,
  eventType: string,
  targetId: string,
  triggerCondition: string,
  regionId?: bigint,
  options?: {
    objectiveTarget?: bigint;
    rewardRenown?: bigint;
    rewardFactionId?: bigint;
    rewardFactionStanding?: bigint;
  }
) {
  // Merge defaults from EVENT_DEFAULTS with explicit options
  const defaults = EVENT_DEFAULTS[eventType] || {};
  const objectiveTarget = options?.objectiveTarget ?? defaults.objectiveTarget;
  const rewardRenown = options?.rewardRenown ?? defaults.rewardRenown;

  const event = ctx.db.worldEvent.insert({
    id: 0n,
    eventType,
    targetId,
    triggerCondition,
    status: EVENT_STATUS.FIRED,
    regionId,
    firedAt: ctx.timestamp,
    resolvedAt: undefined,
    objectiveTarget,
    objectiveCurrent: objectiveTarget ? 0n : undefined,
    rewardRenown,
    rewardFactionId: options?.rewardFactionId,
    rewardFactionStanding: options?.rewardFactionStanding,
  });

  // REQ-033: append EventWorld log entry visible to all players
  const regionLabel = regionId
    ? (() => {
        const region = ctx.db.region.id.find(regionId);
        return region ? ` in ${region.name}` : '';
      })()
    : '';
  appendWorldEvent(ctx, 'world_event', `A world event has begun${regionLabel}: ${eventType}`);

  return event;
}

/**
 * Increment a server-wide stat counter. Auto-fires events when thresholds are crossed.
 */
export function incrementWorldStat(ctx: any, statKey: string, delta: bigint) {
  for (const tracker of ctx.db.worldStatTracker.iter()) {
    if (tracker.statKey !== statKey) continue;
    const newValue = tracker.currentValue + delta;
    if (newValue >= tracker.nextThreshold) {
      // Threshold crossed — fire event and advance threshold
      ctx.db.worldStatTracker.id.update({
        ...tracker,
        currentValue: newValue,
        nextThreshold: tracker.nextThreshold + tracker.thresholdStep,
      });
      // Resolve target region ID by name if not 'global'
      let regionId: bigint | undefined;
      if (tracker.targetId !== 'global') {
        for (const region of ctx.db.region.iter()) {
          if (region.name === tracker.targetId) {
            regionId = region.id;
            break;
          }
        }
      }
      fireWorldEvent(ctx, tracker.eventType, tracker.targetId, `${statKey}_threshold`, regionId);
    } else {
      ctx.db.worldStatTracker.id.update({ ...tracker, currentValue: newValue });
    }
    return;
  }
}

/**
 * Resolve a world event — idempotent (safe to call multiple times).
 * Awards rewards to all participants, applies consequences, triggers ripple.
 */
export function resolveWorldEvent(ctx: any, eventIn: any) {
  // Re-fetch for idempotent guard
  const event = ctx.db.worldEvent.id.find(eventIn.id);
  if (!event || event.status !== EVENT_STATUS.FIRED) return;

  // Mark resolved
  ctx.db.worldEvent.id.update({
    ...event,
    status: EVENT_STATUS.RESOLVED,
    resolvedAt: ctx.timestamp,
  });

  // Award rewards to all joined participants
  for (const participant of ctx.db.worldEventParticipant.by_event.filter(event.id)) {
    const character = ctx.db.character.id.find(participant.characterId);
    if (!character) continue;

    // Renown reward — scaled by contribution if objective-based
    if (event.rewardRenown && event.rewardRenown > 0n) {
      let renownAmount = event.rewardRenown;
      if (event.objectiveTarget && event.objectiveTarget > 0n && participant.contribution > 0n) {
        // Scale by contribution ratio, minimum 10%
        const scale = (participant.contribution * 100n) / event.objectiveTarget;
        const clampedScale = scale < 10n ? 10n : (scale > 100n ? 100n : scale);
        renownAmount = (event.rewardRenown * clampedScale) / 100n;
      }
      if (renownAmount < 1n) renownAmount = 1n;
      awardRenown(ctx, character, renownAmount, `World event: ${event.eventType}`);
    }

    // Faction standing reward
    if (event.rewardFactionId && event.rewardFactionStanding) {
      mutateStanding(ctx, character.id, event.rewardFactionId, event.rewardFactionStanding);
    }
  }

  // Apply event-type-specific consequences
  applyEventConsequence(ctx, event);

  // Log resolution
  appendWorldEvent(ctx, 'world_event', `World event resolved: ${event.eventType}`);

  // Trigger ripple to neighboring regions
  const defaults = EVENT_DEFAULTS[event.eventType];
  if (defaults?.rippleEventType) {
    rippleToNeighbors(ctx, event, defaults.rippleEventType);
  }
}

/**
 * Apply event-type-specific consequences (e.g., unlock race).
 */
export function applyEventConsequence(ctx: any, event: any) {
  if (event.eventType === 'race_unlock') {
    // targetId is the race name — more stable than ID across republish
    for (const race of ctx.db.race.iter()) {
      if (race.name === event.targetId) {
        ctx.db.race.id.update({ ...race, unlocked: true });
        appendWorldEvent(ctx, 'world_event', `The ${race.name} race is now unlocked!`);
        break;
      }
    }
  }
  // Extend here for future event type consequences
}

/**
 * Fire ripple events in neighboring regions when a regional event resolves.
 * Global events (no regionId) do not ripple.
 */
export function rippleToNeighbors(ctx: any, resolvedEvent: any, rippleEventType: string) {
  if (!resolvedEvent.regionId) return; // global events don't ripple
  for (const adj of ctx.db.regionAdjacency.by_region.filter(resolvedEvent.regionId)) {
    // Check if an active event of same type already exists in the neighbor
    let alreadyActive = false;
    for (const existing of ctx.db.worldEvent.by_region.filter(adj.neighborRegionId)) {
      if (existing.status === EVENT_STATUS.FIRED && existing.eventType === rippleEventType) {
        alreadyActive = true;
        break;
      }
    }
    if (!alreadyActive) {
      fireWorldEvent(ctx, rippleEventType, String(adj.neighborRegionId), 'ripple', adj.neighborRegionId);
    }
  }
}

/**
 * Credit event contribution for a character's action in a region.
 * Call from combat kill handler and quest completion handler.
 * Also auto-advances objective progress and auto-resolves if target met.
 */
export function creditEventContribution(ctx: any, characterId: bigint, regionId: bigint, delta: bigint) {
  // Find any active events in this region
  for (const event of ctx.db.worldEvent.by_region.filter(regionId)) {
    if (event.status !== EVENT_STATUS.FIRED) continue;

    // Check if character is a participant
    for (const participant of ctx.db.worldEventParticipant.by_character.filter(characterId)) {
      if (participant.worldEventId !== event.id) continue;

      // Increment contribution
      ctx.db.worldEventParticipant.id.update({
        ...participant,
        contribution: participant.contribution + delta,
      });

      // Increment event objective progress if applicable
      if (event.objectiveTarget && event.objectiveCurrent !== undefined) {
        const newCurrent = event.objectiveCurrent + delta;
        ctx.db.worldEvent.id.update({
          ...event,
          objectiveCurrent: newCurrent,
        });

        // Auto-resolve if objective complete
        if (newCurrent >= event.objectiveTarget) {
          resolveWorldEvent(ctx, { id: event.id });
        }
      }
    }
  }
}
```

**In `spacetimedb/src/seeding/ensure_world.ts`:**

Add two new seeding functions at the bottom of the file (before the final closing, after `ensureDialogueOptions`):

1. `seedRegionAdjacency(ctx)` — seeds bidirectional adjacency rows for the 3 known regions using name-based lookups.

```typescript
import { REGION_ADJACENCY_SEEDS, WORLD_STAT_TRACKER_SEEDS } from '../data/world_event_data';

export function seedRegionAdjacency(ctx: any) {
  const regions = [...ctx.db.region.iter()];
  const byName = new Map(regions.map((r: any) => [r.name, r.id]));

  for (const { a, b } of REGION_ADJACENCY_SEEDS) {
    const aId = byName.get(a);
    const bId = byName.get(b);
    if (!aId || !bId) continue;

    // Check if already seeded (avoid duplicates on re-publish)
    const existing = [...ctx.db.regionAdjacency.by_region.filter(aId)]
      .some((r: any) => r.neighborRegionId === bId);
    if (!existing) {
      ctx.db.regionAdjacency.insert({ id: 0n, regionId: aId, neighborRegionId: bId });
      ctx.db.regionAdjacency.insert({ id: 0n, regionId: bId, neighborRegionId: aId });
    }
  }
}

export function ensureWorldStatTrackers(ctx: any) {
  for (const def of WORLD_STAT_TRACKER_SEEDS) {
    const exists = [...ctx.db.worldStatTracker.iter()].some(
      (r: any) => r.statKey === def.statKey
    );
    if (!exists) {
      ctx.db.worldStatTracker.insert({
        id: 0n,
        statKey: def.statKey,
        currentValue: 0n,
        nextThreshold: def.nextThreshold,
        eventType: def.eventType,
        targetId: def.targetId,
        thresholdStep: def.thresholdStep,
      });
    }
  }
}
```

Add the import at the top of `ensure_world.ts` alongside existing imports. The new functions will be called by the seeding orchestrator in Plan 02.
  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — confirm no type errors. Verify `world_events.ts` exports all 6 functions: `fireWorldEvent`, `incrementWorldStat`, `resolveWorldEvent`, `applyEventConsequence`, `rippleToNeighbors`, `creditEventContribution`. Verify `ensure_world.ts` exports `seedRegionAdjacency` and `ensureWorldStatTrackers`.
  </verify>
  <done>
World event helper module exists with 6 exported functions covering the full lifecycle (fire, join, contribute, resolve, ripple, consequence). Seeding functions exist for region adjacency and stat trackers. All imports reference existing helpers (events, renown, economy) — no duplicated logic.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project spacetimedb/tsconfig.json` passes with no errors
2. `spacetimedb/src/schema/tables.ts` contains WorldEvent, WorldStatTracker, WorldEventParticipant, RegionAdjacency table definitions with correct indexes (single-column only — no multi-column per CLAUDE.md)
3. All 4 new tables are included in the `schema()` export call
4. `spacetimedb/src/data/world_event_data.ts` exists with WORLD_EVENT_TYPES, TRIGGER_CONDITIONS, EVENT_STATUS, WORLD_STAT_TRACKER_SEEDS, EVENT_DEFAULTS, REGION_ADJACENCY_SEEDS
5. `spacetimedb/src/helpers/world_events.ts` exists with 6 exported functions
6. `spacetimedb/src/seeding/ensure_world.ts` exports `seedRegionAdjacency` and `ensureWorldStatTrackers`
7. Helper functions use existing `appendWorldEvent`, `awardRenown`, `mutateStanding` — NOT reimplementing reward logic
</verification>

<success_criteria>
Backend foundation complete: 4 new tables defined, event data constants created, helper functions covering full event lifecycle, seeding functions for region adjacency and stat trackers. TypeScript compiles without errors. Ready for Plan 02 to wire reducers and hooks.
</success_criteria>

<output>
After completion, create `.planning/phases/18-world-events-system-expansion-regional-event-spawning-ripple-system-event-types-and-objectives-faction-and-overall-renown-rewards-event-participation-tracking/18-01-SUMMARY.md`
</output>
