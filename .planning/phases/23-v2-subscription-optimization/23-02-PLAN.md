---
phase: 23-v2-subscription-optimization
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/composables/useGameData.ts
  - src/composables/useEvents.ts
  - src/App.vue
autonomous: true
requirements: []

must_haves:
  truths:
    - "Event log data (world, location, private, group) arrives on the client and displays in the log window"
    - "Event tables use onInsert callbacks instead of useTable (which returns empty for event tables)"
    - "useEvents composable consumes event data from refs populated by onInsert"
    - "New events appear in real-time as they are inserted server-side"
    - "Client-side filtering for private events (by userId) and location events (by locationId) still works"
    - "Session-start filtering still works (events before session start are excluded)"
    - "Local client events (addLocalEvent) still work alongside server events"
  artifacts:
    - path: "src/composables/useGameData.ts"
      provides: "Event refs populated via onInsert callbacks instead of useTable"
    - path: "src/composables/useEvents.ts"
      provides: "Combined event log composable consuming onInsert-driven refs"
    - path: "src/App.vue"
      provides: "Wiring of event data to log display"
  key_links:
    - from: "src/composables/useGameData.ts"
      to: "module_bindings"
      via: "conn.db.event_world.onInsert callback"
      pattern: "onInsert"
    - from: "src/App.vue"
      to: "src/composables/useEvents.ts"
      via: "useEvents({ worldEvents, ... })"
      pattern: "useEvents"
---

<objective>
Convert the client-side event table consumption from useTable() (which returns empty arrays for event tables since iter() is always empty) to onInsert callback-driven refs. Event tables with `event: true` only fire onInsert — they never store rows in the client cache, so useTable always returns empty arrays.

Purpose: After Plan 01 converted the 4 event tables to `event: true` on the server, the client must switch from useTable (which relies on cached rows) to onInsert callbacks (which capture transient inserts). Without this change, the event log would show nothing.

Output: Working event log display using onInsert-driven event data.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-v2-subscription-optimization/23-RESEARCH.md
@.planning/phases/23-v2-subscription-optimization/23-01-SUMMARY.md
@src/composables/useGameData.ts
@src/composables/useEvents.ts
@src/App.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace useTable with onInsert for event tables in useGameData</name>
  <files>
    src/composables/useGameData.ts
  </files>
  <action>
    **Critical context:** Event tables with `event: true` never store rows in the client cache. `useTable()` internally calls `Array.from(table.iter())` which always returns empty for event tables. The correct pattern is to use `onInsert` callbacks to capture each inserted row into a local ref array.

    **Step 1 — Remove the 4 useTable calls for event tables:**

    Remove these lines from useGameData:
    ```
    const [worldEvents] = useTable(tables.event_world);
    const [locationEvents] = useTable(tables.event_location);
    const [privateEvents] = useTable(tables.event_private);
    const [groupEvents] = useTable(tables.event_group);
    ```

    **Step 2 — Add onInsert-driven refs for event tables:**

    Import `shallowRef` from vue. Create shallowRef arrays for each event table. The `conn` object from `useSpacetimeDB()` provides access to `conn.db` for registering callbacks. However, `conn` from `useSpacetimeDB()` returns the reactive connection ref. We need the actual DbConnection to register callbacks.

    Use `window.__db_conn` (set in main.ts onConnect) for callback registration. This is the established pattern in the codebase (see useGameData.ts existing patterns and MEMORY.md).

    Actually, check whether the v2 SDK's `useSpacetimeDB()` returns a connection object that has `.db`. If it does, use that. If not, use `window.__db_conn`.

    The v2 `useSpacetimeDB()` returns a `DbConnection` object (or null when disconnected). Use it directly:

    ```typescript
    import { shallowRef, watchEffect, onUnmounted } from 'vue';

    // Inside useGameData:
    const MAX_CLIENT_EVENTS = 200;

    const worldEvents = shallowRef<any[]>([]);
    const locationEvents = shallowRef<any[]>([]);
    const privateEvents = shallowRef<any[]>([]);
    const groupEvents = shallowRef<any[]>([]);
    ```

    **Step 3 — Register onInsert callbacks and explicit subscriptions:**

    Event tables require explicit subscription (excluded from subscribeToAllTables) AND onInsert callbacks.

    After the conn is available, register callbacks. Since `useSpacetimeDB()` returns the connection and useTable internally subscribes, we need to:
    1. Subscribe explicitly to each event table
    2. Register onInsert to populate our refs

    ```typescript
    // Subscribe explicitly to event tables (event tables require explicit subscription)
    // The conn from useSpacetimeDB() is available immediately after provider mounts
    if (conn) {
      conn.subscriptionBuilder().subscribe([
        'SELECT * FROM "event_world"',
        'SELECT * FROM "event_location"',
        'SELECT * FROM "event_private"',
        'SELECT * FROM "event_group"',
      ]);

      conn.db.event_world.onInsert((_ctx, row) => {
        worldEvents.value = [...worldEvents.value.slice(-(MAX_CLIENT_EVENTS - 1)), row];
      });
      conn.db.event_location.onInsert((_ctx, row) => {
        locationEvents.value = [...locationEvents.value.slice(-(MAX_CLIENT_EVENTS - 1)), row];
      });
      conn.db.event_private.onInsert((_ctx, row) => {
        privateEvents.value = [...privateEvents.value.slice(-(MAX_CLIENT_EVENTS - 1)), row];
      });
      conn.db.event_group.onInsert((_ctx, row) => {
        groupEvents.value = [...groupEvents.value.slice(-(MAX_CLIENT_EVENTS - 1)), row];
      });
    }
    ```

    **Important:** The `conn` object from `useSpacetimeDB()` may be null initially. Check the actual return type. If it's a Ref, use `watchEffect` to register callbacks when conn becomes available. If it's a direct object (set by the provider before components mount), register directly.

    Look at the actual implementation of `useSpacetimeDB()` in the SDK to confirm. The existing code does `const conn = useSpacetimeDB();` and then immediately uses it (line 12 of useGameData.ts), so it must return a non-null value when inside the provider.

    **Step 4 — Keep the return object unchanged:**

    The `worldEvents`, `locationEvents`, `privateEvents`, `groupEvents` refs are already in the return object. Since we created them as `shallowRef<any[]>([])`, they maintain the same `Ref<any[]>` type signature. No changes needed to the return statement.

    **Important:** Do NOT change the names or types of the returned refs. App.vue destructures them by name.
  </action>
  <verify>
    <automated>cd C:/projects/uwr && npx tsc --noEmit</automated>
    <manual>Check that useGameData no longer calls useTable for the 4 event tables, and instead uses onInsert callbacks</manual>
  </verify>
  <done>The 4 event table subscriptions use onInsert callbacks instead of useTable. Each callback appends to a local shallowRef array capped at 200 entries. Explicit subscriptions are registered for event tables. Return shape of useGameData is unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Update useEvents composable and verify event log wiring</name>
  <files>
    src/composables/useEvents.ts
    src/App.vue
  </files>
  <action>
    **Step 1 — Verify useEvents.ts compatibility:**

    The `useEvents` composable accepts `UseEventsArgs` which includes:
    ```typescript
    worldEvents: Ref<EventWorld[]>;
    locationEvents: Ref<EventLocation[]>;
    privateEvents: Ref<EventPrivate[]>;
    groupEvents: Ref<EventGroup[]>;
    ```

    With the onInsert approach, the refs contain the same row shapes (the onInsert callback receives the full row object matching the table schema). However, since event tables auto-delete, the rows won't have the same lifecycle — they arrive once and stay in our local array until trimmed.

    **The composable should work as-is** because:
    - It reads `.value` arrays from the refs
    - It maps row properties (id, createdAt, kind, message)
    - The row shape from onInsert matches the row shape from useTable

    **One change needed in useEvents.ts:** The current implementation filters by `sessionStartedAt` which compares `createdAt.microsSinceUnixEpoch`. This still works because event table rows still have the `createdAt` field populated by the server.

    If TypeScript complains about the row types (since we used `any[]` in useGameData), update the UseEventsArgs types to accept `any[]` or re-import the correct types. Prefer keeping the existing typed refs if possible.

    **Step 2 — Verify App.vue event wiring:**

    App.vue has these computed properties that filter events:
    - `userPrivateEvents`: filters privateEvents by userId
    - `userLocationEvents`: filters locationEvents by locationId and excludeCharacterId
    - `userGroupEvents`: filters groupEvents by group membership

    These computeds read from the destructured refs. Since the refs now contain ALL rows (not pre-filtered by views), the client-side filtering is MORE important than before. Previously, `my_private_events` view filtered server-side by userId. Now with event tables (public), ALL event_private rows arrive on the client, and the computed filter handles scoping.

    **Verify these computeds still work correctly.** They should, since they already existed alongside the public table pattern (per STATE.md decision #36/#48).

    **Step 3 — Handle the removed views:**

    Plan 01 removed `my_private_events` and `my_location_events` views. Check if App.vue or any other file subscribes to these views. If so, remove those references. Search for `my_private_events` and `my_location_events` in `src/`.

    If these view names appear in useGameData or elsewhere, remove them (they no longer exist on the server).

    **Step 4 — Verify TypeScript compilation:**

    Run `npx tsc --noEmit` in the project root. Fix any type errors related to:
    - Event row types (EventWorld, EventLocation, etc.) — may need to import from module_bindings
    - The shallowRef type annotations in useGameData
    - Any references to removed views

    **Step 5 — Test event log behavior:**

    Start the local SpacetimeDB server, ensure the module is published (from Plan 01), and start the Vite dev server. Verify:
    1. Connect to the game
    2. Perform an action that generates events (e.g., move to a location, start combat)
    3. Check the log window shows new events in real-time
    4. Verify events are scoped correctly (private events only show for the acting player)
  </action>
  <verify>
    <automated>cd C:/projects/uwr && npx tsc --noEmit</automated>
    <manual>Start dev server, connect, perform actions, verify event log shows new events in real-time with correct scoping</manual>
  </verify>
  <done>useEvents composable correctly consumes onInsert-driven event refs. App.vue client-side event filtering works for private/location/group scoping. Event log displays new events in real-time. No TypeScript errors. No references to removed event views.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Event log displays new events (world, location, private, group) in real-time
3. Private events are scoped to the authenticated user
4. Location events are scoped to the character's current location
5. Group events are scoped to the character's group
6. No references to `my_private_events` or `my_location_events` views in client code
7. useGameData return shape is unchanged (same ref names, same destructuring in App.vue)
</verification>

<success_criteria>
- Event tables consumed via onInsert callbacks, not useTable
- Combined event log shows real-time events with correct scoping
- TypeScript compiles cleanly
- useGameData interface unchanged (backward compatible)
- No references to removed server-side views
</success_criteria>

<output>
After completion, create `.planning/phases/23-v2-subscription-optimization/23-02-SUMMARY.md`
</output>
