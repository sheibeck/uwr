---
phase: 06-quest-system
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/components/LocationGrid.vue
  - src/App.vue
autonomous: false

must_haves:
  truths:
    - "Module publishes successfully with new tables and reducers"
    - "Client bindings regenerated with QuestItem, NamedEnemy, SearchResult types"
    - "Location panel shows search results when character has SearchResult"
    - "Quest item nodes appear in location panel with loot interaction"
    - "Named enemies appear in location panel with pull option"
    - "Quests tab in Journal panel shows new quest types with progress"
  artifacts:
    - path: "src/module_bindings/"
      provides: "Generated bindings with new tables"
      contains: "quest_item"
    - path: "src/components/LocationGrid.vue"
      provides: "Search result display, quest item nodes, named enemy tiles"
      contains: "searchResult"
    - path: "src/App.vue"
      provides: "useTable subscriptions for QuestItem, NamedEnemy, SearchResult"
      contains: "questItem"
  key_links:
    - from: "src/App.vue"
      to: "src/module_bindings/"
      via: "useTable subscriptions for new tables"
      pattern: "useTable.*tables\\.questItem"
    - from: "src/components/LocationGrid.vue"
      to: "src/App.vue"
      via: "Props for search results, quest items, named enemies"
      pattern: "searchResult|questItem|namedEnem"
---

<objective>
Publish the SpacetimeDB module with all new tables and reducers, regenerate client bindings, and add minimal client-side integration: search result display in the location panel, quest item loot nodes, and named enemy pull tiles. Then human-verify the complete quest system end-to-end.

Purpose: This plan connects the backend (Plans 01+02) to the frontend and verifies everything works together. The client changes are minimal — adding new tile types to the existing LocationGrid pattern.

Output: Published module, regenerated bindings, working client integration for search results and new quest interactions.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-quest-system/06-01-SUMMARY.md
@.planning/phases/06-quest-system/06-02-SUMMARY.md
@src/components/LocationGrid.vue
@src/App.vue
@src/components/NpcDialogPanel.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Publish module, regenerate bindings, and add client subscriptions</name>
  <files>src/module_bindings/*, src/App.vue</files>
  <action>
1. Run `spacetime publish uwr --clear-database -y --project-path spacetimedb` to publish the module with the new tables and reducers. If the default server is maincloud, use maincloud. If publish fails, check `spacetime logs uwr` for errors and fix.

2. Run `spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb` to regenerate client bindings.

3. In `src/App.vue`, add useTable subscriptions for the three new tables. Find where existing useTable calls are (likely in the `useGameData` composable or directly in App.vue). Add:

```typescript
const [questItems] = useTable(tables.questItem);
const [namedEnemies] = useTable(tables.namedEnemy);
const [searchResults] = useTable(tables.searchResult);
```

4. Create computed properties to filter these for the selected character:

```typescript
const characterQuestItems = computed(() => {
  if (!selectedCharacter.value) return [];
  const charId = selectedCharacter.value.id;
  return questItems.value.filter(qi => qi.characterId === charId);
});

const characterNamedEnemies = computed(() => {
  if (!selectedCharacter.value) return [];
  const charId = selectedCharacter.value.id;
  return namedEnemies.value.filter(ne => ne.characterId === charId);
});

const characterSearchResult = computed(() => {
  if (!selectedCharacter.value) return null;
  const charId = selectedCharacter.value.id;
  return searchResults.value.find(sr => sr.characterId === charId) ?? null;
});
```

5. Pass these as props to LocationGrid component. Find where LocationGrid is rendered and add the new props:
```html
:quest-items="locationQuestItems"
:named-enemies="locationNamedEnemies"
:search-result="characterSearchResult"
```

Also create a location-filtered version for quest items and named enemies:
```typescript
const locationQuestItems = computed(() => {
  if (!selectedCharacter.value) return [];
  const locId = selectedCharacter.value.locationId;
  return characterQuestItems.value.filter(qi => qi.locationId === locId && qi.discovered && !qi.looted);
});

const locationNamedEnemies = computed(() => {
  if (!selectedCharacter.value) return [];
  const locId = selectedCharacter.value.locationId;
  return characterNamedEnemies.value.filter(ne => ne.locationId === locId && ne.isAlive);
});
```

6. Make sure the SQL subscription query includes the new tables. Find where `subscriptionBuilder().subscribe([...])` is called and add:
```
'SELECT * FROM quest_item',
'SELECT * FROM named_enemy',
'SELECT * FROM search_result',
```

7. Add `lootQuestItem` and `pullNamedEnemy` handler functions in App.vue that call the reducers:
```typescript
const lootQuestItem = (questItemId: bigint) => {
  if (!selectedCharacter.value || !conn) return;
  conn.reducers.lootQuestItem({ characterId: selectedCharacter.value.id, questItemId });
};

const pullNamedEnemy = (namedEnemyId: bigint) => {
  if (!selectedCharacter.value || !conn) return;
  conn.reducers.pullNamedEnemy({ characterId: selectedCharacter.value.id, namedEnemyId });
};
```

Pass these as props or provide them via the existing event/callback pattern used for other interactions.
  </action>
  <verify>
- Module publishes without errors
- Bindings generate without errors
- `npm run dev` starts the client without errors
- Open the app, verify no console errors related to new table subscriptions
  </verify>
  <done>Module published with new tables. Bindings regenerated. Client subscribes to QuestItem, NamedEnemy, SearchResult tables. Character-filtered computed properties created. Reducer call handlers wired up.</done>
</task>

<task type="auto">
  <name>Task 2: Add search results, quest items, and named enemies to LocationGrid</name>
  <files>src/components/LocationGrid.vue</files>
  <action>
1. Add props to LocationGrid.vue for the new data:
```typescript
questItems: { type: Array, default: () => [] },       // QuestItem[] at current location
namedEnemies: { type: Array, default: () => [] },      // NamedEnemy[] at current location
searchResult: { type: Object, default: null },         // SearchResult | null
```

Also add event emits for interactions:
```typescript
const emit = defineEmits([...existing emits, 'loot-quest-item', 'pull-named-enemy']);
```

2. In the template, add a SEARCH RESULTS section at the TOP of LocationGrid (before enemies), only shown when searchResult exists:

```html
<!-- Search Results -->
<div v-if="searchResult">
  <div :style="styles.gridSectionLabel">SEARCH</div>
  <div :style="styles.gridWrap">
    <div
      v-if="searchResult.foundResources"
      :style="{ ...styles.gridTile, color: '#60a5fa' }"
    >
      Hidden resources detected nearby
    </div>
    <div
      v-if="searchResult.foundQuestItem"
      :style="{ ...styles.gridTile, color: '#fbbf24' }"
    >
      Something of interest found...
    </div>
    <div
      v-if="searchResult.foundNamedEnemy"
      :style="{ ...styles.gridTile, color: '#ef4444' }"
    >
      A powerful presence lurks here
    </div>
    <div
      v-if="!searchResult.foundResources && !searchResult.foundQuestItem && !searchResult.foundNamedEnemy"
      :style="{ ...styles.gridTile, opacity: 0.5 }"
    >
      Nothing unusual detected
    </div>
  </div>
</div>
```

3. Add a QUEST ITEMS section after resources but before enemies, showing discovered but unlooted quest items:

```html
<!-- Quest Items -->
<div v-if="questItems.length > 0">
  <div :style="styles.gridSectionLabel">QUEST ITEMS</div>
  <div :style="styles.gridWrap">
    <div
      v-for="qi in questItems"
      :key="qi.id.toString()"
      :style="{
        ...styles.gridTile,
        color: '#fbbf24',
        cursor: 'pointer',
        flexDirection: 'column',
        alignItems: 'flex-start',
      }"
      @click="emit('loot-quest-item', qi.id)"
    >
      <span>{{ qi.name }}</span>
      <span :style="{ fontSize: '0.7rem', opacity: 0.7 }">Click to loot</span>
    </div>
  </div>
</div>
```

4. Add a NAMED ENEMIES section after the quest items section (or mix into the enemies section as a distinct visual):

```html
<!-- Named Enemies -->
<div v-if="namedEnemies.length > 0">
  <div :style="styles.gridSectionLabel">NAMED ENEMIES</div>
  <div :style="styles.gridWrap">
    <div
      v-for="ne in namedEnemies"
      :key="ne.id.toString()"
      :style="{
        ...styles.gridTile,
        color: '#ef4444',
        cursor: 'pointer',
        borderLeft: '3px solid #ef4444',
        flexDirection: 'column',
        alignItems: 'flex-start',
      }"
      @click="emit('pull-named-enemy', ne.id)"
    >
      <span>{{ ne.name }}</span>
      <span :style="{ fontSize: '0.7rem', opacity: 0.7 }">Click to engage</span>
    </div>
  </div>
</div>
```

5. Update the empty state check at the top of LocationGrid to also consider the new sections:
```html
v-if="
  enemySpawns.length === 0 &&
  resourceNodes.length === 0 &&
  npcsHere.length === 0 &&
  corpsesHere.length === 0 &&
  questItems.length === 0 &&
  namedEnemies.length === 0 &&
  !searchResult
"
```

6. Make sure the existing styles object is used for consistency. Use the same `gridTile`, `gridWrap`, `gridSectionLabel` patterns already in use. Do NOT change any existing sections (enemies, resources, NPCs, corpses, players).
  </action>
  <verify>
- `npm run dev` starts without errors
- Travel to a non-safe location — search result section appears in LocationGrid
- LocationGrid shows quest items when an explore quest is active at that location and the roll succeeds
- Named enemies appear when a boss_kill quest is active at that location and the roll succeeds
  </verify>
  <done>LocationGrid displays search results, quest item loot nodes (clickable), and named enemy pull tiles (clickable). Existing LocationGrid sections unchanged. Empty state updated to account for new sections.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete quest type expansion with passive search system:
- QuestTemplate extended with questType, targetLocationId, targetNpcId, targetItemName, itemDropChance
- QuestItem, NamedEnemy, SearchResult tables (public, client-filtered)
- Passive search triggers on every location entry with independent probability rolls
- 14 new quests seeded across 7 NPCs with affinity-gated dialogue branches
- 4 new quest types: kill_loot (item drops from kills), explore (search + loot nodes), delivery (hail target NPC), boss_kill (search + named enemy pull)
- Delivery chain: Marla -> Scout Thessa -> Keeper Mordane links all 3 regions
- Client shows search results, quest items, and named enemies in location panel</what-built>
  <how-to-verify>
1. Create a new character or use existing one at Hollowmere
2. Travel to any non-safe location — verify SEARCH section appears in location panel
3. Talk to Marla the Guide (/hail marla) — build affinity by choosing dialogue options
4. Once at Acquaintance (25 affinity), say "debts" to accept "Old Debts" delivery quest
5. Verify quest appears in the Quests tab of Journal panel
6. Travel to Embermarch Gate area where Scout Thessa is located
7. /hail scout thessa — verify delivery auto-completes and quest log updates
8. Talk to Warden Kael, build affinity to 25 — say "supplies" to accept "Stolen Supply Cache" (kill_loot)
9. Kill Thicket Wolves — verify occasional "Stolen Supply Pack" drops (25% chance per kill)
10. Talk to Herbalist Venna, build affinity to 25 — say "moss" to accept "Bogfen Healing Moss" (explore)
11. Travel to Willowfen — verify search occasionally reveals "Rare Healing Moss" quest item
12. Click the quest item to loot it — verify quest completes (and possible aggro)
13. For boss_kill: build affinity with Ashwalker Ren to 50 — say "commander" to accept
14. Travel to Scoria Flats repeatedly — named enemy should appear (20% search chance)
15. Click named enemy to engage — verify combat starts
  </how-to-verify>
  <resume-signal>Type "approved" to confirm the quest system works, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- Module published and running
- Client bindings include QuestItem, NamedEnemy, SearchResult types
- Travel triggers search results in location panel
- kill_loot quests drop items from kills
- explore quests reveal items via search, lootable with aggro chance
- delivery quests auto-complete on hailing target NPC
- boss_kill quests reveal named enemies via search, pullable into combat
- Existing quest system (13 kill quests) still works
- NPC dialogue trees show new affinity-gated quest branches
</verification>

<success_criteria>
- All 4 new quest types functional end-to-end
- Passive search system works on every location entry
- 14 new quests accessible via NPC dialogue with proper affinity gates
- Delivery chain Marla -> Thessa -> Mordane links narratively
- No regressions to existing quest, combat, or NPC systems
- Human verifies core quest flows work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-quest-system/06-03-SUMMARY.md`
</output>
