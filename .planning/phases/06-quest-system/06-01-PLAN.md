---
phase: 06-quest-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/data/faction_quest_data.ts
  - spacetimedb/src/seeding/ensure_content.ts
  - spacetimedb/src/reducers/quests.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/reducers/characters.ts
  - spacetimedb/src/index.ts
autonomous: true
must_haves:
  truths:
    - "FactionQuest table contains 8 seeded quests gated by faction standing"
    - "Player can accept a faction quest and a PlayerFactionQuest row is created"
    - "Killing quest-target enemies increments PlayerFactionQuest progress"
    - "Player can complete a faction quest and receive XP, gold, and faction standing rewards"
    - "Completing a quest penalizes rival faction standing"
    - "Player cannot accept a quest if standing is too low"
    - "Player cannot accept the same quest twice while active or after completion"
    - "Character deletion cleans up PlayerFactionQuest rows"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "FactionQuest and PlayerFactionQuest table definitions"
      contains: "FactionQuest"
    - path: "spacetimedb/src/data/faction_quest_data.ts"
      provides: "FACTION_QUEST_DATA seed array and ensureFactionQuests function"
      exports: ["FACTION_QUEST_DATA", "ensureFactionQuests"]
    - path: "spacetimedb/src/reducers/quests.ts"
      provides: "accept_faction_quest and complete_faction_quest reducers"
      exports: ["registerQuestReducers"]
    - path: "spacetimedb/src/seeding/ensure_content.ts"
      provides: "ensureFactionQuests call in syncAllContent"
      contains: "ensureFactionQuests"
  key_links:
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "ctx.db.playerFactionQuest"
      via: "updateFactionQuestProgressForKill in kill resolution loop"
      pattern: "playerFactionQuest\\.by_character\\.filter"
    - from: "spacetimedb/src/reducers/quests.ts"
      to: "helpers/economy.ts mutateStanding"
      via: "quest completion reward"
      pattern: "mutateStanding"
    - from: "spacetimedb/src/seeding/ensure_content.ts"
      to: "spacetimedb/src/data/faction_quest_data.ts"
      via: "ensureFactionQuests import and call"
      pattern: "ensureFactionQuests"
---

<objective>
Backend foundation for the faction quest system: define FactionQuest and PlayerFactionQuest tables, seed 8 faction-gated quests, implement accept/complete reducers with reward granting, hook kill progress tracking into combat loop, and publish module with regenerated bindings.

Purpose: Provide all server-side quest infrastructure so the frontend can subscribe to quest data and call reducers.
Output: Working backend with seeded quests, accept/complete reducers, kill-based progress tracking, published module, regenerated client bindings.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-quest-system/06-RESEARCH.md
@spacetimedb/src/schema/tables.ts
@spacetimedb/src/helpers/economy.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/reducers/characters.ts
@spacetimedb/src/reducers/index.ts
@spacetimedb/src/seeding/ensure_content.ts
@spacetimedb/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define tables, seed data, and wire seeding</name>
  <files>
    spacetimedb/src/schema/tables.ts
    spacetimedb/src/data/faction_quest_data.ts
    spacetimedb/src/seeding/ensure_content.ts
  </files>
  <action>
**1. Add FactionQuest and PlayerFactionQuest tables to `spacetimedb/src/schema/tables.ts`:**

Add before the `spacetimedb = schema(...)` export:

```typescript
export const FactionQuest = table(
  {
    name: 'faction_quest',
    public: true,
    indexes: [
      { name: 'by_faction', algorithm: 'btree', columns: ['factionId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    name: t.string(),
    description: t.string(),
    factionId: t.u64(),
    requiredStanding: t.i64(),
    questType: t.string(),
    targetEnemyTemplateId: t.u64().optional(),
    requiredCount: t.u64().optional(),
    targetLocationId: t.u64().optional(),
    rewardXp: t.u64(),
    rewardGold: t.u64(),
    rewardFactionStanding: t.u64(),
    rivalFactionPenalty: t.u64(),
  }
);

export const PlayerFactionQuest = table(
  {
    name: 'player_faction_quest',
    public: true,
    indexes: [
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    characterId: t.u64(),
    factionQuestId: t.u64(),
    status: t.string(),
    progress: t.u64(),
    acceptedAt: t.timestamp(),
    completedAt: t.timestamp().optional(),
  }
);
```

Add both `FactionQuest` and `PlayerFactionQuest` to the `schema(...)` call at the bottom of the file, after `PendingSpellCast`.

**2. Create `spacetimedb/src/data/faction_quest_data.ts`:**

Define `FACTION_QUEST_DATA` array with all 8 quests. Each entry has: `name`, `description` (hardcoded fallback description in RPG flavor), `factionName` (string for lookup), `requiredStanding` (bigint), `questType` ('kill' or 'travel'), `targetEnemyName` (string for lookup, optional), `requiredCount` (bigint, optional), `targetLocationName` (string for lookup, optional — only "The Overgrown Path" uses this, target = "Thornveil Thicket"), `rewardXp`, `rewardGold`, `rewardFactionStanding`, `rivalFactionPenalty`.

Quest data (all values as bigint literals with `n` suffix):

| Quest | Faction | Standing | Type | Target Enemy | Count | Target Location | XP | Gold | Standing | Rival Penalty |
|-------|---------|----------|------|-------------|-------|-----------------|-----|------|----------|---------------|
| The Lost Shipment | Iron Compact | 0n | kill | Bandit | 5n | — | 120n | 50n | 150n | 75n |
| Clearing the Route | Iron Compact | 1000n | kill | Cinder Sentinel | 4n | — | 200n | 100n | 250n | 125n |
| The Overgrown Path | Verdant Circle | 0n | travel | — | — | Thornveil Thicket | 100n | 40n | 150n | 75n |
| The Fungal Bloom | Verdant Circle | 1000n | kill | Marsh Croaker | 6n | — | 200n | 100n | 250n | 125n |
| The Missing Tome | Ashen Order | 0n | kill | Sootbound Mystic | 3n | — | 120n | 50n | 150n | 75n |
| A Test of Mettle | Free Blades | 0n | kill | Ash Jackal | 5n | — | 120n | 50n | 150n | 75n |
| Contract Work | Free Blades | 1000n | kill | Ashforged Revenant | 4n | — | 200n | 100n | 250n | 125n |
| The Debt Ledger | Iron Compact | 3000n | kill | Vault Sentinel | 3n | — | 350n | 200n | 400n | 200n |

Write creative but brief fallback descriptions (1-2 sentences each) in a dark fantasy RPG tone for each quest.

Export `ensureFactionQuests(ctx: any)` function that:
- Iterates `FACTION_QUEST_DATA`
- For each entry, resolves `factionId` by finding `ctx.db.faction.iter()` matching `factionName`
- For kill quests, resolves `targetEnemyTemplateId` by finding `ctx.db.enemyTemplate.iter()` matching `targetEnemyName`
- For travel quests, resolves `targetLocationId` by finding `ctx.db.location.iter()` matching `targetLocationName`
- Uses upsert-by-name pattern: check if `ctx.db.factionQuest.iter()` already has a row with same `name` — if yes, skip (idempotent seeding). If no, insert with `id: 0n`.
- Skip entries where faction/enemy/location lookup fails (log nothing — deterministic reducers cannot do side effects)

**3. Wire seeding in `spacetimedb/src/seeding/ensure_content.ts`:**

- Import `ensureFactionQuests` from `'../data/faction_quest_data'`
- Add `ensureFactionQuests(ctx);` call in `syncAllContent()` after `ensureQuestTemplates(ctx)` and before `ensureDialogueOptions(ctx)` (faction quests depend on factions + enemy templates being seeded first)
  </action>
  <verify>
TypeScript compilation check: `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit` should produce no errors related to FactionQuest, PlayerFactionQuest, or faction_quest_data.
  </verify>
  <done>
FactionQuest and PlayerFactionQuest tables defined in schema with correct indexes. 8 faction quests defined in seed data with resolved faction/enemy/location references. Seeding wired into syncAllContent. Both tables included in schema() export.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement reducers, combat hook, character cleanup, and publish</name>
  <files>
    spacetimedb/src/reducers/quests.ts
    spacetimedb/src/reducers/index.ts
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/reducers/characters.ts
    spacetimedb/src/index.ts
  </files>
  <action>
**1. Create `spacetimedb/src/reducers/quests.ts`:**

Export `registerQuestReducers(deps: any)` following the established pattern (see `registerNpcInteractionReducers` in `npc_interaction.ts` as reference). Destructure from `deps`: `spacetimedb`, `t`, `SenderError`, `requireCharacterOwnedBy`, `appendPrivateEvent`, `fail`, `Faction`, `FactionStanding`, `mutateStanding` (NOTE: `mutateStanding` must be added to deps — see index.ts step below).

Define two reducers:

**`accept_faction_quest` reducer** with args `{ characterId: t.u64(), factionQuestId: t.u64() }`:
1. `requireCharacterOwnedBy(ctx, characterId)` to get character and validate ownership
2. Find quest: `ctx.db.factionQuest.id.find(factionQuestId)` — throw SenderError if not found
3. Check faction standing: `[...ctx.db.factionStanding.by_character.filter(characterId)]` then `.find(s => s.factionId === quest.factionId)`. Get `currentStanding = standing?.standing ?? 0n`. If `currentStanding < quest.requiredStanding`, call `fail(ctx, character, 'Your standing with this faction is too low.')` and return
4. Check not already active or completed: `[...ctx.db.playerFactionQuest.by_character.filter(characterId)]` then check for existing row with same `factionQuestId` and `status === 'active'` — fail with "Quest already active". Also check for `status === 'completed'` — fail with "Quest already completed"
5. Insert: `ctx.db.playerFactionQuest.insert({ id: 0n, characterId, factionQuestId, status: 'active', progress: 0n, acceptedAt: ctx.timestamp, completedAt: undefined })`
6. `appendPrivateEvent(ctx, characterId, character.ownerUserId, 'quest', \`Quest accepted: ${quest.name}.\`)`

**`complete_faction_quest` reducer** with args `{ characterId: t.u64(), playerQuestId: t.u64() }`:
1. `requireCharacterOwnedBy(ctx, characterId)` to get character
2. Find player quest: `ctx.db.playerFactionQuest.id.find(playerQuestId)` — throw SenderError if not found or `playerQuest.characterId !== characterId`
3. Check status: if `playerQuest.status !== 'active'`, fail with "Quest is not active"
4. Find quest template: `ctx.db.factionQuest.id.find(playerQuest.factionQuestId)` — throw SenderError if not found
5. Validate completion by type:
   - If `questType === 'kill'`: check `playerQuest.progress >= (quest.requiredCount ?? 0n)` — fail with progress message if not met
   - If `questType === 'travel'`: check `quest.targetLocationId !== undefined && character.locationId === quest.targetLocationId` — fail with "You must reach the destination first" if not at location
6. Update status: `ctx.db.playerFactionQuest.id.update({ ...playerQuest, status: 'completed', completedAt: ctx.timestamp })`
7. Grant rewards: Re-read character from DB (`ctx.db.character.id.find(characterId)`) to get fresh gold/xp, then update: `ctx.db.character.id.update({ ...freshCharacter, xp: freshCharacter.xp + quest.rewardXp, gold: freshCharacter.gold + quest.rewardGold })`
8. `appendPrivateEvent(ctx, characterId, character.ownerUserId, 'reward', \`Quest complete: ${quest.name}. You gain ${quest.rewardXp} XP and ${quest.rewardGold} gold.\`)`
9. Grant faction standing: if `quest.rewardFactionStanding > 0n`, call `mutateStanding(ctx, characterId, quest.factionId, quest.rewardFactionStanding)`. Find faction name for event message.
10. Apply rival penalty: Find faction via `ctx.db.faction.id.find(quest.factionId)`. If `faction?.rivalFactionId && quest.rivalFactionPenalty > 0n`, call `mutateStanding(ctx, characterId, faction.rivalFactionId, -(quest.rivalFactionPenalty))`. Find rival name for event message.
11. Append faction standing events (both gain and loss) using `appendPrivateEvent` with type 'faction'.

**2. Register quest reducers in `spacetimedb/src/reducers/index.ts`:**
- Import `registerQuestReducers` from `'./quests'`
- Add `registerQuestReducers(deps);` call after `registerNpcInteractionReducers(deps);`

**3. Add `mutateStanding` to `reducerDeps` in `spacetimedb/src/index.ts`:**
- `mutateStanding` is already imported from `'./helpers/economy'` at line 182
- Add `mutateStanding` to the `reducerDeps` object (add after `grantFactionStandingForKill`)
- Also add `FactionQuest` and `PlayerFactionQuest` imports from `'./schema/tables'` at the top import block, and add them to `reducerDeps`

**4. Add `updateFactionQuestProgressForKill` to combat.ts:**

In `spacetimedb/src/reducers/combat.ts`, find the `updateQuestProgressForKill` function (line ~331). Add a NEW function `updateFactionQuestProgressForKill` right after it (NOT inside it), following the same pattern:

```typescript
const updateFactionQuestProgressForKill = (
  ctx: any,
  character: any,
  enemyTemplateId: bigint
) => {
  for (const playerQuest of ctx.db.playerFactionQuest.by_character.filter(character.id)) {
    if (playerQuest.status !== 'active') continue;
    const quest = ctx.db.factionQuest.id.find(playerQuest.factionQuestId);
    if (!quest || quest.questType !== 'kill') continue;
    if (quest.targetEnemyTemplateId !== enemyTemplateId) continue;
    const required = quest.requiredCount ?? 1n;
    const nextProgress = playerQuest.progress + 1n > required ? required : playerQuest.progress + 1n;
    ctx.db.playerFactionQuest.id.update({ ...playerQuest, progress: nextProgress });
    appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
      `Faction quest progress: ${quest.name} (${nextProgress}/${required}).`);
    if (nextProgress >= required) {
      appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
        `Faction quest ready to complete: ${quest.name}. Return to claim your reward.`);
    }
  }
};
```

Then find the kill resolution loop (around line 2025) where `updateQuestProgressForKill(ctx, character, template.id)` is called. Add `updateFactionQuestProgressForKill(ctx, character, template.id);` immediately after that call, inside the same loop.

**5. Add PlayerFactionQuest cleanup to `delete_character` in `spacetimedb/src/reducers/characters.ts`:**

Find the character deletion cleanup section (around line 286, after the `questInstance` cleanup loop). Add:
```typescript
for (const row of ctx.db.playerFactionQuest.by_character.filter(characterId)) {
  ctx.db.playerFactionQuest.id.delete(row.id);
}
```

**6. Publish module and regenerate bindings:**

Run:
```bash
spacetime publish uwr --project-path spacetimedb --clear-database -y
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```
  </action>
  <verify>
1. `cd C:/projects/uwr/spacetimedb && npx tsc --noEmit` — no errors
2. `spacetime publish uwr --project-path C:/projects/uwr/spacetimedb --clear-database -y` succeeds
3. `spacetime generate --lang typescript --out-dir C:/projects/uwr/src/module_bindings --project-path C:/projects/uwr/spacetimedb` succeeds
4. Verify generated bindings contain `factionQuest` and `playerFactionQuest` tables: check `src/module_bindings/faction_quest_table.ts` and `src/module_bindings/player_faction_quest_table.ts` exist
5. `spacetime logs uwr` shows no errors during init (faction quests seeded)
  </verify>
  <done>
accept_faction_quest and complete_faction_quest reducers implemented with full validation (standing gate, duplicate prevention, completion checks). Kill progress tracking wired into combat loop. Character deletion cleans up PlayerFactionQuest rows. Module published and bindings regenerated. Server logs confirm clean initialization with seeded faction quests.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Module publishes successfully with clear-database
3. Server logs show clean init (no errors)
4. Generated bindings include FactionQuest and PlayerFactionQuest types
5. 8 faction quests seeded in database
</verification>

<success_criteria>
- FactionQuest table contains 8 seeded quests with correct faction gating (0, 1000, 3000 standing thresholds)
- PlayerFactionQuest table exists with by_character index
- accept_faction_quest reducer validates standing, prevents duplicates, creates rows
- complete_faction_quest reducer validates progress, grants XP/gold/standing, penalizes rival faction
- Kill-based progress tracking works for faction quest kill targets
- Character deletion cleans up PlayerFactionQuest rows
- Client bindings regenerated with new table types
</success_criteria>

<output>
After completion, create `.planning/phases/06-quest-system/06-01-SUMMARY.md`
</output>
