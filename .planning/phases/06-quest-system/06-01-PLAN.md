---
phase: 06-quest-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/schema/tables.ts
  - spacetimedb/src/reducers/quests.ts
  - spacetimedb/src/reducers/index.ts
  - spacetimedb/src/reducers/commands.ts
  - spacetimedb/src/reducers/combat.ts
  - spacetimedb/src/index.ts
autonomous: true

must_haves:
  truths:
    - "QuestTemplate table supports questType, targetLocationId, targetNpcId, targetItemName, itemDropChance fields"
    - "QuestItem, NamedEnemy, SearchResult tables exist as public tables"
    - "loot_quest_item reducer marks quest item as looted and advances explore quest progress"
    - "loot_quest_item is triggered by client after a client-side cast timer elapses (same pattern as resource gathering)"
    - "pull_named_enemy reducer spawns named enemy into combat"
    - "Delivery quests auto-complete when hailing the target NPC"
    - "kill_loot quests roll item drops on enemy kill and create QuestItem"
    - "updateQuestProgressForKill skips kill_loot quests so they only advance via the drop mechanic"
    - "boss_kill quests use existing kill progress tracking (no special code needed)"
  artifacts:
    - path: "spacetimedb/src/schema/tables.ts"
      provides: "Extended QuestTemplate + QuestItem + NamedEnemy + SearchResult tables"
      contains: "questType"
    - path: "spacetimedb/src/reducers/quests.ts"
      provides: "loot_quest_item and pull_named_enemy reducers"
      exports: ["registerQuestReducers"]
    - path: "spacetimedb/src/reducers/commands.ts"
      provides: "Delivery quest auto-complete in hailNpc"
      contains: "delivery"
  key_links:
    - from: "spacetimedb/src/reducers/quests.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "QuestItem and NamedEnemy table access"
      pattern: "ctx\\.db\\.questItem"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "kill_loot drop chance roll on enemy kill"
      pattern: "itemDropChance"
    - from: "spacetimedb/src/reducers/commands.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "delivery quest completion check in hailNpc"
      pattern: "targetNpcId"
---

<objective>
Extend the quest system schema with new quest type fields and three new tables (QuestItem, NamedEnemy, SearchResult), then implement the backend reducers for all new quest mechanics: loot_quest_item, pull_named_enemy, delivery auto-complete in hailNpc, and kill_loot drops in the combat kill loop.

Purpose: This plan builds the complete backend infrastructure for the four new quest types. Schema first, then all the reducer logic that operates on the new tables.

Output: Extended QuestTemplate schema, three new tables, and all quest-type-specific reducer logic wired into the existing reducer registration system.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@spacetimedb/src/schema/tables.ts
@spacetimedb/src/reducers/index.ts
@spacetimedb/src/reducers/commands.ts
@spacetimedb/src/reducers/combat.ts
@spacetimedb/src/index.ts
@spacetimedb/src/helpers/events.ts
@spacetimedb/src/helpers/location.ts
@spacetimedb/src/helpers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend QuestTemplate and add QuestItem, NamedEnemy, SearchResult tables</name>
  <files>spacetimedb/src/schema/tables.ts</files>
  <action>
1. Extend the existing `QuestTemplate` table (around line 149) by adding these optional fields AFTER the existing `rewardXp` field:
   - `questType: t.string().optional()` — values: 'kill' | 'kill_loot' | 'explore' | 'delivery' | 'boss_kill'. Default assumption: undefined = 'kill' for backwards compat
   - `targetLocationId: t.u64().optional()` — for explore/delivery quests
   - `targetNpcId: t.u64().optional()` — for delivery quest turn-in target NPC
   - `targetItemName: t.string().optional()` — display name of the loot item (kill_loot quests)
   - `itemDropChance: t.u64().optional()` — per-kill drop chance as integer percent (e.g., 25 = 25%)

2. Add a new `QuestItem` table (public) BEFORE the `spacetimedb = schema(...)` call:
```typescript
export const QuestItem = table(
  {
    name: 'quest_item',
    public: true,
    indexes: [
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
      { name: 'by_location', algorithm: 'btree', columns: ['locationId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    characterId: t.u64(),
    questTemplateId: t.u64(),
    locationId: t.u64(),
    name: t.string(),
    discovered: t.bool(),     // true when search reveals it
    looted: t.bool(),         // true when character loots it
  }
);
```

3. Add a new `NamedEnemy` table (public):
```typescript
export const NamedEnemy = table(
  {
    name: 'named_enemy',
    public: true,
    indexes: [
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
      { name: 'by_location', algorithm: 'btree', columns: ['locationId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    characterId: t.u64(),
    name: t.string(),
    enemyTemplateId: t.u64(),
    locationId: t.u64(),
    isAlive: t.bool(),
    lastKilledAt: t.timestamp().optional(),
    respawnMinutes: t.u64(),
  }
);
```

4. Add a new `SearchResult` table (public):
```typescript
export const SearchResult = table(
  {
    name: 'search_result',
    public: true,
    indexes: [
      { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
    ],
  },
  {
    id: t.u64().primaryKey().autoInc(),
    characterId: t.u64(),
    locationId: t.u64(),
    foundResources: t.bool(),
    foundQuestItem: t.bool(),
    questItemId: t.u64().optional(),
    foundNamedEnemy: t.bool(),
    namedEnemyId: t.u64().optional(),
    searchedAt: t.timestamp(),
  }
);
```

5. Add QuestItem, NamedEnemy, SearchResult to the `schema(...)` call at the bottom of the file (around line 1429+), keeping them with the other table registrations.

6. Add the new table imports to `spacetimedb/src/index.ts` alongside the existing imports from `'./schema/tables'`. Add QuestItem, NamedEnemy, SearchResult to the imports.
  </action>
  <verify>Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — should compile with no errors related to the new tables.</verify>
  <done>QuestTemplate has 5 new optional fields. QuestItem, NamedEnemy, SearchResult tables defined with proper indexes and registered in schema. All imported in index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Implement quest type reducers and integration hooks</name>
  <files>spacetimedb/src/reducers/quests.ts, spacetimedb/src/reducers/index.ts, spacetimedb/src/reducers/commands.ts, spacetimedb/src/reducers/combat.ts, spacetimedb/src/index.ts</files>
  <action>
1. Create `spacetimedb/src/reducers/quests.ts` with `registerQuestReducers(deps)` exporting two reducers:

**loot_quest_item reducer** — `{ characterId: t.u64(), questItemId: t.u64() }`:
- Use `requireCharacterOwnedBy(ctx, characterId)` for auth
- Find QuestItem by id, validate: exists, `characterId` matches, `discovered === true`, `looted === false`
- Mark as looted: `ctx.db.questItem.id.update({ ...questItem, looted: true })`
- Find matching QuestInstance (by_character, filter for questTemplateId matching questItem.questTemplateId, not completed)
- If found, set `progress = 1n`, `completed = true` (explore quests complete on single item loot)
- appendPrivateEvent with 'quest' type: "You found {questItem.name}!"
- 30% aggro chance: use deterministic roll `(characterId ^ ctx.timestamp.microsSinceUnixEpoch) % 100n`. If roll < 30n, call `ensureSpawnsForLocation(ctx, character.locationId)` then find an available spawn and start combat using `startCombatForSpawn`. If no available spawn, skip aggro. Import `startCombatForSpawn` from combat.ts and `ensureSpawnsForLocation` from helpers/location.ts via the deps object.

**IMPORTANT — Cast timer is CLIENT-SIDE only:** The `loot_quest_item` reducer itself does NOT implement any timer or delay. It simply validates and marks the item as looted when called. The cast timer follows the same pattern as resource gathering: the **client** shows a timed progress bar (e.g., 3 seconds), and only calls the `loot_quest_item` reducer when the timer elapses. The server trusts that the client waited. This is purely a UX concern handled in Plan 03's client-side code.

**pull_named_enemy reducer** — `{ characterId: t.u64(), namedEnemyId: t.u64() }`:
- Use `requireCharacterOwnedBy(ctx, characterId)` for auth
- Find NamedEnemy by id, validate: exists, `characterId` matches, `isAlive === true`
- Find the enemy template: `ctx.db.enemyTemplate.id.find(namedEnemy.enemyTemplateId)`
- Mark named enemy as not alive: `ctx.db.namedEnemy.id.update({ ...namedEnemy, isAlive: false, lastKilledAt: ctx.timestamp })`
- Use `spawnEnemyWithTemplate` (from deps) to create a single-member enemy spawn at the character's location with the named enemy's template
- Start combat for the character's group using the spawned enemy (call `startCombatForSpawn` via deps)
- appendPrivateEvent: "You engage {namedEnemy.name}!"

The deps object for registerQuestReducers needs: `spacetimedb, t, SenderError, requireCharacterOwnedBy, appendPrivateEvent, fail, ensureSpawnsForLocation, startCombatForSpawn, spawnEnemyWithTemplate, effectiveGroupId, isGroupLeaderOrSolo`. Pull these from the existing deps pattern in index.ts.

2. In `spacetimedb/src/reducers/index.ts`, add:
- `import { registerQuestReducers } from './quests';`
- Call `registerQuestReducers(deps);` in `registerReducers()`

3. In `spacetimedb/src/reducers/commands.ts`, modify the `hailNpc` function to handle delivery quest auto-complete. After the existing quest turn-in loop (around line 80, after the `return;` in the quest turn-in block), add a NEW check BEFORE the root dialogue lookup:

```typescript
// Check for delivery quest completion (new quest types)
const deliveryInstances = [...ctx.db.questInstance.by_character.filter(character.id)];
for (const qi of deliveryInstances) {
  if (qi.completed || qi.completedAt) continue;
  const qt = ctx.db.questTemplate.id.find(qi.questTemplateId);
  if (!qt) continue;
  if ((qt.questType ?? 'kill') !== 'delivery') continue;
  if (qt.targetNpcId !== npc.id) continue;

  // Delivery quest complete!
  ctx.db.questInstance.id.update({
    ...qi,
    progress: 1n,
    completed: true,
    completedAt: ctx.timestamp,
  });

  // Award XP
  const currentXp = character.xp + qt.rewardXp;
  ctx.db.character.id.update({ ...character, xp: currentXp });

  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
    `Delivery complete: ${qt.name}. ${npc.name} accepts your delivery.`);
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'reward',
    `You gain ${qt.rewardXp} XP.`);
  appendNpcDialog(ctx, character.id, npc.id,
    `${npc.name} says, "Ah, you've brought it. Thank you."`);

  // Award affinity
  awardNpcAffinity(ctx, character, npc.id, 15n);
  appendPrivateEvent(ctx, character.id, character.ownerUserId, 'faction',
    `You gain 15 affinity with ${npc.name}.`);

  // DON'T return — continue to normal hail so follow-up dialogue branches appear
}
```

Important: The delivery check must NOT return early — the character should still see the NPC's dialogue tree after the delivery so follow-up quest branches (like Scout Thessa offering new quests after receiving Marla's delivery) are visible.

4. In `spacetimedb/src/reducers/combat.ts`, add a questType guard to the existing `updateQuestProgressForKill` function AND add a kill_loot drop check. **Both changes must be inside the `registerCombatReducers` closure** where `deps` is in scope.

**Step 4a — Guard `updateQuestProgressForKill` against kill_loot quests:**
Find the `updateQuestProgressForKill` function inside `registerCombatReducers`. Add a guard that skips kill_loot quests so they are NOT advanced by the normal kill counter. Add this check inside the quest iteration loop, right after loading the quest template:

```typescript
// Skip kill_loot quests — they advance only via item drop, not kill count
if ((template.questType ?? 'kill') === 'kill_loot') continue;
```

Without this guard, kill_loot quests would incorrectly complete from kill count alone, bypassing the item drop mechanic entirely.

**Step 4b — Add `rollKillLootDrop` inside `registerCombatReducers`:**
Define `rollKillLootDrop` as a function INSIDE the `registerCombatReducers` closure (NOT as a module-level const), because it needs access to `deps.appendPrivateEvent`. Place it near `updateQuestProgressForKill`:

```typescript
function rollKillLootDrop(
  ctx: any,
  character: any,
  enemyTemplateId: bigint
) {
  // Check for active kill_loot quests targeting this enemy
  for (const quest of ctx.db.questInstance.by_character.filter(character.id)) {
    if (quest.completed) continue;
    const template = ctx.db.questTemplate.id.find(quest.questTemplateId);
    if (!template) continue;
    if ((template.questType ?? 'kill') !== 'kill_loot') continue;
    if (template.targetEnemyTemplateId !== enemyTemplateId) continue;

    // Roll drop chance
    const dropChance = template.itemDropChance ?? 25n;
    const roll = (character.id ^ ctx.timestamp.microsSinceUnixEpoch) % 100n;
    if (roll < dropChance) {
      // Item drops! Create a QuestItem (discovered + looted since it drops directly)
      ctx.db.questItem.insert({
        id: 0n,
        characterId: character.id,
        questTemplateId: template.id,
        locationId: character.locationId,
        name: template.targetItemName ?? 'Quest Item',
        discovered: true,
        looted: true,
      });

      // Update quest progress
      const nextProgress = quest.progress + 1n;
      const isComplete = nextProgress >= template.requiredCount;
      ctx.db.questInstance.id.update({
        ...quest,
        progress: nextProgress,
        completed: isComplete,
        completedAt: quest.completedAt,
      });

      deps.appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
        `${template.targetItemName ?? 'Quest item'} drops! (${nextProgress}/${template.requiredCount})`);

      if (isComplete) {
        deps.appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
          `Quest ready to turn in: ${template.name}. Return to the quest giver.`);
      }
    } else {
      deps.appendPrivateEvent(ctx, character.id, character.ownerUserId, 'quest',
        `No ${template.targetItemName ?? 'quest item'} dropped this time.`);
    }
  }
}
```

Call `rollKillLootDrop(ctx, character, enemyTemplateId)` right after the existing `updateQuestProgressForKill(ctx, character, enemyTemplateId)` call in the combat kill resolution.

Note: boss_kill quests reuse the existing `updateQuestProgressForKill` — NamedEnemy uses the same `enemyTemplateId` as regular enemies, so the existing hook handles it automatically. No special code needed.

5. In `spacetimedb/src/index.ts`, ensure `startCombatForSpawn` and `spawnEnemyWithTemplate` are passed through the deps object to `registerReducers`. Check if they're already in deps; if not, add them.
  </action>
  <verify>Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` — should compile with no errors. Verify that `registerQuestReducers` is imported and called in reducers/index.ts. Verify that `updateQuestProgressForKill` contains the kill_loot skip guard. Verify that `rollKillLootDrop` is defined inside `registerCombatReducers`, not at module level.</verify>
  <done>All four new quest types have backend logic: kill_loot drops from combat kills (with updateQuestProgressForKill guarded to skip kill_loot quests), explore completes via loot_quest_item reducer (server validates + marks looted, cast timer is client-side UX only), delivery auto-completes in hailNpc (without blocking normal dialogue), boss_kill uses existing kill tracking. Named enemy pull spawns combat. Aggro chance on quest item loot works. rollKillLootDrop is scoped inside registerCombatReducers where deps is available.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project spacetimedb/tsconfig.json` compiles cleanly
- QuestTemplate has questType, targetLocationId, targetNpcId, targetItemName, itemDropChance fields
- QuestItem, NamedEnemy, SearchResult tables are in schema() export
- reducers/quests.ts exports registerQuestReducers with loot_quest_item and pull_named_enemy
- reducers/index.ts imports and calls registerQuestReducers
- commands.ts hailNpc checks for delivery quest completion before dialogue
- combat.ts updateQuestProgressForKill skips kill_loot quests (questType guard present)
- combat.ts rollKillLootDrop is defined inside registerCombatReducers closure and called after updateQuestProgressForKill
</verification>

<success_criteria>
- All new schema fields and tables compile without errors
- Quest type reducer file exists with proper registration
- Delivery auto-complete wired into hailNpc without blocking dialogue flow
- Kill loot drops wired into combat kill loop, kill_loot quests excluded from normal kill counter
- loot_quest_item reducer is a simple validate+mark (cast timer is client-side, same as resource gathering)
- No existing functionality broken (existing kill quests still work)
</success_criteria>

<output>
After completion, create `.planning/phases/06-quest-system/06-01-SUMMARY.md`
</output>
