---
phase: 03-renown-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spacetimedb/src/index.ts
  - spacetimedb/src/data/faction_data.ts
  - spacetimedb/src/views/faction.ts
  - spacetimedb/src/views/types.ts
  - spacetimedb/src/views/index.ts
  - spacetimedb/src/reducers/characters.ts
  - spacetimedb/src/reducers/combat.ts
  - src/module_bindings/
autonomous: true

must_haves:
  truths:
    - "4 factions exist in the Faction table after syncAllContent runs (Iron Compact, Verdant Circle, Ashen Order, Free Blades)"
    - "Each faction has a rivalFactionId pointing to its rival (Iron Compact <-> Verdant Circle, Ashen Order <-> Free Blades)"
    - "Creating a character inserts FactionStanding rows for all 4 factions at standing 0"
    - "Deleting a character cleans up all associated FactionStanding rows"
    - "Killing a faction-associated enemy grants standing to that faction and reduces standing with its rival"
    - "my_faction_standings view returns the authenticated player's FactionStanding rows"
    - "Client bindings include Faction, FactionStanding, myFactionStandings types"
  artifacts:
    - path: "spacetimedb/src/data/faction_data.ts"
      provides: "FACTION_DATA constant and ensureFactions two-phase seeding function"
      contains: "ensureFactions"
    - path: "spacetimedb/src/views/faction.ts"
      provides: "my_faction_standings view registration"
      contains: "my_faction_standings"
    - path: "spacetimedb/src/index.ts"
      provides: "Faction and FactionStanding table definitions, schema export, reducerDeps, syncAllContent wiring"
      contains: "FactionStanding"
  key_links:
    - from: "spacetimedb/src/data/faction_data.ts"
      to: "spacetimedb/src/index.ts"
      via: "ensureFactions imported and called in syncAllContent"
      pattern: "ensureFactions"
    - from: "spacetimedb/src/views/faction.ts"
      to: "spacetimedb/src/views/index.ts"
      via: "registerFactionViews imported and called in registerViews"
      pattern: "registerFactionViews"
    - from: "spacetimedb/src/reducers/combat.ts"
      to: "spacetimedb/src/index.ts"
      via: "grantFactionStandingForKill called from kill resolution loop via deps"
      pattern: "grantFactionStandingForKill"
    - from: "spacetimedb/src/reducers/characters.ts"
      to: "spacetimedb/src/index.ts"
      via: "FactionStanding insert in create_character and delete in delete_character via deps"
      pattern: "factionStanding"
---

<objective>
Backend faction standing system: Faction table with 4 factions, FactionStanding table for per-character per-faction standing, seeding, character lifecycle hooks, combat-based standing grants with rival penalties, and my_faction_standings view.

Purpose: Establishes the server-side data model and mutation logic for the renown system. Characters track standing with each faction, standing changes on combat kills, and the view exposes standings to the authenticated client.

Output: Published SpacetimeDB module with Faction + FactionStanding tables, regenerated client bindings, all CRUD and query paths functional.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-renown-foundation/03-RESEARCH.md
@.planning/phases/01-races/01-01-SUMMARY.md

# Key source files to read before starting
@spacetimedb/src/index.ts
@spacetimedb/src/data/races.ts
@spacetimedb/src/views/quests.ts
@spacetimedb/src/views/types.ts
@spacetimedb/src/views/index.ts
@spacetimedb/src/reducers/characters.ts
@spacetimedb/src/reducers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Faction and FactionStanding tables, faction seeding, and schema wiring</name>
  <files>
    spacetimedb/src/index.ts
    spacetimedb/src/data/faction_data.ts
  </files>
  <action>
**Create `spacetimedb/src/data/faction_data.ts`** (new file) following the `spacetimedb/src/data/races.ts` pattern exactly:

1. Define `FACTION_DATA` constant array with 4 factions:
   - `{ name: 'Iron Compact', description: 'A militaristic union of smiths, soldiers, and engineers who maintain order through strength.', rivalName: 'Verdant Circle' }`
   - `{ name: 'Verdant Circle', description: 'Druids, herbalists, and wildlands defenders who oppose industrialization and expansion.', rivalName: 'Iron Compact' }`
   - `{ name: 'Ashen Order', description: 'A secretive brotherhood of scholars devoted to ancient rituals and forbidden knowledge.', rivalName: 'Free Blades' }`
   - `{ name: 'Free Blades', description: 'An unaligned guild of mercenaries, rogues, and adventurers who answer to no authority.', rivalName: 'Ashen Order' }`

2. Define `ensureFactions(ctx: any)` function with two-phase seeding:
   - Phase 1: For each FACTION_DATA entry, find existing by name via `[...ctx.db.faction.iter()].find(row => row.name === data.name)`. If found, update description. If not, insert with `{ id: 0n, name, description, rivalFactionId: undefined }`.
   - Phase 2: For each FACTION_DATA entry with a rivalName, find the faction row and rival row by name, then update `rivalFactionId` if not already set.
   - Export both `FACTION_DATA` and `ensureFactions`.

**Modify `spacetimedb/src/index.ts`:**

1. **Add Faction table definition** (near Race table, before schema export):
   ```typescript
   const Faction = table(
     { name: 'faction', public: true },
     {
       id: t.u64().primaryKey().autoInc(),
       name: t.string(),
       description: t.string(),
       rivalFactionId: t.u64().optional(),
     }
   );
   ```

2. **Add FactionStanding table definition** (after Faction):
   ```typescript
   const FactionStanding = table(
     {
       name: 'faction_standing',
       indexes: [
         { name: 'by_character', algorithm: 'btree', columns: ['characterId'] },
       ],
     },
     {
       id: t.u64().primaryKey().autoInc(),
       characterId: t.u64(),
       factionId: t.u64(),
       standing: t.i64(),
     }
   );
   ```
   CRITICAL: Single-column index `by_character` ONLY. No multi-column indexes. No composite PK.

3. **Add both to `schema()` export** (find the `schema(...)` call and add `Faction, FactionStanding` to it).

4. **Add `factionId: t.u64().optional()` to EnemyTemplate** table definition. This is a non-breaking optional field addition. Existing enemy inserts remain valid.

5. **Import and wire ensureFactions into syncAllContent:**
   - Add `import { FACTION_DATA, ensureFactions } from './data/faction_data';` at top of file.
   - Call `ensureFactions(ctx);` inside `syncAllContent` function, after `ensureRaces(ctx)`.

6. **Add faction-associated `factionId` values to existing enemy template seeding** in `ensureEnemyTemplatesAndRoles`. Look at the existing enemy template names and assign factionId based on:
   - Iron Compact: soldiers, guards, sentinels — martial/military enemies
   - Verdant Circle: beasts, treants, nature spirits — nature enemies
   - Ashen Order: undead, cultists, wraiths — dark magic enemies
   - Free Blades: bandits, rogues, thieves — outlaw enemies
   Read the existing enemy names to determine which ones get which factionId. Assign factionId by looking up the faction by name: `[...ctx.db.faction.iter()].find(r => r.name === 'Iron Compact')?.id`. For enemies that don't fit any faction, leave `factionId: undefined`.

7. **Define standing mutation helpers** as module-level functions (before reducerDeps):

   ```typescript
   const STANDING_PER_KILL = 10n;
   const RIVAL_STANDING_PENALTY = 5n;

   function mutateStanding(ctx: any, characterId: bigint, factionId: bigint, delta: bigint) {
     const rows = [...ctx.db.factionStanding.by_character.filter(characterId)];
     const existing = rows.find((row: any) => row.factionId === factionId);
     if (existing) {
       ctx.db.factionStanding.id.update({ ...existing, standing: existing.standing + delta });
     } else {
       ctx.db.factionStanding.insert({ id: 0n, characterId, factionId, standing: delta });
     }
   }

   function grantFactionStandingForKill(ctx: any, character: any, enemyTemplateId: bigint) {
     const template = ctx.db.enemyTemplate.id.find(enemyTemplateId);
     if (!template?.factionId) return;
     const faction = ctx.db.faction.id.find(template.factionId);
     if (!faction) return;
     mutateStanding(ctx, character.id, faction.id, STANDING_PER_KILL);
     if (faction.rivalFactionId) {
       mutateStanding(ctx, character.id, faction.rivalFactionId, -RIVAL_STANDING_PENALTY);
     }
   }
   ```
   Note: `appendPrivateEvent` for standing gain notification is optional here — add it if the function is accessible in scope. The key is the standing mutation.

8. **Add to `reducerDeps` object:**
   - `Faction`
   - `FactionStanding`
   - `grantFactionStandingForKill`

  </action>
  <verify>
Run `npx tsc --noEmit --project spacetimedb/tsconfig.json` (or equivalent TypeScript check on the server module). No type errors on new table definitions, faction_data.ts, or standing helpers. Confirm `Faction` and `FactionStanding` are in the `schema()` call. Confirm `ensureFactions` is called in `syncAllContent`. Confirm `factionId` is on EnemyTemplate.
  </verify>
  <done>
Faction and FactionStanding tables defined in schema. FACTION_DATA seeding with two-phase rival wiring. EnemyTemplate has factionId optional field. Standing mutation helpers (mutateStanding, grantFactionStandingForKill) defined. All wired into schema(), syncAllContent, and reducerDeps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire faction standing into character lifecycle and combat, add view, publish and regenerate bindings</name>
  <files>
    spacetimedb/src/reducers/characters.ts
    spacetimedb/src/reducers/combat.ts
    spacetimedb/src/views/faction.ts
    spacetimedb/src/views/types.ts
    spacetimedb/src/views/index.ts
    spacetimedb/src/index.ts
    src/module_bindings/
  </files>
  <action>
**1. Create `spacetimedb/src/views/faction.ts`** (new file) following `spacetimedb/src/views/quests.ts` exactly:

```typescript
import type { ViewDeps } from './types';

export const registerFactionViews = ({ spacetimedb, t, FactionStanding }: ViewDeps) => {
  spacetimedb.view(
    { name: 'my_faction_standings', public: true },
    t.array(FactionStanding.rowType),
    (ctx: any) => {
      const player = ctx.db.player.id.find(ctx.sender);
      if (!player?.activeCharacterId) return [];
      return [...ctx.db.factionStanding.by_character.filter(player.activeCharacterId)];
    }
  );
};
```

CRITICAL: Use `.by_character.filter()` — NOT `.iter()`. Views cannot use `.iter()`.

**2. Update `spacetimedb/src/views/types.ts`:**
Add `Faction: any;` and `FactionStanding: any;` to the ViewDeps type interface.

**3. Update `spacetimedb/src/views/index.ts`:**
- Import `registerFactionViews` from `'./faction'`.
- Call `registerFactionViews(deps)` inside `registerViews` function.

**4. Update the `registerViews(...)` call in `spacetimedb/src/index.ts`:**
Add `Faction` and `FactionStanding` to the deps object passed to `registerViews()`.

**5. Update `spacetimedb/src/reducers/characters.ts` — `create_character`:**
After the character insert and `grantStarterItems` call (and before `appendPrivateEvent`), add:
```typescript
// Initialize FactionStanding for all factions at 0
for (const faction of ctx.db.faction.iter()) {
  ctx.db.factionStanding.insert({
    id: 0n,
    characterId: character.id,
    factionId: faction.id,
    standing: 0n,
  });
}
```
Access `ctx.db.faction` and `ctx.db.factionStanding` — these are available because Faction and FactionStanding are now in the schema. If the reducer uses a `deps` pattern for table access, use `deps.Faction` / `deps.FactionStanding` accordingly. Read the file first to understand how other table accesses work in `create_character`.

**6. Update `spacetimedb/src/reducers/characters.ts` — `delete_character`:**
In the deletion cleanup section (where QuestInstance rows and other related data are cleaned up), add:
```typescript
for (const row of ctx.db.factionStanding.by_character.filter(characterId)) {
  ctx.db.factionStanding.id.delete(row.id);
}
```

**7. Update `spacetimedb/src/reducers/combat.ts` — kill resolution loop:**
Find the kill resolution loop (around line 1805, where `updateQuestProgressForKill` is called). Add `deps.grantFactionStandingForKill(ctx, character, template.id);` right after the `updateQuestProgressForKill` call, inside the same loop.

**8. Publish module and regenerate bindings:**
```bash
spacetime publish uwr --clear-database -y --project-path spacetimedb
spacetime generate --lang typescript --out-dir src/module_bindings --project-path spacetimedb
```

Verify generated bindings include faction-related types by checking for `faction` in the generated files.

**9. Verify TypeScript compilation of client:**
Run `npx tsc --noEmit` from the project root. Fix any type errors in client code caused by new or changed bindings (e.g., if `tables.faction`, `tables.factionStanding`, or `tables.myFactionStandings` need to be referenced correctly).
  </action>
  <verify>
1. `spacetime logs uwr` shows no errors after publish.
2. Generated bindings in `src/module_bindings/` include faction-related files (search for `faction` in filenames).
3. `npx tsc --noEmit` passes with no errors.
4. Check `spacetime sql uwr "SELECT * FROM faction"` returns 4 faction rows with rivalFactionId populated.
5. Check `spacetime sql uwr "SELECT * FROM faction_standing"` returns empty (no characters yet, but table exists).
  </verify>
  <done>
my_faction_standings view registered and functional. Character creation inserts FactionStanding rows for all 4 factions at standing 0. Character deletion cleans up FactionStanding rows. Combat kills of faction-associated enemies call grantFactionStandingForKill which mutates standing and applies rival penalty. Module published, bindings regenerated, client TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. `spacetime sql uwr "SELECT * FROM faction"` returns 4 rows: Iron Compact, Verdant Circle, Ashen Order, Free Blades — each with a non-null `rivalFactionId`.
2. `spacetime sql uwr "SELECT * FROM enemy_template WHERE faction_id IS NOT NULL"` returns at least 1 enemy per faction (or some enemies with factionId set).
3. After creating a character via the client, `spacetime sql uwr "SELECT * FROM faction_standing"` shows 4 new rows for that character, all with standing=0.
4. The `my_faction_standings` view is registered (check `spacetime logs uwr` for view registration).
5. Generated bindings in `src/module_bindings/` include faction table types.
6. No TypeScript errors in client or server code.
</verification>

<success_criteria>
- Faction table seeded with 4 factions, each with correct rivalFactionId
- FactionStanding table exists with by_character index
- EnemyTemplate has factionId field, at least some enemies assigned to factions
- Character creation initializes 4 FactionStanding rows at standing 0
- Character deletion cleans up FactionStanding rows
- grantFactionStandingForKill mutates standing (+10 primary, -5 rival) for faction-associated enemy kills
- my_faction_standings view returns standings for authenticated player
- Module published, bindings regenerated, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-renown-foundation/03-01-SUMMARY.md`
</output>
