---
phase: 21-race-expansion
plan: 02
type: execute
wave: 2
depends_on:
  - "21-01"
files_modified:
  - spacetimedb/src/helpers/combat.ts
  - spacetimedb/src/reducers/commands.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true
requirements:
  - RACE-EXP-03
  - RACE-EXP-04
  - RACE-EXP-05

must_haves:
  truths:
    - "Leveling a character to an even level (2, 4, 6, 8, 10) re-applies racial bonuses with flat additive stacking (half the base value per even level)"
    - "Leveling to an odd level does NOT re-apply racial bonuses (class stats only)"
    - "A character who was level 10 before the fix now has correct racial stat bonuses after /level command"
    - "/unlockrace <name> sets Race.unlocked = true and broadcasts to all players"
    - "racialManaRegen and racialStaminaRegen are added to each regen tick for characters that have them"
    - "racialSpellDamage is added to raw damage when ability damageType is 'magic'"
    - "racialPhysDamage is added to raw damage when ability damageType is 'physical'"
    - "An Eldrin wizard at the same level as a Human wizard deals more damage with spell abilities"
  artifacts:
    - path: "spacetimedb/src/helpers/combat.ts"
      provides: "Fixed awardXp with even-level racial bonus stacking and notification; executeAbility applies racialSpellDamage/racialPhysDamage to raw damage"
    - path: "spacetimedb/src/reducers/commands.ts"
      provides: "Fixed level_character; new /unlockrace command"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "regen_health path reads racialManaRegen and racialStaminaRegen from Character row"
  key_links:
    - from: "spacetimedb/src/helpers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "awardXp reads race row via ctx.db.race.iter() to find race by character.race name"
      pattern: "race.name.*character.race"
    - from: "spacetimedb/src/helpers/combat.ts"
      to: "Character row"
      via: "executeAbility reads character.racialSpellDamage and character.racialPhysDamage when computing raw damage"
      pattern: "racialSpellDamage|racialPhysDamage"
    - from: "spacetimedb/src/reducers/commands.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "/unlockrace uses appendWorldEvent for broadcast"
      pattern: "appendWorldEvent"
---

<objective>
Fix the level-up racial bonus bug in awardXp (and the admin /level command), add even-level racial bonus re-application with flat additive stacking, wire racialManaRegen/racialStaminaRegen into the regen tick, wire racialSpellDamage/racialPhysDamage into combat ability damage, and implement the /unlockrace admin command.

Purpose: RACE-EXP-03 requires racial bonuses to persist and stack at even levels — the current code silently drops them. RACE-EXP-04 requires the admin unlock command. RACE-EXP-05 requires spell/physical damage bonuses to be active in combat, not just stored on the character row.
Output: awardXp preserves race bonuses every level and stacks them at even levels with notification. /level admin command fixed identically. /unlockrace command with world broadcast. Regen tick uses racial regen columns. executeAbility adds racial spell/phys damage to the raw damage calculation.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/21-race-expansion/21-CONTEXT.md
@.planning/phases/21-race-expansion/21-RESEARCH.md
@.planning/phases/21-race-expansion/21-01-SUMMARY.md
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/commands.ts
@spacetimedb/src/reducers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix awardXp level-up bug and add even-level racial bonus stacking</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
In `spacetimedb/src/helpers/combat.ts`, update the `awardXp` function (currently around lines 1899-1938).

**The bug:** When leveling up, `computeBaseStats` returns class-only stat values and they are assigned directly to the character row, silently overwriting any racial stat bonuses that were applied at creation.

**The fix + even-level stacking (flat additive):**

Replace the entire level-up block (after `const newBase = computeBaseStats(...)`) with this:

```typescript
const newBase = computeBaseStats(character.className, newLevel);

// Look up the character's race row by name (character.race is a display name string, not an ID).
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);

// Flat additive stacking formula:
//   At creation (level 1): full baseValue applied once
//   At each even level: floor(baseValue / 2) added again
//   Total at newLevel = baseValue + floor(baseValue / 2) * floor(newLevel / 2)
//
// Example — Eldrin (spell_damage base=2n):
//   Level 1 creation: +2 spell damage
//   Level 2 (app 1):  +1 more = 3 total
//   Level 4 (app 2):  +1 more = 4 total
//   Level 10 (app 5): +1 more = 7 total

const evenApplications = newLevel / 2n; // BigInt floor division

function accumulateRacialBonus(bonusType: string, baseValue: bigint,
  out: { str: bigint; dex: bigint; int: bigint; wis: bigint; cha: bigint;
         spellDmg: bigint; physDmg: bigint; maxHp: bigint; maxMana: bigint;
         manaRegen: bigint; staminaRegen: bigint; crit: bigint; armor: bigint; dodge: bigint }
) {
  // Full base at creation + half-base per even level
  const total = baseValue + (baseValue / 2n) * evenApplications;
  switch (bonusType) {
    case 'stat_str': out.str += total; break;
    case 'stat_dex': out.dex += total; break;
    case 'stat_int': out.int += total; break;
    case 'stat_wis': out.wis += total; break;
    case 'stat_cha': out.cha += total; break;
    case 'spell_damage': out.spellDmg += total; break;
    case 'phys_damage': out.physDmg += total; break;
    case 'max_hp': out.maxHp += total; break;
    case 'max_mana': out.maxMana += total; break;
    case 'mana_regen': out.manaRegen += total; break;
    case 'stamina_regen': out.staminaRegen += total; break;
    case 'crit_chance': out.crit += total; break;
    case 'armor': out.armor += total; break;
    case 'dodge': out.dodge += total; break;
  }
}

const racial = { str: 0n, dex: 0n, int: 0n, wis: 0n, cha: 0n,
  spellDmg: 0n, physDmg: 0n, maxHp: 0n, maxMana: 0n,
  manaRegen: 0n, staminaRegen: 0n, crit: 0n, armor: 0n, dodge: 0n };

if (raceRow) {
  accumulateRacialBonus(raceRow.bonus1Type, raceRow.bonus1Value, racial);
  accumulateRacialBonus(raceRow.bonus2Type, raceRow.bonus2Value, racial);
}

const updated = {
  ...character,
  level: newLevel,
  xp: newXp,
  str: newBase.str + racial.str,
  dex: newBase.dex + racial.dex,
  cha: newBase.cha + racial.cha,
  wis: newBase.wis + racial.wis,
  int: newBase.int + racial.int,
  racialSpellDamage: racial.spellDmg || undefined,
  racialPhysDamage: racial.physDmg || undefined,
  racialMaxHp: racial.maxHp || undefined,
  racialMaxMana: racial.maxMana || undefined,
  racialManaRegen: racial.manaRegen || undefined,
  racialStaminaRegen: racial.staminaRegen || undefined,
  racialCritBonus: racial.crit || undefined,
  racialArmorBonus: racial.armor || undefined,
  racialDodgeBonus: racial.dodge || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);

// Notify on even-level racial bonus re-application
if (newLevel % 2n === 0n && raceRow) {
  appendPrivateEvent(
    ctx,
    character.id,
    character.ownerUserId,
    'system',
    `Your ${raceRow.name} heritage grows stronger at level ${newLevel}.`
  );
}

return { xpGained: gained, leveledUp: true, newLevel };
```

**Formula example — Eldrin (spell_damage base=2n):**
- Level 1 (creation): +2 → total 2
- Level 2 (app 1): +1 → total 3
- Level 4 (app 2): +1 → total 4
- Level 10 (app 5): +1 → total 7

Simple, predictable, transparent to players. Can be replaced with diminishing returns in a future phase when levels 11-50 are designed.

**Important:** `appendPrivateEvent` must be imported — check if it is already imported at the top of combat.ts. If not, add the import from `helpers/events.ts`.

**All arithmetic uses BigInt:** no Number() conversions.
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Inspect awardXp for correct race row lookup: `ctx.db.race.iter()` with name match
3. Inspect accumulated formula: `baseValue + (baseValue / 2n) * evenApplications` — all BigInt
4. Inspect the even-level notification condition: `newLevel % 2n === 0n`
  </verify>
  <done>awardXp preserves racial stat bonuses at every level-up using flat additive stacking: full baseValue at creation + floor(baseValue/2) per even level. Notification message fires on even levels. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Fix level_character admin command, add /unlockrace command, wire racialManaRegen/racialStaminaRegen into regen tick</name>
  <files>
    spacetimedb/src/reducers/commands.ts
    spacetimedb/src/reducers/combat.ts
  </files>
  <action>
**A. Fix `level_character` admin reducer in `commands.ts` (same bug as awardXp):**

Find the `level_character` reducer (around lines 505-549). Replace the stat-setting block:

```typescript
// REMOVE this block:
const newBase = computeBaseStats(character.className, target);
const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str,
  dex: newBase.dex,
  cha: newBase.cha,
  wis: newBase.wis,
  int: newBase.int,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

Replace with (same flat additive formula as awardXp):

```typescript
const newBase = computeBaseStats(character.className, target);
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);
const evenApplications = target / 2n;

const racial = { str: 0n, dex: 0n, int: 0n, wis: 0n, cha: 0n,
  spellDmg: 0n, physDmg: 0n, maxHp: 0n, maxMana: 0n,
  manaRegen: 0n, staminaRegen: 0n, crit: 0n, armor: 0n, dodge: 0n };

function applyRacialBonus(bonusType: string, baseValue: bigint) {
  const total = baseValue + (baseValue / 2n) * evenApplications;
  switch (bonusType) {
    case 'stat_str': racial.str += total; break;
    case 'stat_dex': racial.dex += total; break;
    case 'stat_int': racial.int += total; break;
    case 'stat_wis': racial.wis += total; break;
    case 'stat_cha': racial.cha += total; break;
    case 'spell_damage': racial.spellDmg += total; break;
    case 'phys_damage': racial.physDmg += total; break;
    case 'max_hp': racial.maxHp += total; break;
    case 'max_mana': racial.maxMana += total; break;
    case 'mana_regen': racial.manaRegen += total; break;
    case 'stamina_regen': racial.staminaRegen += total; break;
    case 'crit_chance': racial.crit += total; break;
    case 'armor': racial.armor += total; break;
    case 'dodge': racial.dodge += total; break;
  }
}

if (raceRow) {
  applyRacialBonus(raceRow.bonus1Type, raceRow.bonus1Value);
  applyRacialBonus(raceRow.bonus2Type, raceRow.bonus2Value);
}

const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str + racial.str,
  dex: newBase.dex + racial.dex,
  cha: newBase.cha + racial.cha,
  wis: newBase.wis + racial.wis,
  int: newBase.int + racial.int,
  racialSpellDamage: racial.spellDmg || undefined,
  racialPhysDamage: racial.physDmg || undefined,
  racialMaxHp: racial.maxHp || undefined,
  racialMaxMana: racial.maxMana || undefined,
  racialManaRegen: racial.manaRegen || undefined,
  racialStaminaRegen: racial.staminaRegen || undefined,
  racialCritBonus: racial.crit || undefined,
  racialArmorBonus: racial.armor || undefined,
  racialDodgeBonus: racial.dodge || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

**B. Add `/unlockrace` command to `submit_command` in `commands.ts`:**

After the `/synccontent` block (around line 219) and before the `hailMatch` block, add:

```typescript
const unlockRaceMatch = trimmed.match(/^\/unlockrace\s+(.+)$/i);
if (unlockRaceMatch) {
  requireAdmin(ctx);
  const raceName = unlockRaceMatch[1].trim();
  let found = false;
  for (const race of ctx.db.race.iter()) {
    if (race.name.toLowerCase() === raceName.toLowerCase()) {
      if (race.unlocked) {
        appendPrivateEvent(
          ctx, character.id, requirePlayerUserId(ctx), 'system',
          `${race.name} is already unlocked.`
        );
        return;
      }
      ctx.db.race.id.update({ ...race, unlocked: true });
      appendWorldEvent(ctx, 'world_event', `A world-shaking event has occurred — the ${race.name} have emerged from hiding and may now walk among us!`);
      appendPrivateEvent(
        ctx, character.id, requirePlayerUserId(ctx), 'system',
        `Unlocked race: ${race.name}.`
      );
      found = true;
      break;
    }
  }
  if (!found) {
    appendPrivateEvent(
      ctx, character.id, requirePlayerUserId(ctx), 'system',
      `Race not found: "${raceName}". Check spelling (case-insensitive).`
    );
  }
  return;
}
```

**Import:** Update line 2 of commands.ts to add `appendWorldEvent` to the existing import:
```typescript
import { appendSystemMessage, appendWorldEvent } from '../helpers/events';
```

**C. Wire racialManaRegen and racialStaminaRegen into regen_health in `combat.ts`:**

Find the regen_health block (around line 1213-1232) where `manaRegenBonus` and `staminaRegenBonus` are summed from CharacterEffect rows:

After the CharacterEffect loop, add:
```typescript
// Add racial regen bonuses from Character row (these persist through death, unlike CharacterEffects)
manaRegenBonus += character.racialManaRegen ?? 0n;
staminaRegenBonus += character.racialStaminaRegen ?? 0n;
```

This ensures racial mana/stamina regen bonuses are applied every tick alongside food regen effects.

**D. Publish updated module (no --clear-database needed — no schema changes in this plan):**

```bash
spacetime publish <module-name> --project-path spacetimedb
```
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Check line 2 of commands.ts: `import { appendSystemMessage, appendWorldEvent } from '../helpers/events'`
3. Check submit_command for `/unlockrace` pattern match
4. Check regen_health block for `character.racialManaRegen ?? 0n` addition
5. `spacetime publish <module-name> --project-path spacetimedb` succeeds (no --clear-database)
6. `spacetime logs <module-name>` shows no errors
  </verify>
  <done>awardXp and level_character both preserve and stack racial bonuses with diminishing returns. /unlockrace command implemented with world broadcast. racialManaRegen and racialStaminaRegen added to regen tick. Module published successfully.</done>
</task>

<task type="auto">
  <name>Task 3: Wire racialSpellDamage and racialPhysDamage into executeAbility damage calculation</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
In `spacetimedb/src/helpers/combat.ts`, inside the `executeAbility` function, update the per-hit raw damage calculation in the single-target hit loop (around line 608-624).

**Current code (single-target hit loop):**
```typescript
let totalDamage = 0n;
const hitDamages: bigint[] = [];
for (let i = 0n; i < hits; i += 1n) {
  // Total raw damage
  const raw = weaponComponent + finalDirectDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);

  // Route mitigation by damage type
  const dmgType = ability?.damageType ?? 'physical';
  let reduced: bigint;
  if (dmgType === 'magic') {
    // Magic damage bypasses armor entirely (makes magic impactful)
    reduced = raw > 0n ? raw : 1n;
  } else {
    // Physical damage uses armor mitigation
    reduced = applyArmorMitigation(raw, armor);
  }
  hitDamages.push(reduced);
  totalDamage += reduced;
}
```

**Replace with** (add racial damage bonus lookup before the loop, then add to raw per hit):
```typescript
// Read racial damage bonuses from character row — these are flat additions to each hit
const racialSpellBonus = character.racialSpellDamage ?? 0n;
const racialPhysBonus = character.racialPhysDamage ?? 0n;

let totalDamage = 0n;
const hitDamages: bigint[] = [];
for (let i = 0n; i < hits; i += 1n) {
  // Route racial bonus by damage type
  const dmgType = ability?.damageType ?? 'physical';
  const racialDamageBonus = dmgType === 'magic' ? racialSpellBonus : racialPhysBonus;

  // Total raw damage (racial bonus added per hit)
  const raw = weaponComponent + finalDirectDamage + totalDamageUp + racialDamageBonus + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);

  // Route mitigation by damage type
  let reduced: bigint;
  if (dmgType === 'magic') {
    // Magic damage bypasses armor entirely (makes magic impactful)
    reduced = raw > 0n ? raw : 1n;
  } else {
    // Physical damage uses armor mitigation
    reduced = applyArmorMitigation(raw, armor);
  }
  hitDamages.push(reduced);
  totalDamage += reduced;
}
```

**Why this location:** `finalDirectDamage` is the computed ability damage after stat scaling and multipliers. Adding racial bonus here matches the pattern for `totalDamageUp` (which is also a flat per-hit bonus from CharacterEffects). The racial bonus is flat (not percentage-based) and applies every hit, consistent with how it should scale with multi-hit abilities.

**AoE path:** The AoE branch (above this loop) computes `aoeDamage` from `finalDirectDamage` only — it does not use the per-hit loop. For simplicity and consistency with scope, racial damage is wired into the single-target path only. AoE racial bonus wiring can be added in a future plan if needed.

**Publish updated module:**
```bash
spacetime publish <module-name> --project-path spacetimedb
```
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Inspect executeAbility: `racialSpellDamage ?? 0n` and `racialPhysDamage ?? 0n` assignments present before the hit loop
3. Inspect the raw damage line: includes `racialDamageBonus` term
4. `spacetime publish <module-name> --project-path spacetimedb` succeeds
5. `spacetime logs <module-name>` — no errors
  </verify>
  <done>executeAbility adds character.racialSpellDamage to raw damage for magic-type abilities and character.racialPhysDamage for physical-type abilities on every hit. TypeScript clean. Module published.</done>
</task>

</tasks>

<verification>
- TypeScript compiles clean across all modified files
- awardXp at even levels: racial bonuses use flat additive formula — `baseValue + (baseValue / 2n) * evenApplications`
- awardXp at odd levels: racial bonuses still applied (evenApplications = floor(oddLevel/2) — same formula, just fewer applications)
- level_character admin command applies identical flat additive formula
- /unlockrace command matches regex, requires admin, updates Race.unlocked, broadcasts world event
- commands.ts import: `appendWorldEvent` present
- regen_health block adds character.racialManaRegen and character.racialStaminaRegen
- executeAbility single-target hit loop adds racialSpellDamage for magic damage, racialPhysDamage for physical damage
- Module publishes without error
</verification>

<success_criteria>
- Character leveled to 2 via natural XP: str/dex/etc include racial stat bonus (baseValue + baseValue/2*1 = 1.5x base for base=2n → 3)
- Character leveled to 4: racial stat bonus increased (baseValue + baseValue/2*2 = 2x base for base=2n → 4)
- Character leveled to 10 via /level command: racial bonuses = baseValue + baseValue/2*5 = 3.5x base for base=2n → 7
- `/unlockrace Dark-Elf` (as admin) sets Dark-Elf row to unlocked=true and fires world broadcast
- `/unlockrace NotARace` returns "Race not found" private event
- Non-admin `/unlockrace` throws (requireAdmin guard)
- An Eldrin wizard firing a spell ability deals more raw damage than a Human wizard at the same level (racialSpellDamage added to each hit)
- An Ironclad warrior firing a physical ability deals more raw damage than a Human warrior at the same level (racialPhysDamage added to each hit)
</success_criteria>

<output>
After completion, create `.planning/phases/21-race-expansion/21-02-SUMMARY.md` using the summary template.
</output>
