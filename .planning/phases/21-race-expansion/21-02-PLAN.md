---
phase: 21-race-expansion
plan: 02
type: execute
wave: 2
depends_on:
  - "21-01"
files_modified:
  - spacetimedb/src/helpers/combat.ts
  - spacetimedb/src/reducers/commands.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true
requirements:
  - RACE-EXP-03
  - RACE-EXP-04

must_haves:
  truths:
    - "Leveling a character to an even level (2, 4, 6, 8, 10) re-applies racial bonuses with diminishing returns stacking"
    - "Leveling to an odd level does NOT re-apply racial bonuses (class stats only)"
    - "A character who was level 10 before the fix now has correct racial stat bonuses after /level command"
    - "/unlockrace <name> sets Race.unlocked = true and broadcasts to all players"
    - "racialManaRegen and racialStaminaRegen are added to each regen tick for characters that have them"
  artifacts:
    - path: "spacetimedb/src/helpers/combat.ts"
      provides: "Fixed awardXp with even-level racial bonus stacking and notification"
    - path: "spacetimedb/src/reducers/commands.ts"
      provides: "Fixed level_character; new /unlockrace command"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "regen_health path reads racialManaRegen and racialStaminaRegen from Character row"
  key_links:
    - from: "spacetimedb/src/helpers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "awardXp reads race row via ctx.db.race.iter() to find race by character.race name"
      pattern: "race.name.*character.race"
    - from: "spacetimedb/src/reducers/commands.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "/unlockrace uses appendWorldEvent for broadcast"
      pattern: "appendWorldEvent"
---

<objective>
Fix the level-up racial bonus bug in awardXp (and the admin /level command), add even-level racial bonus re-application with diminishing returns stacking, wire racialManaRegen/racialStaminaRegen into the regen tick, and implement the /unlockrace admin command.

Purpose: RACE-EXP-03 requires racial bonuses to persist and stack at even levels — the current code silently drops them. RACE-EXP-04 requires the admin unlock command.
Output: awardXp preserves race bonuses every level and stacks them at even levels with notification. /level admin command fixed identically. /unlockrace command with world broadcast. Regen tick uses racial regen columns.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/21-race-expansion/21-CONTEXT.md
@.planning/phases/21-race-expansion/21-RESEARCH.md
@.planning/phases/21-race-expansion/21-01-SUMMARY.md
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/commands.ts
@spacetimedb/src/reducers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix awardXp level-up bug and add even-level racial bonus stacking</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
In `spacetimedb/src/helpers/combat.ts`, update the `awardXp` function (currently around lines 1899-1938).

**The bug:** When leveling up, `computeBaseStats` returns class-only stat values and they are assigned directly to the character row, silently overwriting any racial stat bonuses that were applied at creation.

**The fix + even-level stacking:**

Replace the entire level-up block (after `const newBase = computeBaseStats(...)`) with this:

```typescript
const newBase = computeBaseStats(character.className, newLevel);

// Look up the character's race row by name (character.race is a display name string, not an ID).
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);

// Compute racial stat bonuses for the new level.
// Stacking formula (diminishing returns, BigInt arithmetic):
//   Level 1 = 1 application (initial)
//   Each even level adds another application at 50% of base value
//   Total bonus = baseValue + floor(baseValue * evenLevelCount / 2)
// At level 10: 5 even levels → baseValue + floor(baseValue * 5/2) = 2.5x → effectively 3x for whole numbers
// Example: +1 stat at level 10 = 1 + floor(1*5/2) = 1 + 2 = 3 total
const evenLevelCount = newLevel / 2n;  // BigInt integer division floors automatically

let racialStr = 0n, racialDex = 0n, racialInt = 0n, racialWis = 0n, racialCha = 0n;
let racialSpellDamage = 0n, racialPhysDamage = 0n;
let racialMaxHp = 0n, racialMaxMana = 0n;
let racialManaRegen = 0n, racialStaminaRegen = 0n;
let racialCritBonus = 0n, racialArmorBonus = 0n, racialDodgeBonus = 0n;

if (raceRow) {
  function accumulateBonus(bonusType: string, baseValue: bigint) {
    // Total accumulated value across all applications up to newLevel
    const accumulated = baseValue + (baseValue * evenLevelCount) / 2n;
    switch (bonusType) {
      case 'stat_str': racialStr += accumulated; break;
      case 'stat_dex': racialDex += accumulated; break;
      case 'stat_int': racialInt += accumulated; break;
      case 'stat_wis': racialWis += accumulated; break;
      case 'stat_cha': racialCha += accumulated; break;
      case 'spell_damage': racialSpellDamage += accumulated; break;
      case 'phys_damage': racialPhysDamage += accumulated; break;
      case 'max_hp': racialMaxHp += accumulated; break;
      case 'max_mana': racialMaxMana += accumulated; break;
      case 'mana_regen': racialManaRegen += accumulated; break;
      case 'stamina_regen': racialStaminaRegen += accumulated; break;
      case 'crit_chance': racialCritBonus += accumulated; break;
      case 'armor': racialArmorBonus += accumulated; break;
      case 'dodge': racialDodgeBonus += accumulated; break;
    }
  }
  accumulateBonus(raceRow.bonus1Type, raceRow.bonus1Value);
  accumulateBonus(raceRow.bonus2Type, raceRow.bonus2Value);
}

const updated = {
  ...character,
  level: newLevel,
  xp: newXp,
  str: newBase.str + racialStr,
  dex: newBase.dex + racialDex,
  cha: newBase.cha + racialCha,
  wis: newBase.wis + racialWis,
  int: newBase.int + racialInt,
  racialSpellDamage: racialSpellDamage || undefined,
  racialPhysDamage: racialPhysDamage || undefined,
  racialMaxHp: racialMaxHp || undefined,
  racialMaxMana: racialMaxMana || undefined,
  racialManaRegen: racialManaRegen || undefined,
  racialStaminaRegen: racialStaminaRegen || undefined,
  racialCritBonus: racialCritBonus || undefined,
  racialArmorBonus: racialArmorBonus || undefined,
  racialDodgeBonus: racialDodgeBonus || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);

// Notify on even-level racial bonus re-application
if (newLevel % 2n === 0n && raceRow) {
  appendPrivateEvent(
    ctx,
    character.id,
    character.ownerUserId,
    'system',
    `Your ${raceRow.name} heritage deepens at level ${newLevel} — racial bonuses strengthen.`
  );
}

return { xpGained: gained, leveledUp: true, newLevel };
```

**Important:** The `accumulateBonus` helper is defined inside the if-block. The `appendPrivateEvent` function must be imported — check if it is already imported at the top of combat.ts. If not, add the import from `helpers/events.ts`.

**All arithmetic uses BigInt:** `newLevel / 2n`, `evenLevelCount`, bonus values from race row are all already bigint. No Number mixing.
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Inspect awardXp for correct race row lookup: `ctx.db.race.iter()` with name match
3. Inspect the even-level condition: `newLevel % 2n === 0n`
  </verify>
  <done>awardXp preserves racial stat bonuses at every level-up. At even levels, stacked value using formula `baseValue + floor(baseValue * evenLevelCount / 2n)` is written to all racial fields. Notification message fires on even levels. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Fix level_character admin command, add /unlockrace command, wire racialManaRegen/racialStaminaRegen into regen tick</name>
  <files>
    spacetimedb/src/reducers/commands.ts
    spacetimedb/src/reducers/combat.ts
  </files>
  <action>
**A. Fix `level_character` admin reducer in `commands.ts` (same bug as awardXp):**

Find the `level_character` reducer (around lines 505-549). Replace the stat-setting block:

```typescript
// REMOVE this block:
const newBase = computeBaseStats(character.className, target);
const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str,
  dex: newBase.dex,
  cha: newBase.cha,
  wis: newBase.wis,
  int: newBase.int,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

Replace with (same formula as awardXp — copy the racial accumulation logic):

```typescript
const newBase = computeBaseStats(character.className, target);
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);
const evenLevelCount = target / 2n;

let racialStr = 0n, racialDex = 0n, racialInt = 0n, racialWis = 0n, racialCha = 0n;
let racialSpellDamage = 0n, racialPhysDamage = 0n;
let racialMaxHp = 0n, racialMaxMana = 0n;
let racialManaRegen = 0n, racialStaminaRegen = 0n;
let racialCritBonus = 0n, racialArmorBonus = 0n, racialDodgeBonus = 0n;

if (raceRow) {
  function accumulateCmd(bonusType: string, baseValue: bigint) {
    const accumulated = baseValue + (baseValue * evenLevelCount) / 2n;
    switch (bonusType) {
      case 'stat_str': racialStr += accumulated; break;
      case 'stat_dex': racialDex += accumulated; break;
      case 'stat_int': racialInt += accumulated; break;
      case 'stat_wis': racialWis += accumulated; break;
      case 'stat_cha': racialCha += accumulated; break;
      case 'spell_damage': racialSpellDamage += accumulated; break;
      case 'phys_damage': racialPhysDamage += accumulated; break;
      case 'max_hp': racialMaxHp += accumulated; break;
      case 'max_mana': racialMaxMana += accumulated; break;
      case 'mana_regen': racialManaRegen += accumulated; break;
      case 'stamina_regen': racialStaminaRegen += accumulated; break;
      case 'crit_chance': racialCritBonus += accumulated; break;
      case 'armor': racialArmorBonus += accumulated; break;
      case 'dodge': racialDodgeBonus += accumulated; break;
    }
  }
  accumulateCmd(raceRow.bonus1Type, raceRow.bonus1Value);
  accumulateCmd(raceRow.bonus2Type, raceRow.bonus2Value);
}

const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str + racialStr,
  dex: newBase.dex + racialDex,
  cha: newBase.cha + racialCha,
  wis: newBase.wis + racialWis,
  int: newBase.int + racialInt,
  racialSpellDamage: racialSpellDamage || undefined,
  racialPhysDamage: racialPhysDamage || undefined,
  racialMaxHp: racialMaxHp || undefined,
  racialMaxMana: racialMaxMana || undefined,
  racialManaRegen: racialManaRegen || undefined,
  racialStaminaRegen: racialStaminaRegen || undefined,
  racialCritBonus: racialCritBonus || undefined,
  racialArmorBonus: racialArmorBonus || undefined,
  racialDodgeBonus: racialDodgeBonus || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

**B. Add `/unlockrace` command to `submit_command` in `commands.ts`:**

After the `/synccontent` block (around line 219) and before the `hailMatch` block, add:

```typescript
const unlockRaceMatch = trimmed.match(/^\/unlockrace\s+(.+)$/i);
if (unlockRaceMatch) {
  requireAdmin(ctx);
  const raceName = unlockRaceMatch[1].trim();
  let found = false;
  for (const race of ctx.db.race.iter()) {
    if (race.name.toLowerCase() === raceName.toLowerCase()) {
      if (race.unlocked) {
        appendPrivateEvent(
          ctx, character.id, requirePlayerUserId(ctx), 'system',
          `${race.name} is already unlocked.`
        );
        return;
      }
      ctx.db.race.id.update({ ...race, unlocked: true });
      appendWorldEvent(ctx, 'world_event', `A world-shaking event has occurred — the ${race.name} have emerged from hiding and may now walk among us!`);
      appendPrivateEvent(
        ctx, character.id, requirePlayerUserId(ctx), 'system',
        `Unlocked race: ${race.name}.`
      );
      found = true;
      break;
    }
  }
  if (!found) {
    appendPrivateEvent(
      ctx, character.id, requirePlayerUserId(ctx), 'system',
      `Race not found: "${raceName}". Check spelling (case-insensitive).`
    );
  }
  return;
}
```

**Import check:** `appendWorldEvent` must be available in commands.ts. Check the imports at the top of the file. If `appendWorldEvent` is not already imported, add:
```typescript
import { appendWorldEvent } from '../helpers/events';
```
(matching the import style used for `appendSystemMessage` or `appendPrivateEvent` already in commands.ts).

**C. Wire racialManaRegen and racialStaminaRegen into regen_health in `combat.ts`:**

Find the regen_health block (around line 1213-1232) where `manaRegenBonus` and `staminaRegenBonus` are summed from CharacterEffect rows:

After the CharacterEffect loop, add:
```typescript
// Add racial regen bonuses from Character row (these persist through death, unlike CharacterEffects)
manaRegenBonus += character.racialManaRegen ?? 0n;
staminaRegenBonus += character.racialStaminaRegen ?? 0n;
```

This ensures racial mana/stamina regen bonuses are applied every tick alongside food regen effects.

**D. Publish updated module (no --clear-database needed — no schema changes in this plan):**

```bash
spacetime publish <module-name> --project-path spacetimedb
```
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Check commands.ts imports include appendWorldEvent (or that it's accessible)
3. Check submit_command for `/unlockrace` pattern match
4. Check regen_health block for `character.racialManaRegen ?? 0n` addition
5. `spacetime publish <module-name> --project-path spacetimedb` succeeds (no --clear-database)
6. `spacetime logs <module-name>` shows no errors
  </verify>
  <done>awardXp and level_character both preserve and stack racial bonuses. /unlockrace command implemented with world broadcast. racialManaRegen and racialStaminaRegen added to regen tick. Module published successfully.</done>
</task>

</tasks>

<verification>
- TypeScript compiles clean across all modified files
- awardXp at even levels: racial stat bonuses use formula `baseValue + floor(baseValue * evenLevelCount / 2n)`
- awardXp at odd levels: racial bonuses still applied (just 1 application so far — no stack yet at odd level beyond 1)
- level_character admin command applies same formula
- /unlockrace command matches regex, requires admin, updates Race.unlocked, broadcasts world event
- regen_health block adds character.racialManaRegen and character.racialStaminaRegen
- Module publishes without error
</verification>

<success_criteria>
- Character leveled to 2 via natural XP: str/dex/etc include racial stat bonus + 50% stack (for stat-type races)
- Character leveled to 10 via /level command: racial bonuses show stacked value
- `/unlockrace Dark-Elf` (as admin) sets Dark-Elf row to unlocked=true and fires world broadcast
- `/unlockrace NotARace` returns "Race not found" private event
- Non-admin `/unlockrace` throws (requireAdmin guard)
</success_criteria>

<output>
After completion, create `.planning/phases/21-race-expansion/21-02-SUMMARY.md` using the summary template.
</output>
