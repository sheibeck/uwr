---
phase: 21-race-expansion
plan: 02
type: execute
wave: 2
depends_on:
  - "21-01"
files_modified:
  - spacetimedb/src/helpers/combat.ts
  - spacetimedb/src/reducers/commands.ts
  - spacetimedb/src/reducers/combat.ts
autonomous: true
requirements:
  - RACE-EXP-03
  - RACE-EXP-04
  - RACE-EXP-05

must_haves:
  truths:
    - "Leveling a character to an even level (2, 4, 6, 8, 10) re-applies racial bonuses with diminishing returns stacking"
    - "Leveling to an odd level does NOT re-apply racial bonuses (class stats only)"
    - "A character who was level 10 before the fix now has correct racial stat bonuses after /level command"
    - "/unlockrace <name> sets Race.unlocked = true and broadcasts to all players"
    - "racialManaRegen and racialStaminaRegen are added to each regen tick for characters that have them"
    - "racialSpellDamage is added to raw damage when ability damageType is 'magic'"
    - "racialPhysDamage is added to raw damage when ability damageType is 'physical'"
    - "An Eldrin wizard at the same level as a Human wizard deals more damage with spell abilities"
  artifacts:
    - path: "spacetimedb/src/helpers/combat.ts"
      provides: "Fixed awardXp with even-level racial bonus stacking and notification; executeAbility applies racialSpellDamage/racialPhysDamage to raw damage"
    - path: "spacetimedb/src/reducers/commands.ts"
      provides: "Fixed level_character; new /unlockrace command"
    - path: "spacetimedb/src/reducers/combat.ts"
      provides: "regen_health path reads racialManaRegen and racialStaminaRegen from Character row"
  key_links:
    - from: "spacetimedb/src/helpers/combat.ts"
      to: "spacetimedb/src/schema/tables.ts"
      via: "awardXp reads race row via ctx.db.race.iter() to find race by character.race name"
      pattern: "race.name.*character.race"
    - from: "spacetimedb/src/helpers/combat.ts"
      to: "Character row"
      via: "executeAbility reads character.racialSpellDamage and character.racialPhysDamage when computing raw damage"
      pattern: "racialSpellDamage|racialPhysDamage"
    - from: "spacetimedb/src/reducers/commands.ts"
      to: "spacetimedb/src/helpers/world_events.ts"
      via: "/unlockrace uses appendWorldEvent for broadcast"
      pattern: "appendWorldEvent"
---

<objective>
Fix the level-up racial bonus bug in awardXp (and the admin /level command), add even-level racial bonus re-application with diminishing returns stacking, wire racialManaRegen/racialStaminaRegen into the regen tick, wire racialSpellDamage/racialPhysDamage into combat ability damage, and implement the /unlockrace admin command.

Purpose: RACE-EXP-03 requires racial bonuses to persist and stack at even levels — the current code silently drops them. RACE-EXP-04 requires the admin unlock command. RACE-EXP-05 requires spell/physical damage bonuses to be active in combat, not just stored on the character row.
Output: awardXp preserves race bonuses every level and stacks them at even levels with notification. /level admin command fixed identically. /unlockrace command with world broadcast. Regen tick uses racial regen columns. executeAbility adds racial spell/phys damage to the raw damage calculation.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/21-race-expansion/21-CONTEXT.md
@.planning/phases/21-race-expansion/21-RESEARCH.md
@.planning/phases/21-race-expansion/21-01-SUMMARY.md
@spacetimedb/src/helpers/combat.ts
@spacetimedb/src/reducers/commands.ts
@spacetimedb/src/reducers/combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix awardXp level-up bug and add even-level racial bonus stacking</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
In `spacetimedb/src/helpers/combat.ts`, update the `awardXp` function (currently around lines 1899-1938).

**The bug:** When leveling up, `computeBaseStats` returns class-only stat values and they are assigned directly to the character row, silently overwriting any racial stat bonuses that were applied at creation.

**The fix + even-level stacking with diminishing returns:**

Replace the entire level-up block (after `const newBase = computeBaseStats(...)`) with this:

```typescript
const newBase = computeBaseStats(character.className, newLevel);

// Look up the character's race row by name (character.race is a display name string, not an ID).
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);

// Diminishing returns stacking formula (BigInt arithmetic throughout):
//   appNum = the application number (1-indexed), where appNum = evenLevel / 2
//   increment(appNum, baseValue) = baseValue * max(10n - BigInt(appNum), 1n) / 10n
//
//   Application 1 (level 2):  baseValue * 10/10 = 100% of base
//   Application 2 (level 4):  baseValue * 9/10  = 90% of base
//   Application 3 (level 6):  baseValue * 8/10  = 80% of base
//   Application 4 (level 8):  baseValue * 7/10  = 70% of base
//   Application 5 (level 10): baseValue * 6/10  = 60% of base
//   ...
//   Application 25 (level 50): baseValue * 1/10 = 10% of base (minimum floor)
//
// Total accumulated at newLevel = sum of increments for appNums 1..floor(newLevel/2)
// This ensures each even-level application adds strictly less than the previous.

function sumRacialAccumulated(baseValue: bigint, totalApplications: bigint): bigint {
  let total = 0n;
  for (let appNum = 1n; appNum <= totalApplications; appNum += 1n) {
    const factor = 10n - appNum > 1n ? 10n - appNum : 1n;
    total += baseValue * factor / 10n;
  }
  return total;
}

const totalApplications = newLevel / 2n; // BigInt floor division — even levels only

let racialStr = 0n, racialDex = 0n, racialInt = 0n, racialWis = 0n, racialCha = 0n;
let racialSpellDamage = 0n, racialPhysDamage = 0n;
let racialMaxHp = 0n, racialMaxMana = 0n;
let racialManaRegen = 0n, racialStaminaRegen = 0n;
let racialCritBonus = 0n, racialArmorBonus = 0n, racialDodgeBonus = 0n;

if (raceRow) {
  function accumulateBonus(bonusType: string, baseValue: bigint) {
    const accumulated = sumRacialAccumulated(baseValue, totalApplications);
    switch (bonusType) {
      case 'stat_str': racialStr += accumulated; break;
      case 'stat_dex': racialDex += accumulated; break;
      case 'stat_int': racialInt += accumulated; break;
      case 'stat_wis': racialWis += accumulated; break;
      case 'stat_cha': racialCha += accumulated; break;
      case 'spell_damage': racialSpellDamage += accumulated; break;
      case 'phys_damage': racialPhysDamage += accumulated; break;
      case 'max_hp': racialMaxHp += accumulated; break;
      case 'max_mana': racialMaxMana += accumulated; break;
      case 'mana_regen': racialManaRegen += accumulated; break;
      case 'stamina_regen': racialStaminaRegen += accumulated; break;
      case 'crit_chance': racialCritBonus += accumulated; break;
      case 'armor': racialArmorBonus += accumulated; break;
      case 'dodge': racialDodgeBonus += accumulated; break;
    }
  }
  accumulateBonus(raceRow.bonus1Type, raceRow.bonus1Value);
  accumulateBonus(raceRow.bonus2Type, raceRow.bonus2Value);
}

const updated = {
  ...character,
  level: newLevel,
  xp: newXp,
  str: newBase.str + racialStr,
  dex: newBase.dex + racialDex,
  cha: newBase.cha + racialCha,
  wis: newBase.wis + racialWis,
  int: newBase.int + racialInt,
  racialSpellDamage: racialSpellDamage || undefined,
  racialPhysDamage: racialPhysDamage || undefined,
  racialMaxHp: racialMaxHp || undefined,
  racialMaxMana: racialMaxMana || undefined,
  racialManaRegen: racialManaRegen || undefined,
  racialStaminaRegen: racialStaminaRegen || undefined,
  racialCritBonus: racialCritBonus || undefined,
  racialArmorBonus: racialArmorBonus || undefined,
  racialDodgeBonus: racialDodgeBonus || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);

// Notify on even-level racial bonus re-application
if (newLevel % 2n === 0n && raceRow) {
  appendPrivateEvent(
    ctx,
    character.id,
    character.ownerUserId,
    'system',
    `Your ${raceRow.name} heritage deepens at level ${newLevel} — racial bonuses strengthen.`
  );
}

return { xpGained: gained, leveledUp: true, newLevel };
```

**Formula correctness check (at level 50, base=1n):**
- Applications 1-9: increments are 10/10, 9/10, 8/10, 7/10, 6/10, 5/10, 4/10, 3/10, 2/10 → all floor to 1 or 0 for base=1n
- For base=2n: app1=2n, app2=1n, app3=1n, ..., app9=0n (floor), subsequent apps use factor=1 → 2*1/10=0
- For base=10n: app1=10n, app2=9n, app3=8n, ... app9=2n, app10=1n, app11-25=1n each
- Each application's increment is <= the previous — diminishing returns satisfied.

**Important:** `sumRacialAccumulated` is defined outside the if-block so it is reusable. `accumulateBonus` is defined inside the if-block. The `appendPrivateEvent` function must be imported — check if it is already imported at the top of combat.ts. If not, add the import from `helpers/events.ts`.

**All arithmetic uses BigInt:** every operation uses `bigint` literals (`1n`, `10n`, `2n`). No Number() conversions.
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Inspect awardXp for correct race row lookup: `ctx.db.race.iter()` with name match
3. Inspect `sumRacialAccumulated`: loop uses `appNum += 1n` and `factor = 10n - appNum > 1n ? 10n - appNum : 1n` — all BigInt
4. Inspect the even-level notification condition: `newLevel % 2n === 0n`
  </verify>
  <done>awardXp preserves racial stat bonuses at every level-up. At even levels, accumulated value uses per-application diminishing returns (each application's increment is smaller than the previous, computed via sumRacialAccumulated). Notification message fires on even levels. TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Fix level_character admin command, add /unlockrace command, wire racialManaRegen/racialStaminaRegen into regen tick</name>
  <files>
    spacetimedb/src/reducers/commands.ts
    spacetimedb/src/reducers/combat.ts
  </files>
  <action>
**A. Fix `level_character` admin reducer in `commands.ts` (same bug as awardXp):**

Find the `level_character` reducer (around lines 505-549). Replace the stat-setting block:

```typescript
// REMOVE this block:
const newBase = computeBaseStats(character.className, target);
const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str,
  dex: newBase.dex,
  cha: newBase.cha,
  wis: newBase.wis,
  int: newBase.int,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

Replace with (same diminishing returns formula as awardXp — extract `sumRacialAccumulated` into a shared helper file if the duplication is uncomfortable, otherwise copy inline):

```typescript
const newBase = computeBaseStats(character.className, target);
const raceRow = [...ctx.db.race.iter()].find((r: any) => r.name === character.race);
const totalApplications = target / 2n;

function sumRacialAccumulated(baseValue: bigint, apps: bigint): bigint {
  let total = 0n;
  for (let appNum = 1n; appNum <= apps; appNum += 1n) {
    const factor = 10n - appNum > 1n ? 10n - appNum : 1n;
    total += baseValue * factor / 10n;
  }
  return total;
}

let racialStr = 0n, racialDex = 0n, racialInt = 0n, racialWis = 0n, racialCha = 0n;
let racialSpellDamage = 0n, racialPhysDamage = 0n;
let racialMaxHp = 0n, racialMaxMana = 0n;
let racialManaRegen = 0n, racialStaminaRegen = 0n;
let racialCritBonus = 0n, racialArmorBonus = 0n, racialDodgeBonus = 0n;

if (raceRow) {
  function accumulateCmd(bonusType: string, baseValue: bigint) {
    const accumulated = sumRacialAccumulated(baseValue, totalApplications);
    switch (bonusType) {
      case 'stat_str': racialStr += accumulated; break;
      case 'stat_dex': racialDex += accumulated; break;
      case 'stat_int': racialInt += accumulated; break;
      case 'stat_wis': racialWis += accumulated; break;
      case 'stat_cha': racialCha += accumulated; break;
      case 'spell_damage': racialSpellDamage += accumulated; break;
      case 'phys_damage': racialPhysDamage += accumulated; break;
      case 'max_hp': racialMaxHp += accumulated; break;
      case 'max_mana': racialMaxMana += accumulated; break;
      case 'mana_regen': racialManaRegen += accumulated; break;
      case 'stamina_regen': racialStaminaRegen += accumulated; break;
      case 'crit_chance': racialCritBonus += accumulated; break;
      case 'armor': racialArmorBonus += accumulated; break;
      case 'dodge': racialDodgeBonus += accumulated; break;
    }
  }
  accumulateCmd(raceRow.bonus1Type, raceRow.bonus1Value);
  accumulateCmd(raceRow.bonus2Type, raceRow.bonus2Value);
}

const updated = {
  ...character,
  level: target,
  xp: xpRequiredForLevel(target),
  str: newBase.str + racialStr,
  dex: newBase.dex + racialDex,
  cha: newBase.cha + racialCha,
  wis: newBase.wis + racialWis,
  int: newBase.int + racialInt,
  racialSpellDamage: racialSpellDamage || undefined,
  racialPhysDamage: racialPhysDamage || undefined,
  racialMaxHp: racialMaxHp || undefined,
  racialMaxMana: racialMaxMana || undefined,
  racialManaRegen: racialManaRegen || undefined,
  racialStaminaRegen: racialStaminaRegen || undefined,
  racialCritBonus: racialCritBonus || undefined,
  racialArmorBonus: racialArmorBonus || undefined,
  racialDodgeBonus: racialDodgeBonus || undefined,
};
ctx.db.character.id.update(updated);
recomputeCharacterDerived(ctx, updated);
```

**B. Add `/unlockrace` command to `submit_command` in `commands.ts`:**

After the `/synccontent` block (around line 219) and before the `hailMatch` block, add:

```typescript
const unlockRaceMatch = trimmed.match(/^\/unlockrace\s+(.+)$/i);
if (unlockRaceMatch) {
  requireAdmin(ctx);
  const raceName = unlockRaceMatch[1].trim();
  let found = false;
  for (const race of ctx.db.race.iter()) {
    if (race.name.toLowerCase() === raceName.toLowerCase()) {
      if (race.unlocked) {
        appendPrivateEvent(
          ctx, character.id, requirePlayerUserId(ctx), 'system',
          `${race.name} is already unlocked.`
        );
        return;
      }
      ctx.db.race.id.update({ ...race, unlocked: true });
      appendWorldEvent(ctx, 'world_event', `A world-shaking event has occurred — the ${race.name} have emerged from hiding and may now walk among us!`);
      appendPrivateEvent(
        ctx, character.id, requirePlayerUserId(ctx), 'system',
        `Unlocked race: ${race.name}.`
      );
      found = true;
      break;
    }
  }
  if (!found) {
    appendPrivateEvent(
      ctx, character.id, requirePlayerUserId(ctx), 'system',
      `Race not found: "${raceName}". Check spelling (case-insensitive).`
    );
  }
  return;
}
```

**Import:** Update line 2 of commands.ts to add `appendWorldEvent` to the existing import:
```typescript
import { appendSystemMessage, appendWorldEvent } from '../helpers/events';
```

**C. Wire racialManaRegen and racialStaminaRegen into regen_health in `combat.ts`:**

Find the regen_health block (around line 1213-1232) where `manaRegenBonus` and `staminaRegenBonus` are summed from CharacterEffect rows:

After the CharacterEffect loop, add:
```typescript
// Add racial regen bonuses from Character row (these persist through death, unlike CharacterEffects)
manaRegenBonus += character.racialManaRegen ?? 0n;
staminaRegenBonus += character.racialStaminaRegen ?? 0n;
```

This ensures racial mana/stamina regen bonuses are applied every tick alongside food regen effects.

**D. Publish updated module (no --clear-database needed — no schema changes in this plan):**

```bash
spacetime publish <module-name> --project-path spacetimedb
```
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Check line 2 of commands.ts: `import { appendSystemMessage, appendWorldEvent } from '../helpers/events'`
3. Check submit_command for `/unlockrace` pattern match
4. Check regen_health block for `character.racialManaRegen ?? 0n` addition
5. `spacetime publish <module-name> --project-path spacetimedb` succeeds (no --clear-database)
6. `spacetime logs <module-name>` shows no errors
  </verify>
  <done>awardXp and level_character both preserve and stack racial bonuses with diminishing returns. /unlockrace command implemented with world broadcast. racialManaRegen and racialStaminaRegen added to regen tick. Module published successfully.</done>
</task>

<task type="auto">
  <name>Task 3: Wire racialSpellDamage and racialPhysDamage into executeAbility damage calculation</name>
  <files>spacetimedb/src/helpers/combat.ts</files>
  <action>
In `spacetimedb/src/helpers/combat.ts`, inside the `executeAbility` function, update the per-hit raw damage calculation in the single-target hit loop (around line 608-624).

**Current code (single-target hit loop):**
```typescript
let totalDamage = 0n;
const hitDamages: bigint[] = [];
for (let i = 0n; i < hits; i += 1n) {
  // Total raw damage
  const raw = weaponComponent + finalDirectDamage + totalDamageUp + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);

  // Route mitigation by damage type
  const dmgType = ability?.damageType ?? 'physical';
  let reduced: bigint;
  if (dmgType === 'magic') {
    // Magic damage bypasses armor entirely (makes magic impactful)
    reduced = raw > 0n ? raw : 1n;
  } else {
    // Physical damage uses armor mitigation
    reduced = applyArmorMitigation(raw, armor);
  }
  hitDamages.push(reduced);
  totalDamage += reduced;
}
```

**Replace with** (add racial damage bonus lookup before the loop, then add to raw per hit):
```typescript
// Read racial damage bonuses from character row — these are flat additions to each hit
const racialSpellBonus = character.racialSpellDamage ?? 0n;
const racialPhysBonus = character.racialPhysDamage ?? 0n;

let totalDamage = 0n;
const hitDamages: bigint[] = [];
for (let i = 0n; i < hits; i += 1n) {
  // Route racial bonus by damage type
  const dmgType = ability?.damageType ?? 'physical';
  const racialDamageBonus = dmgType === 'magic' ? racialSpellBonus : racialPhysBonus;

  // Total raw damage (racial bonus added per hit)
  const raw = weaponComponent + finalDirectDamage + totalDamageUp + racialDamageBonus + sumEnemyEffect(ctx, combatId, 'damage_taken', enemy.id);

  // Route mitigation by damage type
  let reduced: bigint;
  if (dmgType === 'magic') {
    // Magic damage bypasses armor entirely (makes magic impactful)
    reduced = raw > 0n ? raw : 1n;
  } else {
    // Physical damage uses armor mitigation
    reduced = applyArmorMitigation(raw, armor);
  }
  hitDamages.push(reduced);
  totalDamage += reduced;
}
```

**Why this location:** `finalDirectDamage` is the computed ability damage after stat scaling and multipliers. Adding racial bonus here matches the pattern for `totalDamageUp` (which is also a flat per-hit bonus from CharacterEffects). The racial bonus is flat (not percentage-based) and applies every hit, consistent with how it should scale with multi-hit abilities.

**AoE path:** The AoE branch (above this loop) computes `aoeDamage` from `finalDirectDamage` only — it does not use the per-hit loop. For simplicity and consistency with scope, racial damage is wired into the single-target path only. AoE racial bonus wiring can be added in a future plan if needed.

**Publish updated module:**
```bash
spacetime publish <module-name> --project-path spacetimedb
```
  </action>
  <verify>
1. `cd spacetimedb && npx tsc --noEmit` — no TypeScript errors
2. Inspect executeAbility: `racialSpellDamage ?? 0n` and `racialPhysDamage ?? 0n` assignments present before the hit loop
3. Inspect the raw damage line: includes `racialDamageBonus` term
4. `spacetime publish <module-name> --project-path spacetimedb` succeeds
5. `spacetime logs <module-name>` — no errors
  </verify>
  <done>executeAbility adds character.racialSpellDamage to raw damage for magic-type abilities and character.racialPhysDamage for physical-type abilities on every hit. TypeScript clean. Module published.</done>
</task>

</tasks>

<verification>
- TypeScript compiles clean across all modified files
- awardXp at even levels: racial bonuses use sumRacialAccumulated — each application's increment is strictly smaller than the previous (diminishing returns, not flat additive)
- awardXp at odd levels: racial bonuses still applied (totalApplications = floor(oddLevel/2) — same formula, just fewer applications)
- level_character admin command applies identical sumRacialAccumulated formula
- /unlockrace command matches regex, requires admin, updates Race.unlocked, broadcasts world event
- commands.ts import: `appendWorldEvent` present
- regen_health block adds character.racialManaRegen and character.racialStaminaRegen
- executeAbility single-target hit loop adds racialSpellDamage for magic damage, racialPhysDamage for physical damage
- Module publishes without error
</verification>

<success_criteria>
- Character leveled to 2 via natural XP: str/dex/etc include racial stat bonus (appNum=1 → 100% of base)
- Character leveled to 4: racial stat bonus = app1 + app2 = 100% + 90% of base each (strictly more than level 2 but app2 added less than app1)
- Character leveled to 10 via /level command: racial bonuses show correct diminishing sum across 5 applications
- `/unlockrace Dark-Elf` (as admin) sets Dark-Elf row to unlocked=true and fires world broadcast
- `/unlockrace NotARace` returns "Race not found" private event
- Non-admin `/unlockrace` throws (requireAdmin guard)
- An Eldrin wizard firing a spell ability deals more raw damage than a Human wizard at the same level (racialSpellDamage added to each hit)
- An Ironclad warrior firing a physical ability deals more raw damage than a Human warrior at the same level (racialPhysDamage added to each hit)
</success_criteria>

<output>
After completion, create `.planning/phases/21-race-expansion/21-02-SUMMARY.md` using the summary template.
</output>
