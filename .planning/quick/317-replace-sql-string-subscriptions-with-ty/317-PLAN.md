---
phase: quick-317
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/composables/data/useCoreData.ts
  - src/composables/data/useCombatData.ts
  - src/composables/data/useWorldData.ts
  - src/composables/data/useSocialData.ts
  - src/composables/data/useCraftingData.ts
  - src/composables/data/useQuestData.ts
  - src/composables/data/useWorldEventData.ts
autonomous: true
requirements: [QUICK-317]
must_haves:
  truths:
    - "All domain composable subscription SQL is generated by the typed query builder instead of hand-written strings"
    - "Location-scoped WHERE subscriptions in useWorldData use tables.X.where(r => r.locationId.eq(locId)).toSql()"
    - "Event table subscriptions in useGameData.ts remain as raw SQL strings (unchanged)"
    - "Application behavior is identical — no functional regression"
  artifacts:
    - path: "src/composables/data/useCoreData.ts"
      provides: "Core domain subscriptions via query builder"
      contains: "tables."
    - path: "src/composables/data/useWorldData.ts"
      provides: "Location-scoped WHERE subscriptions via query builder"
      contains: ".where("
  key_links:
    - from: "src/composables/data/*.ts"
      to: "src/module_bindings/index.ts"
      via: "import { tables } from module_bindings"
      pattern: "tables\\."
---

<objective>
Replace all raw SQL subscription strings in domain composables with the SpacetimeDB v2 typed query builder (`tables.X.toSql()` and `tables.X.where(...).toSql()`).

Purpose: Prevent typos in table/column names, get compile-time safety for subscription queries, and use the canonical SDK pattern instead of hand-written SQL strings.

Output: All 7 domain composables using `tables.X.toSql()` for `SELECT *` queries and `tables.X.where(r => r.col.eq(val)).toSql()` for WHERE-filtered queries. Event table subscriptions in useGameData.ts left unchanged.
</objective>

<execution_context>
@C:/Users/Dell/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dell/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/23-v2-subscription-optimization/23-RESEARCH.md
@src/composables/data/useCoreData.ts
@src/composables/data/useCombatData.ts
@src/composables/data/useWorldData.ts
@src/composables/data/useSocialData.ts
@src/composables/data/useCraftingData.ts
@src/composables/data/useQuestData.ts
@src/composables/data/useWorldEventData.ts
@src/composables/useGameData.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace SQL strings with query builder in all 7 domain composables</name>
  <files>
    src/composables/data/useCoreData.ts
    src/composables/data/useCombatData.ts
    src/composables/data/useWorldData.ts
    src/composables/data/useSocialData.ts
    src/composables/data/useCraftingData.ts
    src/composables/data/useQuestData.ts
    src/composables/data/useWorldEventData.ts
  </files>
  <action>
    Import `tables` and `toSql` from the generated module bindings in each composable:
    ```typescript
    import { tables } from '../../module_bindings';
    import { toSql } from 'spacetimedb';
    ```

    **For all 6 composables with simple `SELECT *` queries** (useCoreData, useCombatData, useSocialData, useCraftingData, useQuestData, useWorldEventData):

    Replace each raw SQL string in the `.subscribe([...])` array with `toSql(tables.table_name)`.

    Example for useCoreData.ts — replace:
    ```typescript
    .subscribe([
      'SELECT * FROM player',
      'SELECT * FROM user',
      ...
    ]);
    ```
    with:
    ```typescript
    .subscribe([
      toSql(tables.player),
      toSql(tables.user),
      ...
    ]);
    ```

    The `toSql()` function from `spacetimedb` takes a query object and returns the SQL string. `tables.player` is a `TableRef` which implements `Query`, so `toSql(tables.player)` returns `SELECT * FROM "player"` (with properly quoted identifiers).

    **For useWorldData.ts — two subscription groups:**

    Group B (global/template tables) — same pattern as above, replace strings with `toSql(tables.X)`:
    ```typescript
    .subscribe([
      toSql(tables.enemy_spawn_member),
      toSql(tables.enemy_template),
      toSql(tables.enemy_role_template),
      toSql(tables.enemy_ability),
      toSql(tables.vendor_inventory),
      toSql(tables.resource_gather),
      toSql(tables.corpse_item),
    ]);
    ```

    Group A (location-scoped WHERE queries) — replace the string interpolation with the query builder's `.where()`:
    ```typescript
    const queries = [
      toSql(tables.enemy_spawn.where(r => r.locationId.eq(locId))),
      toSql(tables.npc.where(r => r.locationId.eq(locId))),
      toSql(tables.named_enemy.where(r => r.locationId.eq(locId))),
      toSql(tables.resource_node.where(r => r.locationId.eq(locId))),
      toSql(tables.corpse.where(r => r.locationId.eq(locId))),
      toSql(tables.search_result.where(r => r.locationId.eq(locId))),
    ];
    ```

    Note: `locId` is a `bigint` — the query builder's `literalValueToSql` handles bigint via `String(value)` which produces the correct numeric literal.

    **DO NOT touch** useGameData.ts — the 4 event table subscriptions (`event_world`, `event_location`, `event_private`, `event_group`) should remain as raw SQL strings since they use the `onInsert` pattern and are intentionally kept separate.

    **Verify** the `toSql` import path: it should be `import { toSql } from 'spacetimedb'` (the `toSql` function is exported from `spacetimedb/src/lib/query.ts` and re-exported from the main package). If not re-exported, use `import { toSql } from 'spacetimedb/query'` or the path that works. Check the package exports.

    **Alternative if `toSql` is not directly importable from `spacetimedb`:** Each `TableRef` has its own `.toSql()` method, so you can call `tables.player.toSql()` directly instead of `toSql(tables.player)`. Use whichever approach compiles.
  </action>
  <verify>
    <automated>cd C:/projects/uwr && npx vue-tsc --noEmit 2>&1 | head -30</automated>
    <manual>Grep all 7 composable files for raw SQL strings — none should remain except in useGameData.ts event subscriptions. All subscription arrays should reference `tables.` or `toSql(`.</manual>
  </verify>
  <done>
    All 7 domain composables use `toSql(tables.X)` or `tables.X.toSql()` for `SELECT *` subscriptions.
    useWorldData.ts uses `toSql(tables.X.where(r => r.locationId.eq(locId)))` for WHERE-filtered subscriptions.
    useGameData.ts event table subscriptions remain as raw SQL strings (4 strings unchanged).
    TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx vue-tsc --noEmit` passes (no type errors from query builder usage)
2. No raw SQL strings remain in the 7 domain composable files (grep for `'SELECT` or `"SELECT` should return 0 matches in `src/composables/data/`)
3. Raw SQL strings still present in `src/composables/useGameData.ts` for the 4 event tables (intentionally unchanged)
4. Each composable imports `tables` from module_bindings
</verification>

<success_criteria>
- Zero hand-written SQL subscription strings in any domain composable under `src/composables/data/`
- All subscription queries generated by `tables.X.toSql()` or `toSql(tables.X.where(...))`
- TypeScript compilation passes
- No functional change to application behavior (same SQL is generated at runtime)
</success_criteria>

<output>
After completion, create `.planning/quick/317-replace-sql-string-subscriptions-with-ty/317-SUMMARY.md`
</output>
