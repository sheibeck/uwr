# Architecture

**Analysis Date:** 2026-02-11

## Pattern Overview

**Overall:** Two-tier architecture with SpacetimeDB backend (server) and Vue 3 SPA frontend (client)

**Key Characteristics:**
- Server-driven data model using SpacetimeDB tables, reducers, and views
- Event-based communication through reduced state changes
- Client subscribes to server state; UI renders reactive state
- Reducer-centric state mutations (no return values to client)
- View-based data filtering for privacy and performance

## Layers

**Backend (SpacetimeDB - `spacetimedb/src/`):**
- Purpose: Authoritative game state, transaction handling, business logic validation
- Location: `C:\projects\uwr\spacetimedb\src\`
- Contains: Tables (data schema), Reducers (mutations), Views (computed data), Data helpers
- Depends on: SpacetimeDB SDK, game data (abilities, classes, XP), group/combat helpers
- Used by: Frontend via generated bindings and subscriptions

**Frontend (Vue 3 SPA - `src/`):**
- Purpose: UI rendering, user interaction, local state coordination, real-time updates
- Location: `C:\projects\uwr\src\`
- Contains: Components (Vue SFC), Composables (reusable logic), UI styling, Auth integration
- Depends on: SpacetimeDB client SDK, generated module bindings
- Used by: Browser client

**Generated Bindings (`src/module_bindings/`):**
- Purpose: Type-safe bridge between client and server
- Location: `C:\projects\uwr\src\module_bindings\`
- Contains: Auto-generated table types, reducer signatures, view types
- Generated by: `spacetime generate` CLI command
- Updated: When backend schema changes, regenerate and commit

## Data Flow

**Character Creation Flow:**

1. User opens character creation panel (`CharacterPanel.vue`)
2. Form validated and submitted (`createCharacter()` from `useCharacterCreation.ts`)
3. Client calls reducer: `conn.reducers.createCharacter({ ...props })`
4. Backend reducer processes (`spacetimedb/src/reducers/characters.ts: create_character`)
5. Character inserted into `Character` table
6. Starter items granted via `grantStarterItems()` helper
7. Client subscribes to `tables.character` via `useTable(tables.character)`
8. UI updates automatically via Vue reactive ref

**Combat Flow:**

1. User pulls enemy via `CombatPanel.vue` → `startPull(enemyId, pullType)`
2. Calls reducer: `conn.reducers.startCombatWithEnemy({ characterId, enemyId })`
3. Backend: Creates `CombatEncounter` row, spawns combat participants
4. Server schedules combat rounds via scheduled table `CombatAction`
5. Reducers apply damage, track cooldowns, manage turns
6. Client subscribed to combat tables: `combatEncounters`, `combatParticipants`, `combatEnemies`
7. Combat panel renders based on reactive state

**Item Acquisition Flow:**

1. Vendor purchase: `buyItem(templateId)` → `conn.reducers.buyItem({ characterId, npcId, itemTemplateId })`
2. Backend validates inventory space, deducts gold, creates `ItemInstance`
3. Client subscribed to `itemInstances` updates inventory
4. UI renders in `InventoryPanel.vue`

**State Management:**

- **Server-Authoritative:** All persistent state lives on server (SpacetimeDB tables)
- **Client Subscriptions:** Frontend subscribes to tables via `useTable()` composable
- **Reactive Refs:** Each composable returns computed refs; Vue tracks changes
- **Local UI State:** UI-only state (panel positions, tooltips, drag state) via Vue `ref()` and `reactive()`
- **No Optimistic Updates:** UI waits for server confirmation before changing display

## Key Abstractions

**Table (Schema):**
- Purpose: Define data structure and access patterns
- Examples: `Character`, `ItemInstance`, `CombatEncounter` in `spacetimedb/src/index.ts`
- Pattern: `table(options, columns)` where options include indexes and privacy settings
- Access: `ctx.db.tableName` in reducers, `useTable(tables.tableName)` on client

**Reducer (Mutation):**
- Purpose: Transactional state change triggered by client
- Examples: `create_character`, `start_combat_with_enemy` in `spacetimedb/src/reducers/*.ts`
- Pattern: `spacetimedb.reducer(name, { args }, (ctx, args) => { ctx.db.table.operation() })`
- Called: `conn.reducers.camelCaseName({ param: value })` on client

**View (Computed Data):**
- Purpose: Filter table data based on permissions or compute derived state
- Examples: `my_player`, `my_group_members` in `spacetimedb/src/views/*.ts`
- Pattern: Returns subset of table filtered by `ctx.sender` or computed calculation
- Subscribed: `useTable(tables.viewName)` on client

**Composable (Client Logic):**
- Purpose: Reusable Vue 3 composition (state + methods) for specific domain
- Examples: `useCharacters()`, `useCombat()`, `useInventory()` in `src/composables/*.ts`
- Pattern: Returns object with reactive refs and computed properties
- Used: Imported into components, composables can depend on other composables

**Component (UI):**
- Purpose: Vue single-file component for rendering
- Examples: `CombatPanel.vue`, `InventoryPanel.vue` in `src/components/`
- Pattern: Template + script + styles; accepts props, emits events
- Data: Received via props from `App.vue` (orchestrator pulls from composables)

**Helper (Utility):**
- Purpose: Shared business logic functions
- Examples: `getGroupOrSoloParticipants()` in `spacetimedb/src/helpers/group.ts`
- Pattern: Pure functions or functions taking `ctx` for DB access
- Used: Called from reducers and other helpers

**Data Catalog (Constants):**
- Purpose: Game-wide reference data
- Examples: `ABILITIES` (ability definitions), class stats, XP curve in `spacetimedb/src/data/*.ts`
- Pattern: Exported constants/maps used in reducers and views
- Immutable: Never modified at runtime

## Entry Points

**Backend:**
- Location: `spacetimedb/src/index.ts`
- Triggers: SpacetimeDB module startup, table initialization
- Responsibilities: Register all tables, register reducers via `registerReducers(deps)`, register views via `registerViews(deps)`

**Frontend:**
- Location: `src/main.ts`
- Triggers: Browser app load
- Responsibilities: Initialize SpacetimeDB client connection, set up Vue app with `SpacetimeDBProvider`, mount to `#app`

**Application:**
- Location: `src/App.vue`
- Triggers: Mounted after provider ready
- Responsibilities: Orchestrate all composables, manage top-level UI state (panels, tooltips, window positions), render child components

## Error Handling

**Strategy:** Backend validates and rejects invalid actions; frontend handles connection errors

**Patterns:**

**Backend Validation:**
- Throw `SenderError` in reducers for invalid requests (e.g., "Not enough gold")
- Checked in all reducers: `requireCharacterOwnedBy()`, `requirePlayerUserId()`
- Client receives no return value; server logs event and client shows event log entry

**Frontend Connection:**
- `onConnectError` handler in `main.ts` detects 401/Unauthorized, clears auth token, reloads
- `conn.isActive` computed ref tracks connection state
- Disabled UI elements when `!conn.isActive`

**Client-Side Validation:**
- Pre-submission checks (inventory space, gold, character alive) to prevent rejected reducers
- Always fetch latest state before action (e.g., check inventory before equipping)

## Cross-Cutting Concerns

**Logging:** Event-based via `EventWorld`, `EventLocation`, `EventPrivate`, `EventGroup` tables in backend
- Entries appended by reducers using `appendPrivateEvent()`, `appendLocationEvent()`, etc.
- Client subscribed to event tables, renders in `LogWindow.vue`

**Validation:**
- Backend: Reducer functions validate before mutation (e.g., `if (!row) throw new SenderError()`)
- Frontend: Pre-checks before calling reducer (e.g., `if (!selectedCharacter.value) return`)
- Pattern: Fail-safe; invalid actions silently ignored on client, rejected on server

**Authentication:**
- SpacetimeAuth OIDC provider via `spacetimeAuth.ts`
- Client token stored in localStorage, passed to `DbConnection.builder().withToken()`
- Server validates token; `ctx.sender` is authenticated identity
- Session tracked in `Player` and `User` tables

**Ability Cooldowns:**
- Global cooldown: `GLOBAL_COOLDOWN_MICROS` enforced in ability reducer
- Per-ability: `AbilityCooldown` table tracks expiration per character
- UI: `useHotbar.ts` computes remaining cooldown for display

**Combat Locks:**
- `useCombatLock.ts` prevents inventory/hotbar edits during combat
- Checks: `selectedCharacter.value && activeCombat.value && activeCombat status === 'active'`
- Components disabled via `combat-locked` prop when locked

**Timestamp Handling:**
- Server: `ctx.timestamp` is `Timestamp` object with `.microsSinceUnixEpoch` property
- Client: Convert to Date: `new Date(Number(row.createdAt.microsSinceUnixEpoch / 1000n))`
- UI: `formatTimestamp()` in `App.vue` handles conversion

---

*Architecture analysis: 2026-02-11*
